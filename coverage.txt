/home/johnpaul/pire/fuzz.cpp:
    1|       |#include <cstdint>
    2|       |#include <cstdlib>
    3|       |#include <vector>
    4|       |
    5|       |#include "pire/pire.h"
    6|       |
    7|   100k|Pire::NonrelocScanner Compile(const char* p) {
    8|   100k|    std::vector<Pire::wchar32> ucs4;
    9|   100k|    Pire::Encodings::Utf8().FromLocal(p, p + strlen(p), std::back_inserter(ucs4));
   10|   100k|    return Pire::Lexer(ucs4.begin(), ucs4.end())
   11|   100k|        .SetEncoding(Pire::Encodings::Utf8())
   12|   100k|        .Parse()
   13|   100k|        .Surround()
   14|   100k|        .Compile<Pire::NonrelocScanner>();
   15|   100k|}
   16|       |
   17|   100k|bool Matches(const Pire::NonrelocScanner& scanner, const char* p, size_t size) {
   18|   100k|    return Pire::Runner(scanner)
   19|   100k|        .Begin()
   20|   100k|        .Run(p, size)
   21|   100k|        .End();
   22|   100k|}
   23|       |
   24|   100k|extern "C" int LLVMFuzzerTestOneInput(const std::uint8_t* data, std::size_t size) {
   25|       |    //auto scanner = Compile("hell{2,4}(o+)'\1-!@~'70*\|/");
   26|       |    //auto scanner = Compile("777");
   27|       |    //auto scanner = Compile("0");
   28|       |    //auto scanner = Compile("123456789!@#$%^&*");
   29|       |    //auto scanner = Compile("alert(echo('hello')");
   30|       |    //auto scanner = Compile("%");
   31|       |    //auto scanner = Compile("test.io");
   32|       |    //auto scanner = Compile("ABCDlXYZ");
   33|       |    //auto scanner = Compile("<header>");
   34|   100k|    auto scanner = Compile("os.system(/bin/bash)");
   35|       |    //auto scanner = Compile("II");
   36|   100k|    Matches(scanner, (const char*) data, size);
   37|   100k|    return 0;
   38|   100k|}

/home/johnpaul/pire/pire/align.h:
    1|       |/*
    2|       | * align.h -- functions for positioning streams and memory pointers
    3|       | *            to word boundaries
    4|       | *
    5|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    6|       | *                          Alexander Gololobov <agololobov@gmail.com>
    7|       | *
    8|       | * This file is part of Pire, the Perl Incompatible
    9|       | * Regular Expressions library.
   10|       | *
   11|       | * Pire is free software: you can redistribute it and/or modify
   12|       | * it under the terms of the GNU Lesser Public License as published by
   13|       | * the Free Software Foundation, either version 3 of the License, or
   14|       | * (at your option) any later version.
   15|       | * 
   16|       | * Pire is distributed in the hope that it will be useful,
   17|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   18|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   19|       | * GNU Lesser Public License for more details.
   20|       | * You should have received a copy of the GNU Lesser Public License
   21|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   22|       | */
   23|       |
   24|       |
   25|       |#ifndef PIRE_ALIGN_H
   26|       |#define PIRE_ALIGN_H
   27|       |
   28|       |#include "stub/stl.h"
   29|       |#include "stub/saveload.h"
   30|       |#include "platform.h"
   31|       |
   32|       |namespace Pire {
   33|       |	
   34|       |	namespace Impl {
   35|       |
   36|       |		template<class T>
   37|       |		inline T AlignUp(T t, size_t bound)
   38|   151M|		{
   39|   151M|			return (T) (((size_t) t + (bound-1)) & ~(bound-1));
   40|   151M|		}
  ------------------
  | _ZN4Pire4Impl7AlignUpImEET_S2_m:
  |   38|   151M|		{
  |   39|   151M|			return (T) (((size_t) t + (bound-1)) & ~(bound-1));
  |   40|   151M|		}
  ------------------
  | _ZN4Pire4Impl7AlignUpIPcEET_S3_m:
  |   38|   100k|		{
  |   39|   100k|			return (T) (((size_t) t + (bound-1)) & ~(bound-1));
  |   40|   100k|		}
  ------------------
  | _ZN4Pire4Impl7AlignUpIPKDv2_xEET_S5_m:
  |   38|  92.0k|		{
  |   39|  92.0k|			return (T) (((size_t) t + (bound-1)) & ~(bound-1));
  |   40|  92.0k|		}
  ------------------
  | Unexecuted instantiation: _ZN4Pire4Impl7AlignUpIPKmEET_S4_m
  ------------------
   41|       |
   42|       |		template<class T>
   43|       |		inline T AlignDown(T t, size_t bound)
   44|  92.0k|		{
   45|  92.0k|			return (T) ((size_t) t & ~(bound-1));
   46|  92.0k|		}
   47|       |		
   48|       |		inline void AlignSave(yostream* s, size_t size)
   49|      0|		{
   50|      0|			size_t tail = AlignUp(size, sizeof(size_t)) - size;
   51|      0|			if (tail) {
   52|      0|				static const char buf[sizeof(MaxSizeWord)] = {0};
   53|      0|				SavePodArray(s, buf, tail);
   54|      0|			}
   55|      0|		}
   56|       |
   57|       |		inline void AlignLoad(yistream* s, size_t size)
   58|      0|		{
   59|      0|			size_t tail = AlignUp(size, sizeof(size_t)) - size;
   60|      0|			if (tail) {
   61|      0|				char buf[sizeof(MaxSizeWord)];
   62|      0|				LoadPodArray(s, buf, tail);
   63|      0|			}
   64|      0|		}
   65|       |		
   66|       |		template<class T>
   67|       |		inline void AlignedSaveArray(yostream* s, const T* array, size_t count)
   68|       |		{
   69|       |			SavePodArray(s, array, count);
   70|       |			AlignSave(s, sizeof(*array) * count);
   71|       |		}
   72|       |
   73|       |		template<class T>
   74|       |		inline void AlignedLoadArray(yistream* s, T* array, size_t count)
   75|       |		{
   76|       |			LoadPodArray(s, array, count);
   77|       |			AlignLoad(s, sizeof(*array) * count);
   78|       |		}
   79|       |
   80|       |		template<class T>
   81|       |		inline bool IsAligned(T t, size_t bound)
   82|   100k|		{
   83|   100k|			return ((size_t) t & (bound-1)) == 0;
   84|   100k|		}
  ------------------
  | _ZN4Pire4Impl9IsAlignedIPKvEEbT_m:
  |   82|   100k|		{
  |   83|   100k|			return ((size_t) t & (bound-1)) == 0;
  |   84|   100k|		}
  ------------------
  | Unexecuted instantiation: _ZN4Pire4Impl9IsAlignedIPKmEEbT_m
  ------------------
   85|       |		
   86|       |		inline const void* AlignPtr(const size_t*& p, size_t& size)
   87|      0|		{
   88|      0|			if (!IsAligned(p, sizeof(size_t))) {
   89|      0|				const size_t* next = AlignUp(p, sizeof(size_t));
   90|      0|				if (next > p+size)
   91|      0|					throw Error("EOF reached in NPire::Impl::align");
   92|      0|				size -= (next - p);
   93|      0|				p = next;
   94|      0|			}
   95|      0|			return (const void*) p;
   96|      0|		}
   97|       |
   98|       |	}
   99|       |	
  100|       |}
  101|       |
  102|       |#endif

/home/johnpaul/pire/pire/any.h:
    1|       |/*
    2|       | * any.h -- a wrapper capable of holding a value of arbitrary type.
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#ifndef PIRE_ANY_H
   25|       |#define PIRE_ANY_H
   26|       |
   27|       |
   28|       |#include <typeinfo>
   29|       |
   30|       |#include "stub/stl.h"
   31|       |
   32|       |namespace Pire {
   33|       |
   34|       |class Any {
   35|       |
   36|       |public:
   37|   400k|	Any() = default;
   38|       |
   39|       |	Any(const Any& any)
   40|  5.90M|	{
   41|  5.90M|		if (any.h)
   42|  5.40M|			h = any.h->Duplicate();
   43|  5.90M|	}
   44|       |
   45|       |	Any& operator= (Any any)
   46|  1.90M|	{
   47|  1.90M|		any.Swap(*this);
   48|  1.90M|		return *this;
   49|  1.90M|	}
   50|       |
   51|       |	template <class T>
   52|       |	Any(const T& t)
   53|       |		: h(new Holder<T>(t))
   54|  3.70M|	{
   55|  3.70M|	}
  ------------------
  | _ZN4Pire3AnyC2INS_5ypairINS_4TSetINS_7TVectorIjSaIjEEESt4lessIS6_ESaIS6_EEEbEEEERKT_:
  |   54|  3.40M|	{
  |   55|  3.40M|	}
  ------------------
  | Unexecuted instantiation: _ZN4Pire3AnyC2INS_5ypairIiiEEEERKT_
  ------------------
  | _ZN4Pire3AnyC2INS_4Term6DotTagEEERKT_:
  |   54|   100k|	{
  |   55|   100k|	}
  ------------------
  | Unexecuted instantiation: _ZN4Pire3AnyC2INS_4Term8BeginTagEEERKT_
  ------------------
  | Unexecuted instantiation: _ZN4Pire3AnyC2INS_4Term6EndTagEEERKT_
  ------------------
  | _ZN4Pire3AnyC2INS_3FsmEEERKT_:
  |   54|   200k|	{
  |   55|   200k|	}
  ------------------
   56|       |
   57|  2.10M|	bool Empty() const {
   58|  2.10M|		return !h;
   59|  2.10M|	}
   60|       |	template <class T>
   61|  17.5M|	bool IsA() const {
   62|  17.5M|		return h && h->IsA(typeid(T));
   63|  17.5M|	}
  ------------------
  | _ZNK4Pire3Any3IsAINS_5ypairINS_4TSetINS_7TVectorIjSaIjEEESt4lessIS6_ESaIS6_EEEbEEEEbv:
  |   61|  12.9M|	bool IsA() const {
  |   62|  12.9M|		return h && h->IsA(typeid(T));
  |   63|  12.9M|	}
  ------------------
  | _ZNK4Pire3Any3IsAINS_3FsmEEEbv:
  |   61|  4.40M|	bool IsA() const {
  |   62|  4.40M|		return h && h->IsA(typeid(T));
  |   63|  4.40M|	}
  ------------------
  | Unexecuted instantiation: _ZNK4Pire3Any3IsAINS_4Term8BeginTagEEEbv
  ------------------
  | Unexecuted instantiation: _ZNK4Pire3Any3IsAINS_4Term6EndTagEEEbv
  ------------------
  | _ZNK4Pire3Any3IsAINS_4Term6DotTagEEEbv:
  |   61|   200k|	bool IsA() const {
  |   62|   200k|		return h && h->IsA(typeid(T));
  |   63|   200k|	}
  ------------------
  | Unexecuted instantiation: _ZNK4Pire3Any3IsAINS_5ypairIiiEEEEbv
  ------------------
   64|       |
   65|       |	template <class T>
   66|       |	T& As()
   67|  5.70M|	{
   68|  5.70M|		if (h && IsA<T>())
   69|  5.70M|			return *reinterpret_cast<T*>(h->Ptr());
   70|      0|		else
   71|      0|			throw Pire::Error("type mismatch");
   72|  5.70M|	}
  ------------------
  | _ZN4Pire3Any2AsINS_3FsmEEERT_v:
  |   67|  2.30M|	{
  |   68|  2.30M|		if (h && IsA<T>())
  |   69|  2.30M|			return *reinterpret_cast<T*>(h->Ptr());
  |   70|      0|		else
  |   71|      0|			throw Pire::Error("type mismatch");
  |   72|  2.30M|	}
  ------------------
  | _ZN4Pire3Any2AsINS_5ypairINS_4TSetINS_7TVectorIjSaIjEEESt4lessIS6_ESaIS6_EEEbEEEERT_v:
  |   67|  3.40M|	{
  |   68|  3.40M|		if (h && IsA<T>())
  |   69|  3.40M|			return *reinterpret_cast<T*>(h->Ptr());
  |   70|      0|		else
  |   71|      0|			throw Pire::Error("type mismatch");
  |   72|  3.40M|	}
  ------------------
  | Unexecuted instantiation: _ZN4Pire3Any2AsINS_5ypairIiiEEEERT_v
  ------------------
   73|       |
   74|       |	template <class T>
   75|       |	const T& As() const
   76|  3.40M|	{
   77|  3.40M|		if (h && IsA<T>())
   78|  3.40M|			return *reinterpret_cast<const T*>(h->Ptr());
   79|      0|		else
   80|      0|			throw Pire::Error("type mismatch");
   81|  3.40M|	}
   82|       |
   83|  1.90M|	void Swap(Any& a) noexcept {
   84|  1.90M|		DoSwap(h, a.h);
   85|  1.90M|	}
   86|       |
   87|       |private:
   88|       |
   89|       |	struct AbstractHolder {
   90|  9.10M|		virtual ~AbstractHolder() {
   91|  9.10M|		}
   92|       |		virtual std::unique_ptr<AbstractHolder> Duplicate() const = 0;
   93|       |		virtual bool IsA(const std::type_info& id) const = 0;
   94|       |		virtual void* Ptr() = 0;
   95|       |		virtual const void* Ptr() const = 0;
   96|       |	};
   97|       |
   98|       |	template <class T>
   99|       |	struct Holder: public AbstractHolder {
  100|       |		Holder(T t)
  101|       |			: d(t)
  102|  9.10M|		{
  103|  9.10M|		}
  ------------------
  | _ZN4Pire3Any6HolderINS_5ypairINS_4TSetINS_7TVectorIjSaIjEEESt4lessIS6_ESaIS6_EEEbEEEC2ESB_:
  |  102|  8.50M|		{
  |  103|  8.50M|		}
  ------------------
  | Unexecuted instantiation: _ZN4Pire3Any6HolderINS_5ypairIiiEEEC2ES3_
  ------------------
  | _ZN4Pire3Any6HolderINS_4Term6DotTagEEC2ES3_:
  |  102|   300k|		{
  |  103|   300k|		}
  ------------------
  | Unexecuted instantiation: _ZN4Pire3Any6HolderINS_4Term8BeginTagEEC2ES3_
  ------------------
  | Unexecuted instantiation: _ZN4Pire3Any6HolderINS_4Term6EndTagEEC2ES3_
  ------------------
  | _ZN4Pire3Any6HolderINS_3FsmEEC2ES2_:
  |  102|   300k|		{
  |  103|   300k|		}
  ------------------
  104|  5.40M|		std::unique_ptr<AbstractHolder> Duplicate() const {
  105|  5.40M|			return std::unique_ptr<AbstractHolder>(new Holder<T>(d));
  106|  5.40M|		}
  ------------------
  | _ZNK4Pire3Any6HolderINS_5ypairINS_4TSetINS_7TVectorIjSaIjEEESt4lessIS6_ESaIS6_EEEbEEE9DuplicateEv:
  |  104|  5.10M|		std::unique_ptr<AbstractHolder> Duplicate() const {
  |  105|  5.10M|			return std::unique_ptr<AbstractHolder>(new Holder<T>(d));
  |  106|  5.10M|		}
  ------------------
  | Unexecuted instantiation: _ZNK4Pire3Any6HolderINS_5ypairIiiEEE9DuplicateEv
  ------------------
  | _ZNK4Pire3Any6HolderINS_4Term6DotTagEE9DuplicateEv:
  |  104|   200k|		std::unique_ptr<AbstractHolder> Duplicate() const {
  |  105|   200k|			return std::unique_ptr<AbstractHolder>(new Holder<T>(d));
  |  106|   200k|		}
  ------------------
  | Unexecuted instantiation: _ZNK4Pire3Any6HolderINS_4Term8BeginTagEE9DuplicateEv
  ------------------
  | Unexecuted instantiation: _ZNK4Pire3Any6HolderINS_4Term6EndTagEE9DuplicateEv
  ------------------
  | _ZNK4Pire3Any6HolderINS_3FsmEE9DuplicateEv:
  |  104|   100k|		std::unique_ptr<AbstractHolder> Duplicate() const {
  |  105|   100k|			return std::unique_ptr<AbstractHolder>(new Holder<T>(d));
  |  106|   100k|		}
  ------------------
  107|  16.9M|		bool IsA(const std::type_info& id) const {
  108|  16.9M|			return id == typeid(T);
  109|  16.9M|		}
  ------------------
  | _ZNK4Pire3Any6HolderINS_5ypairINS_4TSetINS_7TVectorIjSaIjEEESt4lessIS6_ESaIS6_EEEbEEE3IsAERKSt9type_info:
  |  107|  11.9M|		bool IsA(const std::type_info& id) const {
  |  108|  11.9M|			return id == typeid(T);
  |  109|  11.9M|		}
  ------------------
  | Unexecuted instantiation: _ZNK4Pire3Any6HolderINS_5ypairIiiEEE3IsAERKSt9type_info
  ------------------
  | _ZNK4Pire3Any6HolderINS_4Term6DotTagEE3IsAERKSt9type_info:
  |  107|   400k|		bool IsA(const std::type_info& id) const {
  |  108|   400k|			return id == typeid(T);
  |  109|   400k|		}
  ------------------
  | Unexecuted instantiation: _ZNK4Pire3Any6HolderINS_4Term8BeginTagEE3IsAERKSt9type_info
  ------------------
  | Unexecuted instantiation: _ZNK4Pire3Any6HolderINS_4Term6EndTagEE3IsAERKSt9type_info
  ------------------
  | _ZNK4Pire3Any6HolderINS_3FsmEE3IsAERKSt9type_info:
  |  107|  4.60M|		bool IsA(const std::type_info& id) const {
  |  108|  4.60M|			return id == typeid(T);
  |  109|  4.60M|		}
  ------------------
  110|  9.10M|		void* Ptr() {
  111|  9.10M|			return &d;
  112|  9.10M|		}
  ------------------
  | _ZN4Pire3Any6HolderINS_5ypairINS_4TSetINS_7TVectorIjSaIjEEESt4lessIS6_ESaIS6_EEEbEEE3PtrEv:
  |  110|  6.80M|		void* Ptr() {
  |  111|  6.80M|			return &d;
  |  112|  6.80M|		}
  ------------------
  | Unexecuted instantiation: _ZN4Pire3Any6HolderINS_5ypairIiiEEE3PtrEv
  ------------------
  | Unexecuted instantiation: _ZN4Pire3Any6HolderINS_4Term6DotTagEE3PtrEv
  ------------------
  | Unexecuted instantiation: _ZN4Pire3Any6HolderINS_4Term8BeginTagEE3PtrEv
  ------------------
  | Unexecuted instantiation: _ZN4Pire3Any6HolderINS_4Term6EndTagEE3PtrEv
  ------------------
  | _ZN4Pire3Any6HolderINS_3FsmEE3PtrEv:
  |  110|  2.30M|		void* Ptr() {
  |  111|  2.30M|			return &d;
  |  112|  2.30M|		}
  ------------------
  113|      0|		const void* Ptr() const {
  114|      0|			return &d;
  115|      0|		}
  ------------------
  | Unexecuted instantiation: _ZNK4Pire3Any6HolderINS_5ypairINS_4TSetINS_7TVectorIjSaIjEEESt4lessIS6_ESaIS6_EEEbEEE3PtrEv
  ------------------
  | Unexecuted instantiation: _ZNK4Pire3Any6HolderINS_5ypairIiiEEE3PtrEv
  ------------------
  | Unexecuted instantiation: _ZNK4Pire3Any6HolderINS_4Term6DotTagEE3PtrEv
  ------------------
  | Unexecuted instantiation: _ZNK4Pire3Any6HolderINS_4Term8BeginTagEE3PtrEv
  ------------------
  | Unexecuted instantiation: _ZNK4Pire3Any6HolderINS_4Term6EndTagEE3PtrEv
  ------------------
  | Unexecuted instantiation: _ZNK4Pire3Any6HolderINS_3FsmEE3PtrEv
  ------------------
  116|       |	private:
  117|       |		T d;
  118|       |	};
  119|       |
  120|       |	std::unique_ptr<AbstractHolder> h;
  121|       |};
  122|       |
  123|       |}
  124|       |
  125|       |namespace std {
  126|      0|	inline void swap(Pire::Any& a, Pire::Any& b) {
  127|      0|		a.Swap(b);
  128|      0|	}
  129|       |}
  130|       |
  131|       |#endif

/home/johnpaul/pire/pire/approx_matching.cpp:
    1|       |/*
    2|       | * approx_matching.cpp -- implementation of CreateApproxFsm function
    3|       | *
    4|       | * Copyright (c) 2019 YANDEX LLC, Karina Usmanova <usmanova.karin@yandex.ru>
    5|       | *
    6|       | * This file is part of Pire, the Perl Incompatible
    7|       | * Regular Expressions library.
    8|       | *
    9|       | * Pire is free software: you can redistribute it and/or modify
   10|       | * it under the terms of the GNU Lesser Public License as published by
   11|       | * the Free Software Foundation, either version 3 of the License, or
   12|       | * (at your option) any later version.
   13|       | *
   14|       | * Pire is distributed in the hope that it will be useful,
   15|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   16|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   17|       | * GNU Lesser Public License for more details.
   18|       | * You should have received a copy of the GNU Lesser Public License
   19|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   20|       | */
   21|       |
   22|       |
   23|       |#include "approx_matching.h"
   24|       |
   25|       |namespace Pire {
   26|      0|	Fsm CreateApproxFsm(const Fsm& regexp, size_t distance) {
   27|      0|		Fsm approxFsm = regexp;
   28|       |
   29|      0|		TVector<TSet<Char>> outgoingLettersTable(regexp.Size());
   30|      0|		for (size_t state = 0; state < regexp.Size(); ++state) {
   31|      0|			outgoingLettersTable[state] = regexp.OutgoingLetters(state);
   32|      0|		}
   33|       |
   34|      0|		TVector<TMap<Char, Fsm::StatesSet>> destinationsTable(regexp.Size());
   35|      0|		for (size_t state = 0; state < regexp.Size(); ++state) {
   36|      0|			for (Char letter : outgoingLettersTable[state]) {
   37|      0|				destinationsTable[state][letter] = regexp.Destinations(state, letter);
   38|      0|			}
   39|      0|		}
   40|       |
   41|      0|		for (size_t fsmIdx = 0; fsmIdx < distance; ++fsmIdx) {
   42|      0|			approxFsm.Import(regexp);
   43|      0|			const auto shift = fsmIdx * regexp.Size();
   44|       |
   45|      0|			for (size_t state = 0; state < regexp.Size(); ++state) {
   46|      0|				for (Char letter : outgoingLettersTable[state]) {
   47|      0|					for (size_t to : destinationsTable[state][letter]) {
   48|      0|						for (Char ch = 0; ch < MaxChar; ++ch) {
   49|      0|							if (!approxFsm.Connected(state + shift, to + shift, ch)) {
   50|      0|								approxFsm.Connect(state + shift, to + shift + regexp.Size(), ch);
   51|      0|							}
   52|      0|						}
   53|       |
   54|      0|						approxFsm.Connect(state + shift, to + shift + regexp.Size(), Epsilon);
   55|      0|					}
   56|       |
   57|      0|					for (Char ch = 0; ch < MaxChar; ++ch) {
   58|      0|						approxFsm.Connect(state + shift, state + shift + regexp.Size(), ch);
   59|      0|					}
   60|      0|				}
   61|       |
   62|      0|				if (regexp.IsFinal(state)) {
   63|      0|					approxFsm.SetFinal(state + shift + regexp.Size(), true);
   64|      0|				}
   65|      0|			}
   66|      0|		}
   67|       |
   68|      0|		size_t maxState = (distance > 0) ? approxFsm.Size() - regexp.Size() : 0;
   69|      0|		for (size_t state = 0; state < maxState; ++state) {
   70|      0|			size_t currentDist = state / regexp.Size();
   71|      0|			size_t intState = state % regexp.Size();
   72|       |
   73|      0|			for (Char firstLetter : outgoingLettersTable[intState]) {
   74|      0|				for (size_t firstDest : destinationsTable[intState][firstLetter]) {
   75|      0|					for (Char secondLetter : outgoingLettersTable[firstDest]) {
   76|      0|						for (size_t secondDest : destinationsTable[firstDest][secondLetter]) {
   77|      0|							if (secondDest != intState || firstDest != intState) {
   78|      0|								approxFsm.Resize(approxFsm.Size() + 1);
   79|       |
   80|      0|								size_t to = secondDest + (currentDist + 1) * regexp.Size();
   81|      0|								size_t middle = approxFsm.Size() - 1;
   82|       |
   83|      0|								approxFsm.Connect(state, middle, secondLetter);
   84|      0|								approxFsm.Connect(middle, to, firstLetter);
   85|      0|							}
   86|      0|						}
   87|      0|					}
   88|      0|				}
   89|      0|			}
   90|      0|		}
   91|       |
   92|      0|		return approxFsm;
   93|      0|	}
   94|       |}

/home/johnpaul/pire/pire/classes.cpp:
    1|       |/*
    2|       | * classes.cpp -- implementation for Pire::CharClasses feature.
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#include "stub/stl.h"
   25|       |#include "stub/singleton.h"
   26|       |#include "stub/noncopyable.h"
   27|       |#include "stub/utf8.h"
   28|       |#include "re_lexer.h"
   29|       |
   30|       |namespace Pire {
   31|       |
   32|       |namespace {
   33|       |
   34|       |	class CharClassesTable: private NonCopyable {
   35|       |	private:
   36|       |		class CharClass {
   37|       |		public:
   38|      8|			CharClass() {}
   39|     10|			explicit CharClass(wchar32 ch) { m_bounds.push_back(ymake_pair(ch, ch)); }
   40|      4|			CharClass(wchar32 lower, wchar32 upper) { m_bounds.push_back(ymake_pair(lower, upper)); }
   41|       |
   42|       |			CharClass& operator |= (const CharClass& cc)
   43|      8|			{
   44|      8|				std::copy(cc.m_bounds.begin(), cc.m_bounds.end(), std::back_inserter(m_bounds));
   45|      8|				return *this;
   46|      8|			}
   47|       |
   48|       |			CharClass  operator |  (const CharClass& cc) const
   49|      8|			{
   50|      8|				CharClass r(*this);
   51|      8|				r |= cc;
   52|      8|				return r;
   53|      8|			}
   54|       |
   55|       |			TSet<wchar32> ToSet() const
   56|      0|			{
   57|      0|				TSet<wchar32> ret;
   58|      0|				for (auto&& bound : m_bounds)
   59|      0|					for (wchar32 c = bound.first; c <= bound.second; ++c)
   60|      0|						ret.insert(c);
   61|      0|				return ret;
   62|      0|			}
   63|       |
   64|       |		private:
   65|       |			TVector<ypair<wchar32, wchar32> > m_bounds;
   66|       |		};
   67|       |
   68|       |	public:
   69|       |		bool Has(wchar32 wc) const
   70|      0|		{
   71|      0|			return (m_classes.find(to_lower(wc & ~ControlMask)) != m_classes.end());
   72|      0|		}
   73|       |
   74|       |		TSet<wchar32> Get(wchar32 wc) const
   75|      0|		{
   76|      0|			auto it = m_classes.find(to_lower(wc & ~ControlMask));
   77|      0|			if (it == m_classes.end())
   78|      0|				throw Error("Unknown character class");
   79|      0|			return it->second.ToSet();
   80|      0|		}
   81|       |
   82|       |		CharClassesTable()
   83|      1|		{
   84|      1|			m_classes['l'] = CharClass('A', 'Z') | CharClass('a', 'z');
   85|      1|			m_classes['c']
   86|      1|				= CharClass(0x0410, 0x044F) // Russian capital A to Russan capital YA, Russian small A to Russian small YA
   87|      1|				| CharClass(0x0401)         // Russian capital Yo
   88|      1|				| CharClass(0x0451)         // Russian small Yo
   89|      1|				;
   90|       |
   91|      1|			m_classes['w'] = m_classes['l'] | m_classes['c'];
   92|      1|			m_classes['d'] = CharClass('0', '9');
   93|      1|			m_classes['s']
   94|      1|				= CharClass(' ') | CharClass('\t') | CharClass('\r') | CharClass('\n')
   95|      1|				| CharClass(0x00A0)         // Non-breaking space
   96|      1|				;
   97|       |
   98|       |			// A few special classes which do not have any negation
   99|      1|			m_classes['n'] = CharClass('\n');
  100|      1|			m_classes['r'] = CharClass('\r');
  101|      1|			m_classes['t'] = CharClass('\t');
  102|      1|		}
  103|       |
  104|       |		TMap<wchar32, CharClass> m_classes;
  105|       |	};
  106|       |
  107|       |	class CharClassesImpl: public Feature {
  108|       |	public:
  109|   100k|		CharClassesImpl(): m_table(Singleton<CharClassesTable>()) {}
  110|   300k|		int Priority() const { return 10; }
  111|       |
  112|       |		void Alter(Term& t)
  113|  2.10M|		{
  114|  2.10M|			if (t.Value().IsA<Term::CharacterRange>()) {
  115|  1.70M|				const Term::CharacterRange& range = t.Value().As<Term::CharacterRange>();
  116|  1.70M|				typedef Term::CharacterRange::first_type CharSet;
  117|  1.70M|				const CharSet& old = range.first;
  118|  1.70M|				CharSet altered;
  119|  1.70M|				bool pos = false;
  120|  1.70M|				bool neg = false;
  121|  1.70M|				for (auto&& i : old)
  122|  1.70M|					if (i.size() == 1 && (i[0] & ControlMask) == Control && m_table->Has(i[0])) {
  123|      0|						if (is_upper(i[0] & ~ControlMask))
  124|      0|							neg = true;
  125|      0|						else
  126|      0|							pos = true;
  127|       |
  128|      0|						TSet<wchar32> klass = m_table->Get(i[0]);
  129|      0|						for (auto&& j : klass)
  130|      0|							altered.insert(Term::String(1, j));
  131|      0|					} else
  132|  1.70M|						altered.insert(i);
  133|       |
  134|  1.70M|				if (neg && (pos || range.second))
  135|      0|					Error("Positive and negative character ranges mixed");
  136|  1.70M|				t = Term(t.Type(), Term::CharacterRange(altered, neg || range.second));
  137|  1.70M|			}
  138|  2.10M|		}
  139|       |
  140|       |	private:
  141|       |		CharClassesTable* m_table;
  142|       |	};
  143|       |
  144|       |}
  145|       |
  146|       |namespace Features {
  147|   100k|	Feature::Ptr CharClasses() { return Feature::Ptr(new CharClassesImpl); }
  148|       |}
  149|       |
  150|       |}
  151|       |

/home/johnpaul/pire/pire/defs.h:
    1|       |/*
    2|       | * defs.h -- common Pire definitions.
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | *
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#ifndef PIRE_DEFS_H
   25|       |#define PIRE_DEFS_H
   26|       |
   27|       |#ifndef PIRE_NO_CONFIG
   28|       |#include <pire/config.h>
   29|       |#endif
   30|       |#include <stdlib.h>
   31|       |
   32|       |#if defined(_MSC_VER)
   33|       |#define PIRE_HAVE_DECLSPEC_ALIGN
   34|       |#else
   35|       |#ifndef PIRE_HAVE_ALIGNAS
   36|       |#define PIRE_HAVE_ALIGNAS
   37|       |#endif
   38|       |#endif
   39|       |
   40|       |#ifndef PIRE_HAVE_LAMBDAS
   41|       |#define PIRE_HAVE_LAMBDAS
   42|       |#endif
   43|       |
   44|       |namespace Pire {
   45|       |
   46|       |#ifdef PIRE_DEBUG
   47|       |#	define PIRE_IFDEBUG(x) x
   48|       |#else
   49|       |#	define PIRE_IFDEBUG(x)
   50|       |#endif
   51|       |
   52|       |#ifdef PIRE_CHECKED
   53|       |#	define PIRE_IF_CHECKED(e) e
   54|       |#else
   55|       |#	define PIRE_IF_CHECKED(e)
   56|       |#endif
   57|       |
   58|       |
   59|       |	typedef unsigned short Char;
   60|       |
   61|       |	namespace SpecialChar {
   62|       |	enum {
   63|       |		Epsilon = 257,
   64|       |		BeginMark = 258,
   65|       |		EndMark = 259,
   66|       |
   67|       |		// Actual size of input alphabet
   68|       |		MaxCharUnaligned = 260,
   69|       |
   70|       |		// Size of letter transition tables, must be a multiple of the machine word size
   71|       |		MaxChar = (MaxCharUnaligned + (sizeof(void*)-1)) & ~(sizeof(void*)-1)
   72|       |	};
   73|       |	}
   74|       |
   75|       |	using namespace SpecialChar;
   76|       |
   77|       |	namespace Impl {
   78|       |#ifndef PIRE_WORDS_BIGENDIAN
   79|  1.76M|		inline size_t ToLittleEndian(size_t val) { return val; }
   80|       |#else
   81|       |		template<unsigned N>
   82|       |		inline size_t SwapBytes(size_t val)
   83|       |		{
   84|       |			static const size_t Mask = (1 << (N/2)) - 1;
   85|       |			return ((SwapBytes<N/2>(val) & Mask) << (N/2)) | SwapBytes<N/2>(val >> (N/2));
   86|       |		}
   87|       |
   88|       |		template<>
   89|       |		inline size_t SwapBytes<8>(size_t val) { return val & 0xFF; }
   90|       |
   91|       |		inline size_t ToLittleEndian(size_t val) { return SwapBytes<sizeof(val)*8>(val); }
   92|       |#endif
   93|       |
   94|       |        struct Struct { void* p; };
   95|       |	}
   96|       |}
   97|       |
   98|       |#ifndef PIRE_ALIGNED_DECL
   99|       |#	if defined(PIRE_HAVE_ALIGNAS)
  100|       |#		define PIRE_ALIGNED_DECL(x) alignas(::Pire::Impl::Struct) static const char x[]
  101|       |#	elif defined(PIRE_HAVE_ATTR_ALIGNED)
  102|       |#		define PIRE_ALIGNED_DECL(x) static const char x[] __attribute__((aligned(sizeof(void*))))
  103|       |#	elif defined(PIRE_HAVE_DECLSPEC_ALIGN)
  104|       |#		define PIRE_ALIGNED_DECL(x) __declspec(align(8)) static const char x[]
  105|       |#	endif
  106|       |#endif
  107|       |
  108|       |#ifndef PIRE_LITERAL
  109|       |#	if defined(PIRE_HAVE_LAMBDAS)
  110|       |#		define PIRE_LITERAL(data) ([]() -> const char* { PIRE_ALIGNED_DECL(__pire_regexp__) = data; return __pire_regexp__; })()
  111|       |#	elif defined(PIRE_HAVE_SCOPED_EXPR)
  112|       |#		define PIRE_LITERAL(data) ({ PIRE_ALIGNED_DECL(__pire_regexp__) = data; __pire_regexp__; })
  113|       |#	endif
  114|       |#endif
  115|       |
  116|       |#endif

/home/johnpaul/pire/pire/determine.h:
    1|       |/*
    2|       | * determine.h -- the FSM determination routine.
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#ifndef PIRE_DETERMINE_H
   25|       |#define PIRE_DETERMINE_H
   26|       |
   27|       |#include "stub/stl.h"
   28|       |#include "partition.h"
   29|       |
   30|       |namespace Pire {
   31|       |	namespace Impl {
   32|       |
   33|       |		/**
   34|       |		 * An interface of a determination task.
   35|       |		 * You don't have to derive from this class; it is just a start point template.
   36|       |		 */
   37|       |		class DetermineTask {
   38|       |		private:
   39|       |			struct ImplementationSpecific1;
   40|       |			struct ImplementationSpecific2;
   41|       |
   42|       |		public:
   43|       |			/// A type representing a new state (may be a set of old states, a pair of them, etc...)
   44|       |			typedef ImplementationSpecific1 State;
   45|       |
   46|       |			/// A type of letter equivalence classes table.
   47|       |			typedef Partition<char, ImplementationSpecific2> LettersTbl;
   48|       |
   49|       |			/// A container used for storing map of states to thier indices.
   50|       |			typedef TMap<State, size_t> InvStates;
   51|       |
   52|       |			/// Should return used letters' partition.
   53|       |			const LettersTbl& Letters() const;
   54|       |
   55|       |			/// Should return initial state (surprise!)
   56|       |			State Initial() const;
   57|       |
   58|       |			/// Should calculate next state, given the current state and a letter.
   59|       |			State Next(State state, Char letter) const;
   60|       |
   61|       |			/// Should return true iff the state need to be processed.
   62|      0|			bool IsRequired(const State& /*state*/) const { return true; }
   63|       |
   64|       |			/// Called when the set of new states is closed.
   65|       |			void AcceptStates(const TVector<State>& newstates);
   66|       |
   67|       |			/// Called for each transition from one new state to another.
   68|       |			void Connect(size_t from, size_t to, Char letter);
   69|       |
   70|       |			typedef bool Result;
   71|      0|			Result Success() { return true; }
   72|      0|			Result Failure() { return false; }
   73|       |		};
   74|       |
   75|       |		/**
   76|       |		 * A helper function for FSM determining and all determine-like algorithms
   77|       |		 * like scanners' agglutination.
   78|       |		 *
   79|       |		 * Given an indirectly specified automaton (through Task::Initial() and Task::Next()
   80|       |		 * functions, see above), performs a breadth-first traversal, finding and enumerating
   81|       |		 * all effectively reachable states. Then passes all found states and transitions
   82|       |		 * between them back to the task.
   83|       |		 *
   84|       |		 * Initial state is always placed at zero position.
   85|       |		 *
   86|       |		 * Please note that the function does not take care of any payload (including final flags);
   87|       |		 * it is the task's responsibility to agglutinate them properly.
   88|       |		 *
   89|       |		 * Returns task.Succeed() if everything was done; task.Failure() if maximum limit of state count was reached.
   90|       |		 */
   91|       |		template<class Task>
   92|       |		typename Task::Result Determine(Task& task, size_t maxSize)
   93|   100k|		{
   94|   100k|			typedef typename Task::State State;
   95|   100k|			typedef typename Task::InvStates InvStates;
   96|   100k|			typedef TDeque< TVector<size_t> > TransitionTable;
   97|       |
   98|   100k|			TVector<State> states;
   99|   100k|			InvStates invstates;
  100|   100k|			TransitionTable transitions;
  101|   100k|			TVector<size_t> stateIndices;
  102|       |
  103|   100k|			states.push_back(task.Initial());
  104|   100k|			invstates.insert(typename InvStates::value_type(states[0], 0));
  105|       |
  106|  2.90M|			for (size_t stateIdx = 0; stateIdx < states.size(); ++stateIdx) {
  107|  2.80M|				if (!task.IsRequired(states[stateIdx]))
  108|   200k|					continue;
  109|  2.60M|				TransitionTable::value_type row(task.Letters().Size());
  110|  46.8M|				for (auto&& letter : task.Letters()) {
  111|  46.8M|					State newState = task.Next(states[stateIdx], letter.first);
  112|  46.8M|					auto i = invstates.find(newState);
  113|  46.8M|					if (i == invstates.end()) {
  114|  2.70M|						if (!maxSize--)
  115|      0|							return task.Failure();
  116|  2.70M|						i = invstates.insert(typename InvStates::value_type(newState, states.size())).first;
  117|  2.70M|						states.push_back(newState);
  118|  2.70M|					}
  119|  46.8M|					row[letter.second.first] = i->second;
  120|  46.8M|				}
  121|  2.60M|				transitions.push_back(row);
  122|  2.60M|				stateIndices.push_back(stateIdx);
  123|  2.60M|			}
  124|       |
  125|   100k|			TVector<Char> invletters(task.Letters().Size());
  126|   100k|			for (auto&& letter : task.Letters())
  127|  1.80M|				invletters[letter.second.first] = letter.first;
  128|       |
  129|   100k|			task.AcceptStates(states);
  130|   100k|			size_t from = 0;
  131|  2.70M|			for (TransitionTable::iterator i = transitions.begin(), ie = transitions.end(); i != ie; ++i, ++from) {
  132|  2.60M|				TVector<Char>::iterator l = invletters.begin();
  133|  49.4M|				for (TransitionTable::value_type::iterator j = i->begin(), je = i->end(); j != je; ++j, ++l)
  134|  46.8M|					task.Connect(stateIndices[from], *j, *l);
  135|  2.60M|			}
  136|   100k|			return task.Success();
  137|   100k|		}
  138|       |
  139|       |		// Faster transition table representation for determined FSM
  140|       |		typedef TVector<size_t> DeterminedTransitions;
  141|       |	}
  142|       |}
  143|       |
  144|       |#endif

/home/johnpaul/pire/pire/encoding.cpp:
    1|       |/*
    2|       | * encoding.cpp -- implementation of the encodings shipped with Pire.
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#include <stdexcept>
   25|       |#include <utility>
   26|       |#include "stub/defaults.h"
   27|       |#include "stub/utf8.h"
   28|       |#include "stub/singleton.h"
   29|       |#include "encoding.h"
   30|       |#include "fsm.h"
   31|       |
   32|       |
   33|       |namespace Pire {
   34|       |
   35|       |namespace {
   36|       |
   37|       |	class Latin1: public Encoding {
   38|       |	public:
   39|      1|		Latin1() : Encoding() {}
   40|       |
   41|       |		wchar32 FromLocal(const char*& begin, const char* end) const
   42|      0|		{
   43|      0|			if (begin == end)
   44|      0|				throw Error("EOF reached in Pire::Latin1::fromLocal()");
   45|      0|			else if (static_cast<unsigned char>(*begin) >= 0x80)
   46|      0|				throw Error("Pire::Latin1::fromLocal(): wrong character encountered (>=0x80)");
   47|      0|			else
   48|      0|				return (wchar32) *begin++;
   49|      0|		}
   50|       |
   51|       |		ystring ToLocal(wchar32 ch) const
   52|      0|		{
   53|      0|			if (ch < 0x80)
   54|      0|				return ystring(1, (char) ch);
   55|      0|			else
   56|      0|				return ystring();
   57|      0|		}
   58|       |
   59|      0|		void AppendDot(Fsm& fsm) const { fsm.AppendDot(); }
   60|       |	};
   61|       |	
   62|       |	namespace UtfRanges {
   63|       |
   64|       |		static const size_t MaxLen = 4;
   65|       |		static const size_t First[MaxLen][2] = {
   66|       |			{0x00, 0x80},
   67|       |			{0xC0, 0xE0},
   68|       |			{0xE0, 0xF0},
   69|       |			{0xF0, 0xF8}
   70|       |		};
   71|       |		static const size_t Next[2] = {0x80, 0xC0};
   72|       |	}
   73|       |
   74|       |
   75|       |	class Utf8: public Encoding {
   76|       |	public:
   77|      1|		Utf8() : Encoding() {}
   78|       |
   79|       |		wchar32 FromLocal(const char*& begin, const char* end) const
   80|  2.00M|		{
   81|  2.00M|			wchar32 rune;
   82|  2.00M|			size_t len;
   83|  2.00M|			if (utf8_read_rune(rune, len, reinterpret_cast<const unsigned char*>(begin), reinterpret_cast<const unsigned char*>(end)) != RECODE_OK)
   84|      0|				throw Error("Error reading UTF8 sequence");
   85|  2.00M|			begin += len;
   86|  2.00M|			return rune;
   87|  2.00M|		}
   88|       |
   89|       |		ystring ToLocal(wchar32 c) const
   90|  3.40M|		{
   91|  3.40M|			ystring ret(utf8_rune_len_by_ucs(c), ' ');
   92|  3.40M|			size_t len;
   93|  3.40M|			unsigned char* p = (unsigned char*) &*ret.begin();
   94|  3.40M|			if (utf8_put_rune(c, len, p, p + ret.size()) != RECODE_OK)
   95|      0|				Y_ASSERT(!"Pire::UTF8::toLocal(): Internal error");
   96|  3.40M|			return ret;
   97|  3.40M|		}
   98|       |
   99|       |		void AppendDot(Fsm& fsm) const
  100|   100k|		{
  101|   100k|			size_t last = fsm.Resize(fsm.Size() + UtfRanges::MaxLen);
  102|   500k|			for (size_t i = 0; i < UtfRanges::MaxLen; ++i)
  103|  18.8M|				for (size_t letter = UtfRanges::First[i][0]; letter < UtfRanges::First[i][1]; ++letter)
  104|  18.4M|					fsm.ConnectFinal(fsm.Size() - i - 1, letter);
  105|   400k|			for (size_t i = 0; i < UtfRanges::MaxLen - 1; ++i)
  106|  19.5M|				for (size_t letter = UtfRanges::Next[0]; letter < UtfRanges::Next[1]; ++letter)
  107|  19.2M|					fsm.Connect(last + i, last + i + 1, letter);
  108|   100k|			fsm.ClearFinal();
  109|   100k|			fsm.SetFinal(fsm.Size() - 1, true);
  110|   100k|			fsm.SetIsDetermined(false);
  111|   100k|		}
  112|       |	};
  113|       |}
  114|       |
  115|       |namespace Encodings {
  116|       |
  117|       |	const Encoding& Utf8()
  118|   200k|	{
  119|   200k|		static const Pire::Utf8 utf8;
  120|   200k|		return utf8;
  121|   200k|	}
  122|       |
  123|       |	const Encoding& Latin1()
  124|   100k|	{
  125|   100k|		static const Pire::Latin1 latin1;
  126|   100k|		return latin1;
  127|   100k|	}
  128|       |
  129|       |}
  130|       |
  131|       |}

/home/johnpaul/pire/pire/encoding.h:
    1|       |/*
    2|       | * encoding.h -- the interface of Encoding.
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#ifndef PIRE_ENCODING_H
   25|       |#define PIRE_ENCODING_H
   26|       |
   27|       |
   28|       |#include "stub/defaults.h"
   29|       |#include "stub/stl.h"
   30|       |
   31|       |namespace Pire {
   32|       |
   33|       |class Fsm;
   34|       |
   35|       |class Encoding {
   36|       |public:
   37|      2|	virtual ~Encoding() {}
   38|       |
   39|       |	/// Should read bytes from @p begin and return the corresponding Unicode
   40|       |	/// character, advancing @p begin.
   41|       |	virtual wchar32 FromLocal(const char*& begin, const char* end) const = 0;
   42|       |
   43|       |	/// Opposite to FromLocal(), transforms given Unicode character into
   44|       |	/// the string in the encoding.
   45|       |	virtual ystring ToLocal(wchar32 c) const = 0;
   46|       |
   47|       |	/// Given the FSM, should append the representation of a dot in the ecoding
   48|       |	/// to that FSM.
   49|       |	virtual void AppendDot(Fsm&) const = 0;
   50|       |
   51|       |	template<class OutputIter>
   52|       |	OutputIter FromLocal(const char* begin, const char* end, OutputIter iter) const
   53|   100k|	{
   54|  2.10M|		while (begin != end) {
   55|  2.00M|			*iter = FromLocal(begin, end);
   56|  2.00M|			++iter;
   57|  2.00M|		}
   58|   100k|		return iter;
   59|   100k|	}
   60|       |};
   61|       |
   62|       |namespace Encodings {
   63|       |	const Encoding& Latin1();
   64|       |	const Encoding& Utf8();
   65|       |
   66|       |};
   67|       |
   68|       |
   69|       |};
   70|       |
   71|       |#endif

/home/johnpaul/pire/pire/fsm.cpp:
    1|       |/*
    2|       | * fsm.cpp -- the implementation of the FSM class.
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#include <algorithm>
   25|       |#include <functional>
   26|       |#include <stdexcept>
   27|       |#include <iostream>
   28|       |#include <iterator>
   29|       |#include <numeric>
   30|       |#include <queue>
   31|       |#include <utility>
   32|       |#include "fsm.h"
   33|       |#include "vbitset.h"
   34|       |#include "partition.h"
   35|       |#include "determine.h"
   36|       |#include "minimize.h"
   37|       |
   38|       |#include <iostream>
   39|       |#include <stdio.h>
   40|       |#include "stub/lexical_cast.h"
   41|       |#include "platform.h"
   42|       |
   43|       |namespace Pire {
   44|       |	
   45|       |ystring CharDump(Char c)
   46|      0|{
   47|      0|	char buf[8];
   48|      0|	if (c == '"')
   49|      0|		return ystring("\\\"");
   50|      0|	else if (c == '[' || c == ']' || c == '-' || c == '^') {
   51|      0|		snprintf(buf, sizeof(buf)-1, "\\\\%c", c);
   52|      0|		return ystring(buf);
   53|      0|	} else if (c >= 32 && c < 127)
   54|      0|		return ystring(1, static_cast<char>(c));
   55|      0|	else if (c == '\n')
   56|      0|		return ystring("\\\\n");
   57|      0|	else if (c == '\t')
   58|      0|		return ystring("\\\\t");
   59|      0|	else if (c == '\r')
   60|      0|		return ystring("\\\\r");
   61|      0|	else if (c < 256) {
   62|      0|		snprintf(buf, sizeof(buf)-1, "\\\\%03o", static_cast<int>(c));
   63|      0|		return ystring(buf);
   64|      0|	} else if (c == Epsilon)
   65|      0|		return ystring("<Epsilon>");
   66|      0|	else if (c == BeginMark)
   67|      0|		return ystring("<Begin>");
   68|      0|	else if (c == EndMark)
   69|      0|		return ystring("<End>");
   70|      0|	else
   71|      0|		return ystring("<?" "?" "?>");
   72|      0|}
   73|       |
   74|       |void Fsm::DumpState(yostream& s, size_t state) const
   75|      0|{
   76|       |	// Fill in a 'row': Q -> exp(V) (for current state)
   77|      0|	TVector< ybitset<MaxChar> > row(Size());
   78|      0|	for (auto&& transition : m_transitions[state])
   79|      0|		for (auto&& transitionState : transition.second) {
   80|      0|			if (transitionState >= Size()) {
   81|      0|				std::cerr << "WTF?! Transition from " << state << " on letter " << transition.first << " leads to non-existing state " << transitionState << "\n";
   82|      0|				Y_ASSERT(false);
   83|      0|			}
   84|      0|			if (Letters().Contains(transition.first)) {
   85|      0|				const TVector<Char>& letters = Letters().Klass(Letters().Representative(transition.first));
   86|      0|				for (auto&& letter : letters)
   87|      0|					row[transitionState].set(letter);
   88|      0|			} else
   89|      0|				row[transitionState].set(transition.first);
   90|      0|		}
   91|       |
   92|      0|	bool statePrinted = false;
   93|       |	// Display each destination state
   94|      0|	for (auto rit = row.begin(), rie = row.end(); rit != rie; ++rit) {
   95|      0|		unsigned begin = 0, end = 0;
   96|       |
   97|      0|		ystring delimiter;
   98|      0|		ystring label;
   99|      0|		if (rit->test(Epsilon)) {
  100|      0|			label += delimiter + CharDump(Epsilon);
  101|      0|			delimiter = " ";
  102|      0|		}
  103|      0|		if (rit->test(BeginMark)) {
  104|      0|			label += delimiter + CharDump(BeginMark);
  105|      0|			delimiter = " ";
  106|      0|		}
  107|      0|		if (rit->test(EndMark)) {
  108|      0|			label += delimiter + CharDump(EndMark);
  109|      0|			delimiter = " ";
  110|      0|		}
  111|      0|		unsigned count = 0;
  112|      0|		for (unsigned i = 0; i < 256; ++i)
  113|      0|			if (rit->test(i))
  114|      0|				++count;
  115|      0|		if (count != 0 && count != 256) {
  116|      0|			label += delimiter + "[";
  117|      0|			bool complementary = (count > 128);
  118|      0|			if (count > 128)
  119|      0|				label += "^";
  120|      0|			while (begin < 256) {
  121|      0|				for (begin = end; begin < 256 && (rit->test(begin) == complementary); ++begin)
  122|      0|					;
  123|      0|				for (end = begin; end < 256 && (rit->test(end) == !complementary); ++end)
  124|      0|					;
  125|      0|				if (begin + 1 == end) {
  126|      0|					label += CharDump(begin);
  127|      0|					delimiter = " ";
  128|      0|				} else if (begin != end) {
  129|      0|					label += CharDump(begin) + "-" + (CharDump(end-1));
  130|      0|					delimiter = " ";
  131|      0|				}
  132|      0|			}
  133|      0|			label += "]";
  134|      0|			delimiter = " ";
  135|      0|		} else if (count == 256) {
  136|      0|			label += delimiter + ".";
  137|      0|			delimiter = " ";
  138|      0|		}
  139|      0|		if (!label.empty()) {
  140|      0|			if (!statePrinted) {
  141|      0|				s << "    " << state << "[shape=\"" << (IsFinal(state) ? "double" : "") << "circle\",label=\"" << state;
  142|      0|				auto ti = tags.find(state);
  143|      0|				if (ti != tags.end())
  144|      0|					s << " (tags: " << ti->second << ")";
  145|      0|				s << "\"]\n";
  146|      0|				if (Initial() == state)
  147|      0|					s << "    \"initial\" -> " << state << '\n';
  148|      0|				statePrinted = true;
  149|      0|			}
  150|      0|			s << "    " << state << " -> " << std::distance(row.begin(), rit) << "[label=\"" << label;
  151|       |
  152|       |			// Display outputs
  153|      0|			auto oit = outputs.find(state);
  154|      0|			if (oit != outputs.end()) {
  155|      0|				auto oit2 = oit->second.find(std::distance(row.begin(), rit));
  156|      0|				if (oit2 == oit->second.end())
  157|      0|					;
  158|      0|				else {
  159|      0|					TVector<int> payload;
  160|      0|					for (unsigned i = 0; i < sizeof(oit2->second) * 8; ++i)
  161|      0|						if (oit2->second & (1ul << i))
  162|      0|							payload.push_back(i);
  163|      0|					if (!payload.empty())
  164|      0|						s << " (outputs: " << Join(payload.begin(), payload.end(), ", ") << ")";
  165|      0|				}
  166|      0|			}
  167|       |
  168|      0|			s << "\"]\n";
  169|      0|		}
  170|      0|	}
  171|       |
  172|      0|	if (statePrinted)
  173|      0|		s << '\n';
  174|      0|}
  175|       |
  176|       |void Fsm::DumpTo(yostream& s, const ystring& name) const
  177|      0|{
  178|      0|	s << "digraph {\n    \"initial\"[shape=\"plaintext\",label=\"" << name << "\"]\n\n";
  179|      0|	for (size_t state = 0; state < Size(); ++state) {
  180|      0|		DumpState(s, state);
  181|      0|	}
  182|      0|	s << "}\n\n";
  183|      0|}
  184|       |
  185|      0|yostream& operator << (yostream& s, const Fsm& fsm) { fsm.DumpTo(s); return s; }
  186|       |
  187|       |
  188|       |namespace {
  189|       |	template<class Vector> void resizeVector(Vector& v, size_t s) { v.resize(s); }
  190|       |}
  191|       |
  192|       |Fsm::Fsm():
  193|       |	m_transitions(1),
  194|       |	initial(0),
  195|       |	letters(m_transitions),
  196|       |	m_sparsed(false),
  197|       |	determined(false),
  198|       |	isAlternative(false)
  199|   600k|{
  200|   600k|	m_final.insert(0);
  201|   600k|}
  202|       |
  203|       |Fsm Fsm::MakeFalse()
  204|      1|{
  205|      1|	Fsm f;
  206|      1|	f.SetFinal(0, false);
  207|      1|	return f;
  208|      1|}
  209|       |
  210|       |Char Fsm::Translate(Char c) const
  211|   151M|{
  212|   151M|	if (!m_sparsed || c == Epsilon)
  213|  5.20M|		return c;
  214|   145M|	else
  215|   145M|		return Letters().Representative(c);
  216|   151M|}
  217|       |
  218|       |bool Fsm::Connected(size_t from, size_t to, Char c) const
  219|      0|{
  220|      0|	auto it = m_transitions[from].find(Translate(c));
  221|      0|	return (it != m_transitions[from].end() && it->second.find(to) != it->second.end());
  222|      0|}
  223|       |
  224|       |bool Fsm::Connected(size_t from, size_t to) const
  225|      0|{
  226|      0|	for (auto i = m_transitions[from].begin(), ie = m_transitions[from].end(); i != ie; ++i)
  227|      0|		if (i->second.find(to) != i->second.end())
  228|      0|			return true;
  229|      0|	return false;
  230|      0|}
  231|       |
  232|       |const Fsm::StatesSet& Fsm::Destinations(size_t from, Char c) const
  233|   151M|{
  234|   151M|	auto i = m_transitions[from].find(Translate(c));
  235|   151M|	return (i != m_transitions[from].end()) ? i->second : DefaultValue<StatesSet>();
  236|   151M|}
  237|       |
  238|       |TSet<Char> Fsm::OutgoingLetters(size_t state) const
  239|      0|{
  240|      0|	TSet<Char> ret;
  241|      0|	for (auto&& i : m_transitions[state])
  242|      0|		ret.insert(i.first);
  243|      0|	return ret;
  244|      0|}
  245|       |
  246|       |size_t Fsm::Resize(size_t newSize)
  247|  2.50M|{
  248|  2.50M|	size_t ret = Size();
  249|  2.50M|	m_transitions.resize(newSize);
  250|  2.50M|	return ret;
  251|  2.50M|}
  252|       |
  253|       |void Fsm::Swap(Fsm& fsm)
  254|   200k|{
  255|   200k|	DoSwap(m_transitions, fsm.m_transitions);
  256|   200k|	DoSwap(initial, fsm.initial);
  257|   200k|	DoSwap(m_final, fsm.m_final);
  258|   200k|	DoSwap(letters, fsm.letters);
  259|   200k|	DoSwap(determined, fsm.determined);
  260|   200k|	DoSwap(outputs, fsm.outputs);
  261|   200k|	DoSwap(tags, fsm.tags);
  262|   200k|	DoSwap(isAlternative, fsm.isAlternative);
  263|   200k|}
  264|       |
  265|       |void Fsm::SetFinal(size_t state, bool final)
  266|  2.80M|{
  267|  2.80M|	if (final)
  268|  2.70M|		m_final.insert(state);
  269|   100k|	else
  270|   100k|		m_final.erase(state);
  271|  2.80M|}
  272|       |
  273|       |Fsm& Fsm::AppendDot()
  274|      0|{
  275|      0|	Resize(Size() + 1);
  276|      0|	for (size_t letter = 0; letter != (1 << (sizeof(char)*8)); ++letter)
  277|      0|		ConnectFinal(Size() - 1, letter);
  278|      0|	ClearFinal();
  279|      0|	SetFinal(Size() - 1, true);
  280|      0|	determined = false;
  281|      0|    return *this;
  282|      0|}
  283|       |
  284|       |Fsm& Fsm::Append(char c)
  285|      0|{
  286|      0|	Resize(Size() + 1);
  287|      0|	ConnectFinal(Size() - 1, static_cast<unsigned char>(c));
  288|      0|	ClearFinal();
  289|      0|	SetFinal(Size() - 1, true);
  290|      0|	determined = false;
  291|      0|    return *this;
  292|      0|}
  293|       |
  294|       |Fsm& Fsm::Append(const ystring& str)
  295|      0|{
  296|      0|    for (auto&& i : str)
  297|      0|        Append(i);
  298|      0|    return *this;
  299|      0|}
  300|       |
  301|       |Fsm& Fsm::AppendSpecial(Char c)
  302|      0|{
  303|      0|	Resize(Size() + 1);
  304|      0|	ConnectFinal(Size() - 1, c);
  305|      0|	ClearFinal();
  306|      0|	SetFinal(Size() - 1, true);
  307|      0|	determined = false;
  308|      0|    return *this;
  309|      0|}
  310|       |
  311|       |Fsm& Fsm::AppendStrings(const TVector<ystring>& strings)
  312|  1.70M|{
  313|  1.70M|	for (auto&& i : strings)
  314|  1.70M|		if (i.empty())
  315|      0|			throw Error("None of strings passed to appendStrings() can be empty");
  316|       |
  317|  1.70M|	Resize(Size() + 1);
  318|  1.70M|	size_t end = Size() - 1;
  319|       |
  320|       |	// A local transitions table: (oldstate, char) -> newstate.
  321|       |	// Valid for all letters in given strings except final ones,
  322|       |	// which are always connected to the end state.
  323|       |
  324|       |	// NB: since each FSM contains at least one state,
  325|       |	// state #0 cannot appear in LTRs. Thus we can use this
  326|       |	// criteria to test whether a transition has been created or not.
  327|  1.70M|	typedef ypair<size_t, char> Transition;
  328|  1.70M|	TMap<char, size_t> startLtr;
  329|  1.70M|	TMap<Transition, size_t> ltr;
  330|       |
  331|       |	// A presense of a transition in this set indicates that
  332|       |	// a that transition already points somewhere (either to end
  333|       |	// or somewhere else). Another attempt to create such transition
  334|       |	// will clear `determined flag.
  335|  1.70M|	TSet<Transition> usedTransitions;
  336|  1.70M|	TSet<char> usedFirsts;
  337|       |
  338|  1.70M|	for (const auto& str : strings) {
  339|  1.70M|		if (str.size() > 1) {
  340|       |
  341|       |			// First letter: all previously final states are connected to the new state
  342|      0|			size_t& firstJump = startLtr[str[0]];
  343|      0|			if (!firstJump) {
  344|      0|				firstJump = Resize(Size() + 1);
  345|      0|				ConnectFinal(firstJump, static_cast<unsigned char>(str[0]));
  346|      0|				determined = determined && (usedFirsts.find(str[0]) != usedFirsts.end());
  347|      0|			}
  348|       |
  349|       |			// All other letters except last one
  350|      0|			size_t state = firstJump;
  351|      0|			for (auto cit = str.begin() + 1, cie = str.end() - 1; cit != cie; ++cit) {
  352|      0|				size_t& newState = ltr[ymake_pair(state, *cit)];
  353|      0|				if (!newState) {
  354|      0|					newState = Resize(Size() + 1);
  355|      0|					Connect(state, newState, static_cast<unsigned char>(*cit));
  356|      0|					determined = determined && (usedTransitions.find(ymake_pair(state, *cit)) != usedTransitions.end());
  357|      0|				}
  358|      0|				state = newState;
  359|      0|			}
  360|       |
  361|       |			// The last letter: connect the current state to end
  362|      0|			unsigned char last = static_cast<unsigned char>(*(str.end() - 1));
  363|      0|			Connect(state, end, last);
  364|      0|			determined = determined && (usedTransitions.find(ymake_pair(state, last)) != usedTransitions.end());
  365|       |
  366|  1.70M|		} else {
  367|       |			// The single letter: connect all the previously final states to end
  368|  1.70M|			ConnectFinal(end, static_cast<unsigned char>(str[0]));
  369|  1.70M|			determined = determined && (usedFirsts.find(str[0]) != usedFirsts.end());
  370|  1.70M|		}
  371|  1.70M|	}
  372|       |
  373|  1.70M|	ClearFinal();
  374|  1.70M|	SetFinal(end, true);
  375|  1.70M|    return *this;
  376|  1.70M|}
  377|       |
  378|       |void Fsm::Import(const Fsm& rhs)
  379|   100k|{
  380|       |//     PIRE_IFDEBUG(LOG_DEBUG("fsm") << "Importing");
  381|       |//     PIRE_IFDEBUG(LOG_DEBUG("fsm") << "=== Left-hand side ===\n" << *this);
  382|       |//     PIRE_IFDEBUG(LOG_DEBUG("fsm") << "=== Right-hand side ===\n" << rhs);
  383|       |
  384|   100k|	size_t oldsize = Resize(Size() + rhs.Size());
  385|       |
  386|  2.30M|	for (auto&& outer : m_transitions) {
  387|  2.30M|		for (auto&& letter : letters) {
  388|      0|			auto targets = outer.find(letter.first);
  389|      0|			if (targets == outer.end())
  390|      0|				continue;
  391|      0|			for (auto&& character : letter.second.second)
  392|      0|				if (character != letter.first)
  393|      0|					outer.insert(ymake_pair(character, targets->second));
  394|      0|		}
  395|  2.30M|	}
  396|       |
  397|   100k|	auto dest = m_transitions.begin() + oldsize;
  398|  1.10M|	for (auto outer = rhs.m_transitions.begin(), outerEnd = rhs.m_transitions.end(); outer != outerEnd; ++outer, ++dest) {
  399|  1.00M|		for (auto&& inner : *outer) {
  400|   900k|			TSet<size_t> targets;
  401|   900k|			std::transform(inner.second.begin(), inner.second.end(), std::inserter(targets, targets.begin()),
  402|   900k|				std::bind2nd(std::plus<size_t>(), oldsize));
  403|   900k|			dest->insert(ymake_pair(inner.first, targets));
  404|   900k|		}
  405|       |
  406|  1.00M|		for (auto&& letter : rhs.letters) {
  407|      0|			auto targets = dest->find(letter.first);
  408|      0|			if (targets == dest->end())
  409|      0|				continue;
  410|      0|			for (auto&& character : letter.second.second)
  411|      0|				if (character != letter.first)
  412|      0|					dest->insert(ymake_pair(character, targets->second));
  413|      0|		}
  414|  1.00M|	}
  415|       |
  416|       |	// Import outputs
  417|   100k|	for (auto&& output : rhs.outputs) {
  418|      0|		auto& dest = outputs[output.first + oldsize];
  419|      0|		for (auto&& element : output.second)
  420|      0|			dest.insert(ymake_pair(element.first + oldsize, element.second));
  421|      0|	}
  422|       |
  423|       |	// Import tags
  424|   100k|	for (auto&& tag : rhs.tags)
  425|      0|		tags.insert(ymake_pair(tag.first + oldsize, tag.second));
  426|       |
  427|   100k|	letters = LettersTbl(LettersEquality(m_transitions));
  428|   100k|}
  429|       |
  430|       |void Fsm::Connect(size_t from, size_t to, Char c /* = Epsilon */)
  431|   286M|{
  432|   286M|	m_transitions[from][c].insert(to);
  433|   286M|	ClearHints();
  434|   286M|}
  435|       |
  436|       |void Fsm::ConnectFinal(size_t to, Char c /* = Epsilon */)
  437|  20.3M|{
  438|  20.3M|	for (auto&& final : m_final)
  439|  20.3M|		Connect(final, to, c);
  440|  20.3M|	ClearHints();
  441|  20.3M|}
  442|       |
  443|       |void Fsm::Disconnect(size_t from, size_t to, Char c)
  444|      0|{
  445|      0|	auto i = m_transitions[from].find(c);
  446|      0|	if (i != m_transitions[from].end())
  447|      0|		i->second.erase(to);
  448|      0|	ClearHints();
  449|      0|}
  450|       |
  451|       |void Fsm::Disconnect(size_t from, size_t to)
  452|      0|{
  453|      0|	for (auto&& i : m_transitions[from])
  454|      0|		i.second.erase(to);
  455|      0|	ClearHints();
  456|      0|}
  457|       |
  458|       |unsigned long Fsm::Output(size_t from, size_t to) const
  459|  47.0M|{
  460|  47.0M|	auto i = outputs.find(from);
  461|  47.0M|	if (i == outputs.end())
  462|  47.0M|		return 0;
  463|      0|	auto j = i->second.find(to);
  464|      0|	if (j == i->second.end())
  465|      0|		return 0;
  466|      0|	else
  467|      0|		return j->second;
  468|      0|}
  469|       |
  470|       |Fsm& Fsm::operator += (const Fsm& rhs)
  471|   100k|{
  472|   100k|	size_t lhsSize = Size();
  473|   100k|	Import(rhs);
  474|       |
  475|   100k|	const TransitionRow& row = m_transitions[lhsSize + rhs.initial];
  476|       |
  477|   100k|	for (auto&& outer : row)
  478|   100k|		for (auto&& inner : outer.second)
  479|   100k|			ConnectFinal(inner, outer.first);
  480|       |
  481|   100k|	auto out = rhs.outputs.find(rhs.initial);
  482|   100k|	if (out != rhs.outputs.end())
  483|      0|		for (auto&& toAndOutput : out->second) {
  484|      0|			for (auto&& final : m_final)
  485|      0|				outputs[final].insert(ymake_pair(toAndOutput.first + lhsSize, toAndOutput.second));
  486|      0|		}
  487|       |
  488|   100k|	ClearFinal();
  489|   100k|	for (auto&& letter : rhs.m_final)
  490|   100k|		SetFinal(letter + lhsSize, true);
  491|   100k|	determined = false;
  492|       |
  493|   100k|	ClearHints();
  494|   100k|	PIRE_IFDEBUG(Cdbg << "=== After addition ===" << Endl << *this << Endl);
  495|       |
  496|   100k|	return *this;
  497|   100k|}
  498|       |
  499|       |Fsm& Fsm::operator |= (const Fsm& rhs)
  500|      0|{
  501|      0|	size_t lhsSize = Size();
  502|       |
  503|      0|	Import(rhs);
  504|      0|	for (auto&& final : rhs.m_final)
  505|      0|		m_final.insert(final + lhsSize);	
  506|       |	
  507|      0|	if (!isAlternative && !rhs.isAlternative) {
  508|      0|		Resize(Size() + 1);
  509|      0|		Connect(Size() - 1, initial);
  510|      0|		Connect(Size() - 1, lhsSize + rhs.initial);
  511|      0|		initial = Size() - 1;
  512|      0|	} else if (isAlternative && !rhs.isAlternative) {
  513|      0|		Connect(initial, lhsSize + rhs.initial, Epsilon);
  514|      0|	} else if (!isAlternative && rhs.isAlternative) {
  515|      0|		Connect(lhsSize + rhs.initial, initial, Epsilon);
  516|      0|		initial = rhs.initial + lhsSize;
  517|      0|	} else if (isAlternative && rhs.isAlternative) {
  518|      0|		const StatesSet& tos = rhs.Destinations(rhs.initial, Epsilon);
  519|      0|		for (auto&& to : tos) {
  520|      0|			Connect(initial, to + lhsSize, Epsilon);
  521|      0|			Disconnect(rhs.initial + lhsSize, to + lhsSize, Epsilon);
  522|      0|		}
  523|      0|	}
  524|       |
  525|      0|	determined = false;
  526|      0|	isAlternative = true;
  527|      0|	return *this;
  528|      0|}
  529|       |
  530|       |Fsm& Fsm::operator &= (const Fsm& rhs)
  531|      0|{
  532|      0|	Fsm rhs2(rhs);
  533|      0|	Complement();
  534|      0|	rhs2.Complement();
  535|      0|	*this |= rhs2;
  536|      0|	Complement();
  537|      0|	return *this;
  538|      0|}
  539|       |
  540|       |Fsm& Fsm::Iterate()
  541|      0|{
  542|      0|	PIRE_IFDEBUG(Cdbg << "Iterating:" << Endl << *this << Endl);
  543|      0|	Resize(Size() + 2);
  544|       |
  545|      0|	Connect(Size() - 2, Size() - 1);
  546|      0|	Connect(Size() - 2, initial);
  547|      0|	ConnectFinal(initial);
  548|      0|	ConnectFinal(Size() - 1);
  549|       |
  550|      0|	ClearFinal();
  551|      0|	SetFinal(Size() - 1, true);
  552|      0|	initial = Size() - 2;
  553|       |
  554|      0|	determined = false;
  555|       |
  556|      0|	PIRE_IFDEBUG(Cdbg << "Iterated:" << Endl << *this << Endl);
  557|      0|	return *this;
  558|      0|}
  559|       |
  560|       |Fsm& Fsm::Complement()
  561|      0|{
  562|      0|	if (!Determine())
  563|      0|		throw Error("Regexp pattern too complicated");
  564|      0|	Minimize();
  565|      0|	Resize(Size() + 1);
  566|      0|	for (size_t i = 0; i < Size(); ++i)
  567|      0|		if (!IsFinal(i))
  568|      0|			Connect(i, Size() - 1);
  569|      0|	ClearFinal();
  570|      0|	SetFinal(Size() - 1, true);
  571|      0|	determined = false;
  572|       |
  573|      0|	return *this;
  574|      0|}
  575|       |
  576|       |Fsm Fsm::operator *(size_t count) const
  577|      0|{
  578|      0|	Fsm ret;
  579|      0|	while (count--)
  580|      0|		ret += *this;
  581|      0|	return ret;
  582|      0|}
  583|       |
  584|       |void Fsm::MakePrefix()
  585|      0|{
  586|      0|	RemoveDeadEnds();
  587|      0|	for (size_t i = 0; i < Size(); ++i)
  588|      0|		if (!m_transitions[i].empty())
  589|      0|			m_final.insert(i);
  590|      0|	ClearHints();
  591|      0|}
  592|       |
  593|       |void Fsm::MakeSuffix()
  594|      0|{
  595|      0|	for (size_t i = 0; i < Size(); ++i)
  596|      0|		if (i != initial)
  597|      0|			Connect(initial, i);
  598|      0|	ClearHints();
  599|      0|}
  600|       |	
  601|       |Fsm& Fsm::Reverse()
  602|      0|{
  603|      0|	Fsm out;
  604|      0|	out.Resize(Size() + 1);
  605|      0|	out.letters = Letters();
  606|       |
  607|       |	// Invert transitions
  608|      0|	for (size_t from = 0; from < Size(); ++from)
  609|      0|		for (auto&& i : m_transitions[from])
  610|      0|			for (auto&& j : i.second)
  611|      0|				out.Connect(j, from, i.first);
  612|       |
  613|       |	// Invert initial and final states
  614|      0|	out.m_final.clear();
  615|      0|	out.SetFinal(initial, true);
  616|      0|	for (auto i : m_final)
  617|      0|		out.Connect(Size(), i, Epsilon);
  618|      0|	out.SetInitial(Size());
  619|       |
  620|       |	// Invert outputs
  621|      0|	for (auto&& i : outputs)
  622|      0|		for (auto&& j : i.second)
  623|      0|			out.SetOutput(j.first, i.first, j.second);
  624|       |
  625|       |	// Preserve tags (although thier semantics are usually heavily broken at this point)
  626|      0|	out.tags = tags;
  627|       |
  628|       |	// Apply
  629|      0|	Swap(out);
  630|      0|	return *this;
  631|      0|}
  632|       |
  633|       |TSet<size_t> Fsm::DeadStates() const
  634|   100k|{
  635|   100k|	TSet<size_t> res;
  636|       |
  637|   300k|	for (int invert = 0; invert <= 1; ++invert) {
  638|   200k|		Fsm digraph;
  639|   200k|		digraph.Resize(Size());
  640|  5.40M|		for (TransitionTable::const_iterator j = m_transitions.begin(), je = m_transitions.end(); j != je; ++j) {
  641|  98.8M|			for (TransitionRow::const_iterator k = j->begin(), ke = j->end(); k != ke; ++k) {
  642|   187M|				for (StatesSet::const_iterator toSt = k->second.begin(), toSte = k->second.end(); toSt != toSte; ++toSt) {
  643|       |					// We only care if the states are connected or not regerdless through what letter
  644|  93.6M|					if (invert) {
  645|       |						// Build an FSM with inverted transitions
  646|  46.8M|						digraph.Connect(*toSt, j - m_transitions.begin(), 0);
  647|  46.8M|					} else {
  648|  46.8M|						digraph.Connect(j - m_transitions.begin(), *toSt, 0);
  649|  46.8M|					}
  650|  93.6M|				}
  651|  93.6M|			}
  652|  5.20M|		}
  653|       |
  654|   200k|		TVector<bool> unchecked(Size(), true);
  655|   200k|		TVector<bool> useless(Size(), true);
  656|   200k|		TDeque<size_t> queue;
  657|       |
  658|       |		// Put all final (or initial) states into queue, marking them useful
  659|  5.40M|		for (size_t i = 0; i < Size(); ++i)
  660|  5.20M|			if ((invert && IsFinal(i)) || (!invert && Initial() == i)) {
  661|   200k|				useless[i] = false;
  662|   200k|				queue.push_back(i);
  663|   200k|			}
  664|       |
  665|       |		// Do the breadth-first search, marking all states
  666|       |		// from which already marked states are reachable
  667|  5.40M|		while (!queue.empty()) {
  668|  5.20M|			size_t to = queue.front();
  669|  5.20M|			queue.pop_front();
  670|       |
  671|       |			// All the states that are connected to this state in the transition matrix are useful
  672|  5.20M|			const StatesSet& connections = (digraph.m_transitions[to])[0];
  673|  16.6M|			for (auto&& fr : connections) {
  674|       |				// Enqueue the state for further traversal if it hasnt been already checked
  675|  16.6M|				if (unchecked[fr] && useless[fr]) {
  676|  5.00M|					useless[fr] = false;
  677|  5.00M|					queue.push_back(fr);
  678|  5.00M|				}
  679|  16.6M|			}
  680|       |
  681|       |			// Now we consider this state checked
  682|  5.20M|			unchecked[to] = false;
  683|  5.20M|		}
  684|       |
  685|  5.40M|		for (size_t i = 0; i < Size(); ++i) {
  686|  5.20M|			if (useless[i]) {
  687|      1|				res.insert(i);
  688|      1|			}
  689|  5.20M|		}
  690|   200k|	}
  691|       |
  692|   100k|	return res;
  693|   100k|}
  694|       |
  695|       |void Fsm::RemoveDeadEnds()
  696|      0|{
  697|      0|	PIRE_IFDEBUG(Cdbg << "Removing dead ends on:" << Endl << *this << Endl);
  698|       |
  699|      0|	TSet<size_t> dead = DeadStates();
  700|       |	// Erase all useless states
  701|      0|	for (auto&& i : dead) {
  702|      0|		PIRE_IFDEBUG(Cdbg << "Removing useless state " << i << Endl);
  703|      0|		m_transitions[i].clear();
  704|      0|		for (auto&& j : m_transitions)
  705|      0|			for (auto&& k : j)
  706|      0|				k.second.erase(i);
  707|      0|	}
  708|      0|	ClearHints();
  709|       |
  710|      0|	PIRE_IFDEBUG(Cdbg << "Result:" << Endl << *this << Endl);
  711|      0|}
  712|       |
  713|       |// This method is one step of Epsilon-connection removal algorithm.
  714|       |// It merges transitions, tags, and outputs of 'to' state into 'from' state
  715|       |void Fsm::MergeEpsilonConnection(size_t from, size_t to)
  716|   200k|{
  717|   200k|	unsigned long frEpsOutput = 0;
  718|   200k|	bool fsEpsOutputExists = false;
  719|       |
  720|       |	// Is there an output for 'from'->'to' transition?
  721|   200k|	if (outputs.find(from) != outputs.end() && outputs[from].find(to) != outputs[from].end()) {
  722|      0|		frEpsOutput = outputs[from][to];
  723|      0|		fsEpsOutputExists = true;
  724|      0|	}
  725|       |
  726|       |	// Merge transitions from 'to' state into transitions from 'from' state
  727|  26.5M|	for (auto&& transition : m_transitions[to]) {
  728|  26.5M|		TSet<size_t> connStates;
  729|  26.5M|		std::copy(transition.second.begin(), transition.second.end(),
  730|  26.5M|			std::inserter(m_transitions[from][transition.first], m_transitions[from][transition.first].end()));
  731|       |
  732|       |		// If there is an output of the 'from'->'to' connection it has to be set to all
  733|       |		// new connections that were merged from 'to' state
  734|  26.5M|		if (fsEpsOutputExists) {
  735|       |			// Compute the set of states that are reachable from 'to' state
  736|      0|			std::copy(transition.second.begin(), transition.second.end(), std::inserter(connStates, connStates.end()));
  737|       |
  738|       |			// For each of these states add an output equal to the Epsilon-connection output
  739|      0|			for (auto&& newConnSt : connStates) {
  740|      0|				outputs[from][newConnSt] |= frEpsOutput;
  741|      0|			}
  742|      0|		}
  743|  26.5M|	}
  744|       |
  745|       |	// Mark 'from' state final if 'to' state is final
  746|   200k|	if (IsFinal(to))
  747|   100k|		SetFinal(from, true);
  748|       |
  749|       |	// Combine tags
  750|   200k|	auto ti = tags.find(to);
  751|   200k|	if (ti != tags.end())
  752|      0|		tags[from] |= ti->second;
  753|       |
  754|       |	// Merge all 'to' into 'from' outputs:
  755|       |	//      outputs[from][i] |= (outputs[from][to] | outputs[to][i])
  756|   200k|	auto toOit = outputs.find(to);
  757|   200k|	if (toOit != outputs.end()) {
  758|      0|		for (auto&& output : toOit->second) {
  759|      0|			outputs[from][output.first] |= (frEpsOutput | output.second);
  760|      0|		}
  761|      0|	}
  762|   200k|}
  763|       |
  764|       |// Assuming the epsilon transitions is possible from 'from' to 'thru',
  765|       |// finds all states which are Epsilon-reachable from 'thru' and connects
  766|       |// them directly to 'from' with Epsilon transition having proper output.
  767|       |// Updates inverse map of epsilon transitions as well.
  768|       |void Fsm::ShortCutEpsilon(size_t from, size_t thru, TVector< TSet<size_t> >& inveps)
  769|   200k|{
  770|   200k|	PIRE_IFDEBUG(Cdbg << "In Fsm::ShortCutEpsilon(" << from << ", " << thru << ")\n");
  771|   200k|	const StatesSet& to = Destinations(thru, Epsilon);
  772|   200k|	Outputs::iterator outIt = outputs.find(from);
  773|   200k|	unsigned long fromThruOut = Output(from, thru);
  774|   200k|	for (auto&& toElement : to) {
  775|   100k|		PIRE_IFDEBUG(Cdbg << "Epsilon connecting " << from << " --> " << thru << " --> " << toElement << "\n");
  776|   100k|		Connect(from, toElement, Epsilon);
  777|   100k|		inveps[toElement].insert(from);
  778|   100k|		if (outIt != outputs.end())
  779|      0|			outIt->second[toElement] |= (fromThruOut | Output(thru, toElement));
  780|   100k|	}
  781|   200k|}
  782|       |
  783|       |// Removes all Epsilon-connections by iterating though states and merging each Epsilon-connection
  784|       |// effects from 'to' state into 'from' state
  785|       |void Fsm::RemoveEpsilons()
  786|   100k|{
  787|   100k|	Unsparse();
  788|       |
  789|       |	// Build inverse map of epsilon transitions
  790|   100k|	TVector< TSet<size_t> > inveps(Size()); // We have to use TSet<> here since we want it sorted
  791|  2.60M|	for (size_t from = 0; from != Size(); ++from) {
  792|  2.50M|		const StatesSet& tos = Destinations(from, Epsilon);
  793|  2.50M|		for (auto&& to : tos)
  794|   400k|			inveps[to].insert(from);
  795|  2.50M|	}
  796|       |
  797|       |	// Make a transitive closure of all epsilon transitions (Floyd-Warshall algorithm)
  798|       |	// (if there exists an epsilon-path between two states, epsilon-connect them directly)
  799|  2.60M|	for (size_t thru = 0; thru != Size(); ++thru)
  800|  2.50M|		for (auto&& from : inveps[thru])
  801|       |			// inveps[thru] may alter during loop body, hence we cannot cache ivneps[thru].end()
  802|   400k|			if (from != thru)
  803|   200k|				ShortCutEpsilon(from, thru, inveps);
  804|       |
  805|   100k|	PIRE_IFDEBUG(Cdbg << "=== After epsilons shortcut\n" << *this << Endl);
  806|       |
  807|       |	// Iterate through all epsilon-connected state pairs, merging states together
  808|  2.60M|	for (size_t from = 0; from != Size(); ++from) {
  809|  2.50M|		const StatesSet& to = Destinations(from, Epsilon);
  810|  2.50M|		for (auto&& toElement : to)
  811|   400k|			if (toElement != from)
  812|   200k|				MergeEpsilonConnection(from, toElement); // it's a NOP if to == from, so don't waste time
  813|  2.50M|	}
  814|       |
  815|   100k|	PIRE_IFDEBUG(Cdbg << "=== After epsilons merged\n" << *this << Endl);
  816|       |
  817|       |	// Drop all epsilon transitions
  818|   100k|	for (auto&& i : m_transitions)
  819|  2.50M|		i.erase(Epsilon);
  820|       |
  821|   100k|	Sparse();
  822|   100k|	ClearHints();
  823|   100k|}
  824|       |
  825|       |bool Fsm::LettersEquality::operator()(Char a, Char b) const
  826|   222M|{
  827|  1.21G|	for (auto&& outer : *m_tbl) {
  828|  1.21G|		auto ia = outer.find(a);
  829|  1.21G|		auto ib = outer.find(b);
  830|  1.21G|		if (ia == outer.end() && ib == outer.end())
  831|   902M|			continue;
  832|   312M|		else if (ia == outer.end() || ib == outer.end() || ia->second != ib->second) {
  833|   198M|			return false;
  834|   198M|		}
  835|  1.21G|	}
  836|  24.5M|	return true;
  837|   222M|}
  838|       |
  839|       |void Fsm::Sparse(bool needEpsilons /* = false */)
  840|   100k|{
  841|   100k|	letters = LettersTbl(LettersEquality(m_transitions));
  842|  26.5M|	for (unsigned letter = 0; letter < MaxChar; ++letter)
  843|  26.4M|		if (letter != Epsilon || needEpsilons)
  844|  26.3M|			letters.Append(letter);
  845|       |
  846|   100k|	m_sparsed = true;
  847|   100k|	PIRE_IFDEBUG(Cdbg << "Letter classes = " << letters << Endl);
  848|   100k|}
  849|       |
  850|       |void Fsm::Unsparse()
  851|   100k|{
  852|   100k|	for (auto&& letter : letters)
  853|      0|		for (auto&& i : m_transitions)
  854|      0|			for (auto&& j : letter.second.second)
  855|      0|				i[j] = i[letter.first];
  856|   100k|	m_sparsed = false;
  857|   100k|}
  858|       |
  859|       |// Returns a set of 'terminal states', which are those of the final states,
  860|       |// from which a transition to themselves on any letter is possible.
  861|       |TSet<size_t> Fsm::TerminalStates() const
  862|   100k|{
  863|   100k|	TSet<size_t> terminals;
  864|   200k|	for (auto&& final : m_final) {
  865|   200k|		bool ok = true;
  866|  3.60M|		for (auto&& letter : letters) {
  867|  3.60M|			auto dests = m_transitions[final].find(letter.first);
  868|  3.60M|			ok = ok && (dests != m_transitions[final].end() && dests->second.find(final) != dests->second.end());
  869|  3.60M|		}
  870|   200k|		if (ok)
  871|   100k|			terminals.insert(final);
  872|   200k|	}
  873|   100k|	return terminals;
  874|   100k|}
  875|       |
  876|       |namespace Impl {
  877|       |class FsmDetermineTask {
  878|       |public:
  879|       |	typedef TVector<size_t> State;
  880|       |	typedef Fsm::LettersTbl LettersTbl;
  881|       |	typedef TMap<State, size_t> InvStates;
  882|       |	
  883|       |	FsmDetermineTask(const Fsm& fsm)
  884|       |		: mFsm(fsm)
  885|       |		, mTerminals(fsm.TerminalStates())
  886|   100k|	{
  887|   100k|		PIRE_IFDEBUG(Cdbg << "Terminal states: [" << Join(mTerminals.begin(), mTerminals.end(), ", ") << "]" << Endl);
  888|   100k|	}
  889|  5.70M|	const LettersTbl& Letters() const { return mFsm.letters; }
  890|       |	
  891|   100k|	State Initial() const { return State(1, mFsm.initial); }
  892|       |	bool IsRequired(const State& state) const
  893|  2.80M|	{
  894|  2.80M|		for (auto&& i : state)
  895|  6.00M|			if (mTerminals.find(i) != mTerminals.end())
  896|   200k|				return false;
  897|  2.60M|		return true;
  898|  2.80M|	}
  899|       |	
  900|       |	State Next(const State& state, Char letter) const
  901|  46.8M|	{
  902|  46.8M|		State next;
  903|  46.8M|		next.reserve(20);
  904|  99.0M|		for (auto&& from : state) {
  905|  99.0M|			const auto& part = mFsm.Destinations(from, letter);
  906|  99.0M|			std::copy(part.begin(), part.end(), std::back_inserter(next));
  907|  99.0M|		}
  908|       |
  909|  46.8M|		std::sort(next.begin(), next.end());
  910|  46.8M|		next.erase(std::unique(next.begin(), next.end()), next.end());
  911|  46.8M|		PIRE_IFDEBUG(Cdbg << "Returning transition [" << Join(state.begin(), state.end(), ", ") << "] --" << letter
  912|  46.8M|		                  << "--> [" << Join(next.begin(), next.end(), ", ") << "]" << Endl);
  913|  46.8M|		return next;
  914|  46.8M|	}
  915|       |	
  916|       |	void AcceptStates(const TVector<State>& states)
  917|   100k|	{
  918|   100k|		mNewFsm.Resize(states.size());
  919|   100k|		mNewFsm.initial = 0;
  920|   100k|		mNewFsm.determined = true;
  921|   100k|		mNewFsm.letters = Letters();
  922|   100k|		mNewFsm.m_final.clear();
  923|  2.90M|		for (size_t ns = 0; ns < states.size(); ++ns) {
  924|  2.80M|			PIRE_IFDEBUG(Cdbg << "State " << ns << " = [" << Join(states[ns].begin(), states[ns].end(), ", ") << "]" << Endl);
  925|  6.00M|			for (auto&& j : states[ns]) {
  926|       |
  927|       |				// If it was a terminal state, connect it to itself
  928|  6.00M|				if (mTerminals.find(j) != mTerminals.end()) {
  929|   200k|					for (auto&& letter : Letters())
  930|  3.60M|						mNewFsm.Connect(ns, ns, letter.first);
  931|   200k|					mNewTerminals.insert(ns);
  932|   200k|					PIRE_IFDEBUG(Cdbg << "State " << ns << " becomes terminal because of old state " << j << Endl);
  933|   200k|				}
  934|  6.00M|			}
  935|  5.90M|			for (auto&& j : states[ns]) {
  936|       |				// If any state containing in our one is marked final, mark the new state final as well
  937|  5.90M|				if (mFsm.IsFinal(j)) {
  938|   300k|					PIRE_IFDEBUG(Cdbg << "State " << ns << " becomes final because of old state " << j << Endl);
  939|   300k|					mNewFsm.SetFinal(ns, true);
  940|   300k|					if (mFsm.tags.empty())
  941|       |						// Weve got no tags and already know that the state is final,
  942|       |						// hence weve done with this state and got nothing more to do.
  943|   300k|						break;
  944|   300k|				}
  945|       |
  946|       |				// Bitwise OR all tags in states
  947|  5.60M|				auto ti = mFsm.tags.find(j);
  948|  5.60M|				if (ti != mFsm.tags.end()) {
  949|      0|					PIRE_IFDEBUG(Cdbg << "State " << ns << " carries tag " << ti->second << " because of old state " << j << Endl);
  950|      0|					mNewFsm.tags[ns] |= ti->second;
  951|      0|				}
  952|  5.60M|			}
  953|  2.80M|		}
  954|       |		// For each old state, prepare a list of new state it is contained in
  955|   100k|		typedef TMap< size_t, TVector<size_t> > Old2New;
  956|   100k|		Old2New old2new;
  957|  2.90M|		for (size_t ns = 0; ns < states.size(); ++ns)
  958|  2.80M|			for (auto&& j : states[ns])
  959|  6.00M|				old2new[j].push_back(ns);
  960|       |
  961|       |		// Copy all outputs
  962|   100k|		for (auto&& i : mFsm.outputs) {
  963|      0|			for (auto&& j : i.second) {
  964|      0|				auto from = old2new.find(i.first);
  965|      0|				auto to = old2new.find(j.first);
  966|      0|				if (from != old2new.end() && to != old2new.end()) {
  967|      0|					for (auto&& k : from->second)
  968|      0|						for (auto&& l : to->second)
  969|      0|							mNewFsm.outputs[k][l] |= j.second;
  970|      0|				}
  971|      0|			}
  972|      0|		}
  973|   100k|		PIRE_IFDEBUG(Cdbg << "New terminals = [" << Join(mNewTerminals.begin(), mNewTerminals.end(), ",") << "]" << Endl);
  974|   100k|	}
  975|       |	
  976|       |	void Connect(size_t from, size_t to, Char letter)
  977|  46.8M|	{
  978|  46.8M|		PIRE_IFDEBUG(Cdbg << "Connecting " << from << " --" << letter << "--> " << to << Endl);
  979|  46.8M|		Y_ASSERT(mNewTerminals.find(from) == mNewTerminals.end());
  980|  46.8M|		mNewFsm.Connect(from, to, letter);
  981|  46.8M|	}
  982|       |	typedef bool Result;
  983|       |
  984|   100k|	Result Success() {
  985|   100k|		Fsm::Outputs oldOutputs;
  986|       |		// remove redundant outputs
  987|   100k|		oldOutputs.swap(mNewFsm.outputs);
  988|  2.90M|		for (size_t from = 0; from < mNewFsm.Size(); ++from) {
  989|  2.80M|			auto fromOutput = oldOutputs.find(from);
  990|  2.80M|			if (fromOutput == oldOutputs.end())
  991|  2.80M|				continue;
  992|      0|			const auto& newTransitionsRow = mNewFsm.m_transitions[from];
  993|      0|			for (auto&& row : newTransitionsRow) {
  994|      0|				for (auto&& stateIt : row.second) {
  995|      0|					auto toOutput = fromOutput->second.find(stateIt);
  996|      0|					if (toOutput != fromOutput->second.end()) {
  997|      0|						mNewFsm.outputs[from].insert(*toOutput);
  998|      0|					}
  999|      0|				}
 1000|      0|			}
 1001|      0|		}
 1002|   100k|		return true;
 1003|   100k|	}
 1004|       |
 1005|      0|	Result Failure() { return false; }
 1006|       |	
 1007|   100k|	Fsm& Output() { return mNewFsm; }
 1008|       |private:
 1009|       |	const Fsm& mFsm;
 1010|       |	Fsm mNewFsm;
 1011|       |	TSet<size_t> mTerminals;
 1012|       |	TSet<size_t> mNewTerminals;
 1013|       |};
 1014|       |}
 1015|       |
 1016|       |bool Fsm::Determine(size_t maxsize /* = 0 */)
 1017|   100k|{
 1018|   100k|	static const unsigned MaxSize = 200000;
 1019|   100k|	if (determined)
 1020|      0|		return true;
 1021|       |
 1022|   100k|	PIRE_IFDEBUG(Cdbg << "=== Initial ===" << Endl << *this << Endl);
 1023|       |	
 1024|   100k|	RemoveEpsilons();
 1025|   100k|	PIRE_IFDEBUG(Cdbg << "=== After all epsilons removed" << Endl << *this << Endl);
 1026|       |	
 1027|   100k|	Impl::FsmDetermineTask task(*this);
 1028|   100k|	if (Pire::Impl::Determine(task, maxsize ? maxsize : MaxSize)) {
 1029|   100k|		task.Output().Swap(*this);
 1030|   100k|		PIRE_IFDEBUG(Cdbg << "=== Determined ===" << Endl << *this << Endl);
 1031|   100k|		return true;
 1032|   100k|	} else
 1033|      0|		return false;
 1034|   100k|}
 1035|       |
 1036|       |namespace Impl {
 1037|       |class FsmMinimizeTask {
 1038|       |public:
 1039|       |	explicit FsmMinimizeTask(const Fsm& fsm)
 1040|       |		: mFsm(fsm)
 1041|       |		, reversedTransitions(fsm.Size())
 1042|       |		, StateClass(fsm.Size())
 1043|       |		, Classes(0)
 1044|   100k|	{
 1045|   100k|		Y_ASSERT(mFsm.IsDetermined());
 1046|       |
 1047|   100k|		TMap<bool, size_t> FinalStateClassMap;
 1048|       |
 1049|  2.90M|		for (size_t state = 0; state < mFsm.Size(); ++state) {
 1050|  2.80M|			reversedTransitions[state].resize(mFsm.Letters().Size());
 1051|  2.80M|			if (FinalStateClassMap.find(mFsm.IsFinal(state)) == FinalStateClassMap.end()) {
 1052|   200k|				FinalStateClassMap[mFsm.IsFinal(state)] = Classes++;
 1053|   200k|			}
 1054|  2.80M|			StateClass[state] = FinalStateClassMap[mFsm.IsFinal(state)];
 1055|  2.80M|		}
 1056|       |
 1057|  2.90M|		for (size_t state = 0; state < mFsm.Size(); ++state) {
 1058|  2.80M|			TSet<ypair<Char, size_t>> usedTransitions;
 1059|  50.4M|			for (const auto& transition : mFsm.m_transitions[state]) {
 1060|  50.4M|				Y_ASSERT(transition.second.size() == 1);
 1061|  50.4M|				auto destination = *transition.second.begin();
 1062|  50.4M|				auto letter = mFsm.Letters().Index(transition.first);
 1063|  50.4M|				if (usedTransitions.find(ymake_pair(letter, destination)) == usedTransitions.end()) {
 1064|  50.4M|					usedTransitions.insert(ymake_pair(letter, destination));
 1065|  50.4M|					reversedTransitions[destination][letter].push_back(state);
 1066|  50.4M|				}
 1067|  50.4M|			}
 1068|  2.80M|		}
 1069|   100k|	}
 1070|       |
 1071|   100k|	TVector<size_t>& GetStateClass() { return StateClass; }
 1072|       |
 1073|   148M|	size_t& GetClassesNumber() { return Classes; }
 1074|       |
 1075|  49.4M|	size_t LettersCount() const {
 1076|  49.4M|		return mFsm.Letters().Size();
 1077|  49.4M|	}
 1078|       |
 1079|   100k|	bool IsDetermined() const {
 1080|   100k|		return mFsm.IsDetermined();
 1081|   100k|	}
 1082|       |
 1083|  3.30M|	size_t Size() const {
 1084|  3.30M|		return mFsm.Size();
 1085|  3.30M|	}
 1086|       |
 1087|  98.4M|	const TVector<size_t>& Previous(size_t state, size_t letter) const {
 1088|  98.4M|		return reversedTransitions[state][letter];
 1089|  98.4M|	}
 1090|       |
 1091|   100k|	void AcceptStates() {
 1092|   100k|		mNewFsm.Resize(Classes);
 1093|   100k|		mNewFsm.letters = mFsm.letters;
 1094|   100k|		mNewFsm.determined = mFsm.determined;
 1095|   100k|		mNewFsm.m_sparsed = mFsm.m_sparsed;
 1096|   100k|		mNewFsm.SetFinal(0, false);
 1097|       |
 1098|       |		// Unite equality classes into new states
 1099|   100k|		size_t fromIdx = 0;
 1100|  2.90M|		for (auto from = mFsm.m_transitions.begin(), fromEnd = mFsm.m_transitions.end(); from != fromEnd; ++from, ++fromIdx) {
 1101|  2.80M|			size_t dest = StateClass[fromIdx];
 1102|  2.80M|			PIRE_IFDEBUG(Cdbg << "[min] State " << fromIdx << " becomes state " << dest << Endl);
 1103|  50.4M|			for (auto&& letter : *from) {
 1104|  50.4M|				Y_ASSERT(letter.second.size() == 1 || !"FSM::minimize(): FSM not deterministic");
 1105|  50.4M|				mNewFsm.Connect(dest, StateClass[*letter.second.begin()], letter.first);
 1106|  50.4M|			}
 1107|  2.80M|			if (mFsm.IsFinal(fromIdx)) {
 1108|   300k|				mNewFsm.SetFinal(dest, true);
 1109|   300k|				PIRE_IFDEBUG(Cdbg << "[min] New state " << dest << " becomes final because of old state " << fromIdx << Endl);
 1110|   300k|			}
 1111|       |
 1112|       |			// Append tags
 1113|  2.80M|			auto ti = mFsm.tags.find(fromIdx);
 1114|  2.80M|			if (ti != mFsm.tags.end()) {
 1115|      0|				mNewFsm.tags[dest] |= ti->second;
 1116|      0|				PIRE_IFDEBUG(Cdbg << "[min] New state " << dest << " carries tag " << ti->second << " because of old state " << fromIdx << Endl);
 1117|      0|			}
 1118|  2.80M|		}
 1119|   100k|		mNewFsm.initial = StateClass[mFsm.initial];
 1120|       |
 1121|       |		// Restore outputs
 1122|   100k|		for (auto&& output : mFsm.outputs)
 1123|      0|			for (auto&& output2 : output.second)
 1124|      0|				mNewFsm.outputs[StateClass[output.first]].insert(ymake_pair(StateClass[output2.first], output2.second));
 1125|   100k|	}
 1126|       |
 1127|       |	typedef bool Result;
 1128|       |
 1129|   100k|	Result Success() {
 1130|   100k|		return true;
 1131|   100k|	}
 1132|       |
 1133|      0|	Result Failure() {
 1134|      0|		return false;
 1135|      0|	}
 1136|       |
 1137|   100k|	Fsm& Output() {
 1138|   100k|		return mNewFsm;
 1139|   100k|	}
 1140|       |
 1141|       |private:
 1142|       |	const Fsm& mFsm;
 1143|       |	Fsm mNewFsm;
 1144|       |	TVector<TVector<TVector<size_t>>> reversedTransitions;
 1145|       |	TVector<size_t> StateClass;
 1146|       |	size_t Classes;
 1147|       |};
 1148|       |}
 1149|       |
 1150|       |void Fsm::Minimize()
 1151|   100k|{
 1152|       |	// Minimization algorithm is only applicable to a determined FSM.
 1153|   100k|	Y_ASSERT(determined);
 1154|       |
 1155|   100k|	Impl::FsmMinimizeTask task{*this};
 1156|   100k|	if (Pire::Impl::Minimize(task)) {
 1157|   100k|		task.Output().Swap(*this);
 1158|   100k|	}
 1159|   100k|}
 1160|       |
 1161|       |Fsm& Fsm::Canonize(size_t maxSize /* = 0 */)
 1162|   100k|{
 1163|   100k|	if (!IsDetermined()) {
 1164|   100k|		if (!Determine(maxSize)) 
 1165|      0|			throw Error("regexp pattern too complicated");
 1166|   100k|	}
 1167|   100k|	Minimize();
 1168|   100k|	return *this;
 1169|   100k|}
 1170|       |
 1171|       |void Fsm::PrependAnything()
 1172|   100k|{
 1173|   100k|	size_t newstate = Size();
 1174|   100k|	Resize(Size() + 1);
 1175|  26.5M|	for (size_t letter = 0; letter < MaxChar; ++letter)
 1176|  26.4M|		Connect(newstate, newstate, letter);
 1177|       |	
 1178|   100k|	Connect(newstate, initial);
 1179|   100k|	initial = newstate;
 1180|       |
 1181|   100k|	determined = false;
 1182|   100k|}
 1183|       |
 1184|       |void Fsm::AppendAnything()
 1185|   100k|{
 1186|   100k|	size_t newstate = Size();
 1187|   100k|	Resize(Size() + 1);
 1188|  26.5M|	for (size_t letter = 0; letter < MaxChar; ++letter)
 1189|  26.4M|		Connect(newstate, newstate, letter);
 1190|       |	
 1191|   100k|	ConnectFinal(newstate);
 1192|   100k|	ClearFinal();
 1193|   100k|	SetFinal(newstate, 1);
 1194|       |
 1195|   100k|	determined = false;
 1196|   100k|}
 1197|       |
 1198|       |Fsm& Fsm::Surround()
 1199|   100k|{
 1200|   100k|	PrependAnything();
 1201|   100k|	AppendAnything();
 1202|   100k|	return *this;
 1203|   100k|}
 1204|       |
 1205|       |void Fsm::Divert(size_t from, size_t to, size_t dest)
 1206|      0|{
 1207|      0|	if (to == dest)
 1208|      0|		return;
 1209|       |
 1210|       |	// Assign the output
 1211|      0|	auto oi = outputs.find(from);
 1212|      0|	if (oi != outputs.end()) {
 1213|      0|		auto oi2 = oi->second.find(to);
 1214|      0|		if (oi2 != oi->second.end()) {
 1215|      0|			unsigned long output = oi2->second;
 1216|      0|			oi->second.erase(oi2);
 1217|      0|			oi->second.insert(ymake_pair(dest, output));
 1218|      0|		}
 1219|      0|	}
 1220|       |
 1221|       |	// Assign the transition
 1222|      0|	for (auto&& i : m_transitions[from]) {
 1223|      0|		auto di = i.second.find(to);
 1224|      0|		if (di != i.second.end()) {
 1225|      0|			i.second.erase(di);
 1226|      0|			i.second.insert(dest);
 1227|      0|		}
 1228|      0|	}
 1229|       |
 1230|      0|	ClearHints();
 1231|      0|}
 1232|       |
 1233|       |
 1234|       |}

/home/johnpaul/pire/pire/fsm.h:
    1|       |/*
    2|       | * fsm.h -- the definition of the FSM class.
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#ifndef PIRE_FSM_H
   25|       |#define PIRE_FSM_H
   26|       |
   27|       |
   28|       |#include "stub/stl.h"
   29|       |#include "partition.h"
   30|       |#include "defs.h"
   31|       |
   32|       |namespace Pire {
   33|       |
   34|       |	namespace Impl {
   35|       |		class FsmDetermineTask;
   36|       |		class FsmMinimizeTask;
   37|       |		class HalfFinalDetermineTask;
   38|       |	}
   39|       |
   40|       |	/// A Flying Spaghetti Monster... no, just a Finite State Machine.
   41|       |	class Fsm {
   42|       |	public:		
   43|       |		typedef ybitset<MaxChar> Charset;
   44|       |
   45|       |		Fsm();
   46|       |		void Swap(Fsm& fsm);
   47|       |
   48|       |		static Fsm MakeFalse();
   49|       |
   50|       |		/// Current number of states
   51|  62.2M|		size_t Size() const { return m_transitions.size(); }
   52|       |
   53|       |		Fsm& Append(char c);
   54|       |		Fsm& Append(const ystring& str);
   55|       |		Fsm& AppendSpecial(Char c);
   56|       |
   57|       |		/// Efficiently appends a union of passed strings to FSM.
   58|       |		/// Used for ranges (e.g. [a-z]), character classes (e.g. \w, \d)
   59|       |		/// and case-insensitive comparison of multibyte characters,
   60|       |		/// when one string represents a lowercase variant of a character,
   61|       |		/// while another string represents its uppercase variant.
   62|       |		Fsm& AppendStrings(const TVector<ystring>& strings);
   63|       |
   64|       |		/// Appends a part matching a single byte (any).
   65|       |		Fsm& AppendDot();
   66|       |
   67|       |		/// Appends and prepends the FSM with the iterated dot (see above).
   68|       |		Fsm& Surround(); // returns *this
   69|      0|		Fsm Surrounded() const { Fsm copy(*this); copy.Surround(); return copy; }
   70|       |
   71|       |		Fsm& operator += (const Fsm& rhs); ///< Concatenation
   72|       |		Fsm& operator |= (const Fsm& rhs); ///< Alternation
   73|       |		Fsm& operator &= (const Fsm& rhs); ///< Conjunction
   74|       |		Fsm& Iterate();                    ///< Klene star
   75|       |		Fsm& Complement();                 ///< Complementation
   76|      0|		Fsm& operator *= (size_t count) { *this = *this * count; return *this; }
   77|       |
   78|      0|		Fsm operator + (const Fsm& rhs) const { Fsm a(*this); return a += rhs; }
   79|      0|		Fsm operator | (const Fsm& rhs) const { Fsm a(*this); return a |= rhs; }
   80|      0|		Fsm operator & (const Fsm& rhs) const { Fsm a(*this); return a &= rhs; }
   81|      0|		Fsm operator * ()               const { Fsm a(*this); return a.Iterate(); }
   82|      0|		Fsm operator ~ ()               const { Fsm a(*this); return a.Complement(); }
   83|       |		Fsm operator * (size_t count) const;
   84|       |
   85|       |		// === Raw FSM construction ===
   86|       |		
   87|       |		/// Connects two states with given transition
   88|       |		void Connect(size_t from, size_t to, Char c = Epsilon);
   89|       |		
   90|       |		/// Removes given character from the specified transition.
   91|       |		void Disconnect(size_t from, size_t to, Char c);
   92|       |		
   93|       |		/// Completely removes given transition
   94|       |		void Disconnect(size_t from, size_t to);
   95|       |
   96|       |		/// Creates an FSM which matches any prefix of any word current FSM matches.
   97|       |		void MakePrefix();
   98|       |
   99|       |		/// Creates an FSM which matches any suffix of any word current FSM matches.
  100|       |		void MakeSuffix();
  101|       |		
  102|       |		/// Does the one way part of Surround().
  103|       |		void PrependAnything();
  104|       |		void AppendAnything();
  105|       |		
  106|       |		/// Creates an FSM which matches reversed strings matched by current FSM.
  107|       |		Fsm& Reverse();
  108|       |
  109|       |		/// Returns a set of states from which no final states are reachable or that are not reachable from the start state.
  110|       |		TSet<size_t> DeadStates() const;
  111|       |
  112|       |		/// Removes all dead end paths from FSM
  113|       |		void RemoveDeadEnds();
  114|       |
  115|       |		/// Determines and minimizes the FSM if neccessary. Returns *this.
  116|       |		Fsm& Canonize(size_t maxSize = 0);
  117|       |		
  118|       |		template<class Scanner>
  119|       |		Scanner Compile(size_t distance = 0);
  120|       |
  121|       |		void DumpState(yostream& s, size_t state) const;
  122|       |		void DumpTo(yostream& s, const ystring& name = "") const;
  123|       |
  124|       |		typedef TSet<size_t> StatesSet;
  125|       |		typedef TMap<size_t, StatesSet> TransitionRow;
  126|       |		typedef TVector<TransitionRow> TransitionTable;
  127|       |
  128|       |		struct LettersEquality {
  129|   800k|			LettersEquality(const Fsm::TransitionTable& tbl): m_tbl(&tbl) {}
  130|       |			bool operator()(Char a, Char b) const;
  131|       |		private:
  132|       |			const Fsm::TransitionTable* m_tbl;
  133|       |		};
  134|       |
  135|       |		typedef TSet<size_t> FinalTable;
  136|       |		typedef Partition<Char, LettersEquality> LettersTbl;
  137|       |
  138|       |
  139|       |		/*
  140|       |		 * A very low level FSM building interface.
  141|       |		 *
  142|       |		 * It is generally unwise to call any of these functions unless you are building
  143|       |		 * your own scanner, your own ecoding or exaclty know what you are doing.
  144|       |		 */
  145|  2.60M|		unsigned long Tag(size_t state) const { Tags::const_iterator i = tags.find(state); return (i == tags.end()) ? 0 : i->second; }
  146|      0|		void SetTag(size_t state, unsigned long tag) { tags[state] = tag; }
  147|       |
  148|       |		unsigned long Output(size_t from, size_t to) const;
  149|      0|		void SetOutput(size_t from, size_t to, unsigned long output) { outputs[from][to] = output; }
  150|      0|		void ClearOutputs() { outputs.clear(); }
  151|       |
  152|   100k|		const FinalTable& Finals() const { return m_final; }
  153|  19.9M|		bool IsFinal(size_t state) const { return m_final.find(state) != m_final.end(); }
  154|       |		void SetFinal(size_t size, bool final);
  155|  2.00M|		void ClearFinal() { m_final.clear(); }
  156|       |
  157|       |		/// Removes all espilon transitions from the FSM. Does not change the FSMs language.
  158|       |		void RemoveEpsilons();
  159|       |
  160|       |		/// Resize FSM to newSize states. Returns old size.
  161|       |		size_t Resize(size_t newSize);
  162|       |
  163|       |		/// Imports foreign transition table
  164|       |		void Import(const Fsm& rhs);
  165|       |
  166|       |		/// Connects all final state with given state
  167|       |		void ConnectFinal(size_t to, Char c = Epsilon);
  168|       |
  169|       |		/// Diverts all transition between two given states to @p dest, preserving outputs
  170|       |		void Divert(size_t from, size_t to, size_t dest);
  171|       |
  172|       |		/// Checks whether two states are connected using given letter.
  173|       |		bool Connected(size_t from, size_t to, Char c) const;
  174|       |		
  175|       |		/// Returns a set of letters on which a transition from the specified state exists
  176|       |		TSet<Char> OutgoingLetters(size_t state) const;
  177|       |		
  178|       |		/// Returns a set of states where a transition from the given state using the given letter is possible
  179|       |		const StatesSet& Destinations(size_t from, Char letter) const;
  180|       |
  181|       |		/// Checks whether two states are connected using any letter.
  182|       |		bool Connected(size_t from, size_t to) const;
  183|  2.70M|		size_t Initial() const { return initial; }
  184|      0|		void SetInitial(size_t init) { initial = init; }
  185|       |		
  186|   253M|		const LettersTbl& Letters() const { return letters; }
  187|       |		
  188|       |		/// Determines the FSM.
  189|       |		/// Breaks FSM invariant of having a single final state, so high-level FSM building
  190|       |		/// functions (i.e. Append(), operator+(), etc...) no longer can be applied to the FSM
  191|       |		/// until the invariants have been manually restored.
  192|       |		/// return value: successful?
  193|       |		bool Determine(size_t maxsize = 0);
  194|   200k|		bool IsDetermined() const { return determined; }
  195|   100k|		void SetIsDetermined(bool det) { determined = det; }
  196|       |
  197|       |		/// Minimizes amount of states in the regexp.
  198|       |		/// Requires a determined FSM.
  199|       |		void Minimize();
  200|       |
  201|       |
  202|       |		/// Builds letters equivalence classes
  203|       |		void Sparse(bool needEpsilons = false);
  204|       |
  205|       |		/// Unpacks all letters equivalence classs back into transitions table
  206|       |		void Unsparse();
  207|       |
  208|       |	private:
  209|       |
  210|       |		/// Transitions table :: Q x V -> exp(Q)
  211|       |		TransitionTable m_transitions;
  212|       |
  213|       |		/// Initial state
  214|       |		size_t initial;
  215|       |
  216|       |		/// Final states.
  217|       |		FinalTable m_final;
  218|       |
  219|       |		LettersTbl letters;
  220|       |		
  221|       |		/// Does 'letters' make sense?
  222|       |		bool m_sparsed;
  223|       |
  224|       |		/// Is the FSM already determined?
  225|       |		bool determined;
  226|       |
  227|       |		/// Output
  228|       |		typedef TMap< size_t, TMap<size_t, unsigned long> > Outputs;
  229|       |		Outputs outputs;
  230|       |		
  231|       |		typedef TMap<size_t, unsigned long> Tags;
  232|       |		Tags tags;
  233|       |
  234|       |		/// Heuristics hit: true iff this FSM is a union of two other FSMs
  235|       |		bool isAlternative;
  236|       |		
  237|       |		void ShortCutEpsilon(size_t from, size_t thru, TVector< TSet<size_t> >& inveps); ///< internal
  238|       |		void MergeEpsilonConnection(size_t from, size_t to); ///< internal
  239|       |
  240|       |		TSet<size_t> TerminalStates() const;
  241|       |		
  242|       |		Char Translate(Char c) const;
  243|       |		
  244|   307M|		void ClearHints() { isAlternative = false; }
  245|       |		
  246|       |		friend class Impl::FsmDetermineTask;
  247|       |		friend class Impl::FsmMinimizeTask;
  248|       |		friend class Impl::HalfFinalDetermineTask;
  249|       |	};
  250|       |
  251|       |	template<class Scanner>
  252|       |	inline void BuildScanner(const Fsm& fsm, Scanner& r)
  253|   100k|	{
  254|   100k|		TSet<size_t> dead;
  255|   100k|		if (Scanner::DeadFlag)
  256|   100k|			dead = fsm.DeadStates();
  257|       |
  258|  2.70M|		for (size_t state = 0; state < fsm.Size(); ++state)
  259|  2.60M|			r.SetTag(state, typename Scanner::Tag(fsm.Tag(state)
  260|  2.60M|				| (fsm.IsFinal(state) ? Scanner::FinalFlag : 0)
  261|  2.60M|				| ((dead.find(state) != dead.end()) ? Scanner::DeadFlag : 0)));
  262|       |
  263|  2.70M|		for (size_t from = 0; from != fsm.Size(); ++from)
  264|  49.4M|			for (Fsm::LettersTbl::ConstIterator lit = fsm.Letters().Begin(), lie = fsm.Letters().End(); lit != lie; ++lit) {
  265|  46.8M|				const Fsm::StatesSet& tos = fsm.Destinations(from, lit->first);
  266|  93.6M|				for (Fsm::StatesSet::const_iterator to = tos.begin(), toEnd = tos.end(); to != toEnd; ++to)
  267|  46.8M|					r.SetJump(from, lit->first, *to, r.RemapAction(fsm.Output(from, *to)));
  268|  46.8M|			}
  269|       |		
  270|   100k|		r.FinishBuild();
  271|   100k|	}
  ------------------
  | _ZN4Pire12BuildScannerINS_4Impl7ScannerINS1_14NonrelocatableENS1_9ExitMasksILm2EEEEEEEvRKNS_3FsmERT_:
  |  253|   100k|	{
  |  254|   100k|		TSet<size_t> dead;
  |  255|   100k|		if (Scanner::DeadFlag)
  |  256|   100k|			dead = fsm.DeadStates();
  |  257|       |
  |  258|  2.70M|		for (size_t state = 0; state < fsm.Size(); ++state)
  |  259|  2.60M|			r.SetTag(state, typename Scanner::Tag(fsm.Tag(state)
  |  260|  2.60M|				| (fsm.IsFinal(state) ? Scanner::FinalFlag : 0)
  |  261|  2.60M|				| ((dead.find(state) != dead.end()) ? Scanner::DeadFlag : 0)));
  |  262|       |
  |  263|  2.70M|		for (size_t from = 0; from != fsm.Size(); ++from)
  |  264|  49.4M|			for (Fsm::LettersTbl::ConstIterator lit = fsm.Letters().Begin(), lie = fsm.Letters().End(); lit != lie; ++lit) {
  |  265|  46.8M|				const Fsm::StatesSet& tos = fsm.Destinations(from, lit->first);
  |  266|  93.6M|				for (Fsm::StatesSet::const_iterator to = tos.begin(), toEnd = tos.end(); to != toEnd; ++to)
  |  267|  46.8M|					r.SetJump(from, lit->first, *to, r.RemapAction(fsm.Output(from, *to)));
  |  268|  46.8M|			}
  |  269|       |		
  |  270|   100k|		r.FinishBuild();
  |  271|   100k|	}
  ------------------
  | Unexecuted instantiation: _ZN4Pire12BuildScannerINS_11SlowScannerEEEvRKNS_3FsmERT_
  ------------------
  272|       |	
  273|       |	template<class Scanner>
  274|       |	inline Scanner Fsm::Compile(size_t distance)
  275|   100k|	{
  276|   100k|		return Scanner(*this, distance);
  277|   100k|	}
  ------------------
  | _ZN4Pire3Fsm7CompileINS_4Impl7ScannerINS2_14NonrelocatableENS2_9ExitMasksILm2EEEEEEET_m:
  |  275|   100k|	{
  |  276|   100k|		return Scanner(*this, distance);
  |  277|   100k|	}
  ------------------
  | Unexecuted instantiation: _ZN4Pire3Fsm7CompileINS_13SimpleScannerEEET_m
  ------------------
  278|       |
  279|       |	yostream& operator << (yostream&, const Fsm&);
  280|       |}
  281|       |
  282|       |#endif

/home/johnpaul/pire/pire/half_final_fsm.h:
    1|       |#include "fsm.h"
    2|       |#include "defs.h"
    3|       |
    4|       |namespace Pire {
    5|       |	class HalfFinalFsm {
    6|       |	public:
    7|      0|		HalfFinalFsm(const Fsm& sourceFsm) : fsm(sourceFsm) {}
    8|       |
    9|       |		void MakeScanner();
   10|       |
   11|       |		/// Non greedy counter without allowed intersects works correctly on all regexps
   12|       |		/// Non simplified non greedy counter with allowed intersects counts number of positions in string,
   13|       |		/// on which ends at least one substring that matches regexp
   14|       |		/// Simplified non greedy counter with allowed intersects does not always work correctly,
   15|       |		/// but has fewer number of states and more regexps can be glued into single scanner
   16|       |		void MakeNonGreedyCounter(bool allowIntersects = true, bool simplify = true);
   17|       |
   18|       |		// Simplified counter does not work correctly on all regexps, but has less number of states
   19|       |		// and allows to glue larger number of scanners into one within the same size limit
   20|       |		void MakeGreedyCounter(bool simplify = true);
   21|       |
   22|      0|		const Fsm& GetFsm() const { return fsm; }
   23|       |
   24|       |		template<class Scanner>
   25|       |		Scanner Compile() const;
   26|       |
   27|       |		size_t GetCount(size_t state) const;
   28|       |
   29|       |		size_t GetTotalCount() const;
   30|       |
   31|       |		static size_t MaxCountDepth;
   32|       |	private:
   33|       |		Fsm fsm;
   34|       |
   35|       |		bool AllowHalfFinals();
   36|       |
   37|       |		void MakeHalfFinal();
   38|       |
   39|       |		void DisconnectFinals(bool allowIntersects);
   40|       |
   41|       |		void Determine(size_t depth = MaxCountDepth);
   42|       |	};
   43|       |
   44|       |	template<class Scanner>
   45|       |	Scanner HalfFinalFsm::Compile() const {
   46|       |		auto scanner = Scanner(*this);
   47|       |	}
   48|       |}

/home/johnpaul/pire/pire/minimize.h:
    1|       |#ifndef PIRE_MINIMIZE_H
    2|       |#define PIRE_MINIMIZE_H
    3|       |
    4|       |#include "stub/stl.h"
    5|       |#include "partition.h"
    6|       |
    7|       |namespace Pire {
    8|       |	namespace Impl {
    9|       |
   10|       |		/**
   11|       |		 * An interface of a minimization task.
   12|       |		 * You don't have to derive from this class; it is just a start point template.
   13|       |		 */
   14|       |		class MinimizeTask {
   15|       |		private:
   16|       |			struct ImplementationSpecific1;
   17|       |
   18|       |		public:
   19|       |			// States must be represented by size_t.
   20|       |
   21|       |			/// States must be initially divided into some equivalence classes.
   22|       |			/// If states are in the same equivalence class, they may be merged without loosing state specific info.
   23|       |			/// Equivalence classes must have indexes from 0 to (Classes - 1).
   24|       |			/// The algorithm will modify equivalent classes and in the end
   25|       |			/// all states in the same equivalent class can be merged into one state
   26|      0|			TVector<size_t>& GetStateClass() { return StateClass; }
   27|       |
   28|       |			/// Returns number of equivalent classes
   29|      0|			size_t& GetClassesNumber() { return Classes; }
   30|       |
   31|       |			/// Should return number of letter classes
   32|       |			size_t LettersCount() const;
   33|       |
   34|       |			/// Should return true if FSM is determined.
   35|       |			bool IsDetermined() const;
   36|       |
   37|       |			/// Should return number of states.
   38|       |			size_t Size() const;
   39|       |
   40|       |			/// Should calculate vector of previous states by, given the current state and incoming letter class index.
   41|       |			const TVector<size_t>& Previous(size_t state, size_t letter) const;
   42|       |
   43|       |			/// Called when states equivalent classes are formed, and written in StateClass.
   44|       |			void AcceptStates();
   45|       |
   46|       |			typedef bool Result;
   47|       |
   48|      0|			Result Success() { return true; }
   49|       |
   50|      0|			Result Failure() { return false; }
   51|       |
   52|       |		private:
   53|       |			TVector<size_t> StateClass;
   54|       |
   55|       |			size_t Classes;
   56|       |		};
   57|       |
   58|       |		// Minimizes Determined FSM using Hopcroft algorithm, works in O(Size * log(Size) * MaxChar) time,
   59|       |		// requires O(Size * MaxChar * sizof(size_t)) memory.
   60|       |		template<class Task>
   61|       |		typename Task::Result Minimize(Task& task)
   62|   100k|		{
   63|       |			// Minimization algorithm is only applicable to a determined FSM.
   64|   100k|			if (!task.IsDetermined()) {
   65|      0|				return task.Failure();
   66|      0|			}
   67|       |
   68|   100k|			typedef ypair<size_t, size_t> ClassLetter;
   69|       |
   70|   100k|			TVector<ybitset<MaxChar>> queuedClasses(task.Size());
   71|       |
   72|   100k|			TDeque<ClassLetter> classesToProcess;
   73|       |
   74|   100k|			TVector<TVector<size_t>> classStates(task.Size());
   75|       |
   76|   100k|			TVector<size_t>& stateClass = task.GetStateClass();
   77|       |
   78|  2.90M|			for (size_t state = 0; state < task.Size(); ++state) {
   79|  2.80M|				classStates[stateClass[state]].push_back(state);
   80|  2.80M|			}
   81|       |
   82|   300k|			for (size_t classIndex = 0; classIndex < task.GetClassesNumber(); ++classIndex) {
   83|  3.80M|				for (size_t letter = 0; letter < task.LettersCount(); ++letter) {
   84|  3.60M|					classesToProcess.push_back(ymake_pair(classIndex, letter));
   85|  3.60M|					queuedClasses[classIndex][letter] = 1;
   86|  3.60M|				}
   87|   200k|			}
   88|       |
   89|   100k|			TVector<size_t> classChange(task.Size());
   90|   100k|			TVector<TVector<size_t>> removedStates(task.Size());
   91|       |
   92|  46.9M|			while (classesToProcess.size()) {
   93|  46.8M|				const auto currentClass = classesToProcess.front().first;
   94|  46.8M|				const auto currentLetter = classesToProcess.front().second;
   95|  46.8M|				classesToProcess.pop_front();
   96|  46.8M|				queuedClasses[currentClass][currentLetter] = 0;
   97|  46.8M|				TVector<size_t> splittedClasses;
   98|       |
   99|  98.4M|				for (const auto& classState : classStates[currentClass]) {
  100|  98.4M|					for (const auto& state: task.Previous(classState, currentLetter)) {
  101|  95.5M|						if (classChange[stateClass[state]] != task.GetClassesNumber()) {
  102|  50.7M|							classChange[stateClass[state]] = task.GetClassesNumber();
  103|  50.7M|							splittedClasses.push_back(stateClass[state]);
  104|  50.7M|						}
  105|  95.5M|						removedStates[stateClass[state]].push_back(state);
  106|  95.5M|					}
  107|  98.4M|				}
  108|       |
  109|       |
  110|  50.7M|				for (const auto& splittedClass : splittedClasses) {
  111|  50.7M|					if (removedStates[splittedClass].size() == classStates[splittedClass].size()) {
  112|  48.3M|						classChange[splittedClass] = 0;
  113|  48.3M|						removedStates[splittedClass].clear();
  114|  48.3M|						continue;
  115|  48.3M|					}
  116|       |
  117|  2.40M|					const auto newClass = task.GetClassesNumber()++;
  118|  2.40M|					classChange[splittedClass] = newClass;
  119|  2.40M|					std::swap(classStates[newClass], removedStates[splittedClass]);
  120|  5.10M|					for (const auto& state : classStates[newClass]) {
  121|  5.10M|						stateClass[state] = newClass;
  122|  5.10M|					}
  123|       |
  124|  2.40M|					auto iter = classStates[splittedClass].begin();
  125|  29.2M|					for (const auto state : classStates[splittedClass]) {
  126|  29.2M|						if (stateClass[state] == splittedClass) {
  127|  24.1M|							*iter = state;
  128|  24.1M|							++iter;
  129|  24.1M|						}
  130|  29.2M|					}
  131|  2.40M|					classStates[splittedClass].erase(iter, classStates[splittedClass].end());
  132|       |
  133|  45.6M|					for (size_t letter = 0; letter < task.LettersCount(); ++letter) {
  134|  43.2M|						if (queuedClasses[splittedClass][letter]
  135|  43.2M|							|| classStates[splittedClass].size() > classStates[newClass].size()) {
  136|       |
  137|  33.6M|							queuedClasses[newClass][letter] = 1;
  138|  33.6M|							classesToProcess.push_back(ymake_pair(newClass, letter));
  139|  33.6M|						} else {
  140|  9.60M|							queuedClasses[splittedClass][letter] = 1;
  141|  9.60M|							classesToProcess.push_back(ymake_pair(splittedClass, letter));
  142|  9.60M|						}
  143|  43.2M|					}
  144|  2.40M|				}
  145|  46.8M|			}
  146|       |
  147|   100k|			task.AcceptStates();
  148|   100k|			return task.Success();
  149|   100k|		}
  150|       |	}
  151|       |}
  152|       |
  153|       |#endif

/home/johnpaul/pire/pire/partition.h:
    1|       |/*
    2|       | * partition.h -- a disjoint set of pairwise equivalent items
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#ifndef PIRE_PARTITION_H
   25|       |#define PIRE_PARTITION_H
   26|       |
   27|       |
   28|       |#include "stub/stl.h"
   29|       |#include "stub/singleton.h"
   30|       |
   31|       |namespace Pire {
   32|       |
   33|       |/*
   34|       |* A class which forms a disjoint set of pairwise equivalent items,
   35|       |* depending on given equivalence relation.
   36|       |*/
   37|       |template<class T, class Eq>
   38|       |class Partition {
   39|       |private:
   40|       |	typedef TMap< T, ypair< size_t, TVector<T> > > Set;
   41|       |
   42|       |public:
   43|       |	Partition(const Eq& eq)
   44|       |		: m_eq(eq)
   45|       |		, m_maxidx(0)
   46|   800k|	{
   47|   800k|	}
   48|       |
   49|       |	/// Appends a new item into partition, creating new equivalience class if neccessary.
   50|  26.3M|	void Append(const T& t) {
   51|  26.3M|		DoAppend(m_set, t);
   52|  26.3M|	}
   53|       |
   54|       |	typedef typename Set::const_iterator ConstIterator;
   55|       |
   56|  2.60M|	ConstIterator Begin() const {
   57|  2.60M|		return m_set.begin();
   58|  2.60M|	}
   59|  6.60M|	ConstIterator begin() const {
   60|  6.60M|		return m_set.begin();
   61|  6.60M|	}
   62|  2.60M|	ConstIterator End() const {
   63|  2.60M|		return m_set.end();
   64|  2.60M|	}
   65|  6.60M|	ConstIterator end() const {
   66|  6.60M|		return m_set.end();
   67|  6.60M|	}
   68|  55.0M|	size_t Size() const {
   69|  55.0M|		return m_set.size();
   70|  55.0M|	}
   71|       |	bool Empty() const {
   72|       |		return m_set.empty();
   73|       |	}
   74|       |
   75|       |	/// Returns an item equal to @p t. It is guaranteed that:
   76|       |	/// - representative(a) equals representative(b) iff a is equivalent to b;
   77|       |	/// - representative(a) is equivalent to a.
   78|       |	const T& Representative(const T& t) const
   79|   145M|	{
   80|   145M|		auto it = m_inv.find(t);
   81|   145M|		if (it != m_inv.end())
   82|   145M|			return it->second;
   83|      0|		else
   84|      0|			return DefaultValue<T>();
   85|   145M|	}
   86|       |	
   87|       |	bool Contains(const T& t) const
   88|      0|	{
   89|      0|		return m_inv.find(t) != m_inv.end();
   90|      0|	}
   91|       |
   92|       |	/// Returns an index of set containing @p t. It is guaranteed that:
   93|       |	/// - index(a) equals index(b) iff a is equivalent to b;
   94|       |	/// - 0 <= index(a) < size().
   95|       |	size_t Index(const T& t) const
   96|  50.4M|	{
   97|  50.4M|		auto it = m_inv.find(t);
   98|  50.4M|		if (it == m_inv.end())
   99|      0|			throw Error("Partition::index(): attempted to obtain an index of nonexistent item");
  100|  50.4M|		auto it2 = m_set.find(it->second);
  101|  50.4M|		Y_ASSERT(it2 != m_set.end());
  102|  50.4M|		return it2->second.first;
  103|  50.4M|	}
  104|       |	/// Returns the whole equivalence class of @p t (i.e. item @p i
  105|       |	/// is returned iff representative(i) == representative(t)).
  106|       |	const TVector<T>& Klass(const T& t) const
  107|      0|	{
  108|      0|		auto it = m_inv.find(t);
  109|      0|		if (it == m_inv.end())
  110|      0|			throw Error("Partition::index(): attempted to obtain an index of nonexistent item");
  111|      0|		auto it2 = m_set.find(it->second);
  112|      0|		Y_ASSERT(it2 != m_set.end());
  113|      0|		return it2->second.second;
  114|      0|	}
  115|       |
  116|       |	bool operator == (const Partition& rhs) const { return m_set == rhs.m_set; }
  117|       |	bool operator != (const Partition& rhs) const { return !(*this == rhs); }
  118|       |
  119|       |	/// Splits the current sets into smaller ones, using given equivalence relation.
  120|       |	/// Requires given relation imply previous one (set either in ctor or
  121|       |	/// in preceeding calls to split()), but performs faster.
  122|       |	/// Replaces previous relation with given one.
  123|       |	void Split(const Eq& eq)
  124|       |	{
  125|       |		m_eq = eq;
  126|       |
  127|       |		for (auto&& element : m_set)
  128|       |			if (element.second.second.size() > 1) {
  129|       |				TVector<T>& v = element.second.second;
  130|       |				auto bound = std::partition(v.begin(), v.end(), std::bind2nd(m_eq, v[0]));
  131|       |				if (bound == v.end())
  132|       |					continue;
  133|       |
  134|       |				Set delta;
  135|       |				for (auto it = bound, ie = v.end(); it != ie; ++it)
  136|       |					DoAppend(delta, *it);
  137|       |
  138|       |				v.erase(bound, v.end());
  139|       |				m_set.insert(delta.begin(), delta.end());
  140|       |			}
  141|       |	}
  142|       |
  143|       |private:
  144|       |	Eq m_eq;
  145|       |	Set m_set;
  146|       |	TMap<T, T> m_inv;
  147|       |	size_t m_maxidx;
  148|       |
  149|       |	void DoAppend(Set& set, const T& t)
  150|  26.3M|	{
  151|  26.3M|		auto it = set.begin();
  152|  26.3M|		auto end = set.end();
  153|   224M|		for (; it != end; ++it)
  154|   222M|			if (m_eq(it->first, t)) {
  155|  24.5M|				it->second.second.push_back(t);
  156|  24.5M|				m_inv[t] = it->first;
  157|  24.5M|				break;
  158|  24.5M|			}
  159|       |
  160|  26.3M|		if (it == end) {
  161|       |			// Begin new set
  162|  1.80M|			TVector<T> v(1, t);
  163|  1.80M|			set.insert(ymake_pair(t, ymake_pair(m_maxidx++, v)));
  164|  1.80M|			m_inv[t] = t;
  165|  1.80M|		}
  166|  26.3M|	}
  167|       |};
  168|       |
  169|       |// Mainly for debugging
  170|       |template<class T, class Eq>
  171|       |yostream& operator << (yostream& stream, const Partition<T, Eq>& partition)
  172|       |{
  173|       |	stream << "Partition {\n";
  174|       |	for (auto&& partitionElement : partition) {
  175|       |		stream << "    Class " << partitionElement.second.first << " \"" << partitionElement.first << "\" { ";
  176|       |		bool first = false;
  177|       |		for (auto&& element : partitionElement.second.second) {
  178|       |			if (first)
  179|       |				stream << ", ";
  180|       |			else
  181|       |				first = true;
  182|       |			stream << element;
  183|       |		}
  184|       |		stream << " }\n";
  185|       |	}
  186|       |	stream << "}";
  187|       |	return stream;
  188|       |}
  189|       |
  190|       |}
  191|       |
  192|       |
  193|       |#endif

/home/johnpaul/pire/pire/platform.h:
    1|       |/*
    2|       | * platform.h -- hardware and OS specific stuff
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | *
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |#ifndef PIRE_PLATFORM_H_INCLUDED
   24|       |#define PIRE_PLATFORM_H_INCLUDED
   25|       |
   26|       |#include "stub/defaults.h"
   27|       |#include "static_assert.h"
   28|       |
   29|       |#ifndef PIRE_FORCED_INLINE
   30|       |#ifdef __GNUC__
   31|       |#define PIRE_FORCED_INLINE inline __attribute__((__always_inline__))
   32|       |#elif _MSC_VER
   33|       |#define PIRE_FORCED_INLINE __forceinline
   34|       |#else
   35|       |#define PIRE_FORCED_INLINE inline
   36|       |#endif
   37|       |#endif
   38|       |
   39|       |#if (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ > 2))
   40|       |#define PIRE_HOT_FUNCTION __attribute__ ((hot))
   41|       |#else
   42|       |#define PIRE_HOT_FUNCTION
   43|       |#endif
   44|       |
   45|       |#ifndef PIRE_LIKELY
   46|       |#ifdef __GNUC__
   47|       |#define PIRE_LIKELY(x) (__builtin_expect((x), 1))
   48|       |#else
   49|       |#define PIRE_LIKELY(x) (x)
   50|       |#endif
   51|       |#endif
   52|       |
   53|       |#ifndef PIRE_UNLIKELY
   54|       |#ifdef __GNUC__
   55|  1.84M|#define PIRE_UNLIKELY(x) (__builtin_expect((x), 0))
   56|       |#else
   57|       |#define PIRE_UNLIKELY(x) (x)
   58|       |#endif
   59|       |#endif
   60|       |
   61|       |#ifdef _MSC_VER
   62|       |#include <stdio.h>
   63|       |#include <stdarg.h>
   64|       |
   65|       |namespace Pire {
   66|       |
   67|       |#ifdef _WIN64
   68|       |typedef i64 ssize_t;
   69|       |#else
   70|       |typedef i32 ssize_t;
   71|       |#endif
   72|       |
   73|       |inline int snprintf(char *str, size_t size, const char *format, ...)
   74|       |{
   75|       |	va_list argptr;
   76|       |	va_start(argptr, format);
   77|       |	int i = _vsnprintf(str, size-1, format, argptr);
   78|       |	va_end(argptr);
   79|       |
   80|       |	// A workaround for some bug
   81|       |	if (i < 0) {
   82|       |		str[size - 1] = '\x00';
   83|       |		i = (int)size;
   84|       |	} else if (i < (int)size) {
   85|       |		str[i] = '\x00';
   86|       |	}
   87|       |	return i;
   88|       |}
   89|       |
   90|       |}
   91|       |#endif
   92|       |
   93|       |namespace Pire {
   94|       |namespace Impl {
   95|       |
   96|       |// A portable way to define a constant like `(size_t)0101010101010101ull'
   97|       |// without any compiler warnings.
   98|       |template<unsigned Pos, unsigned char Byte>
   99|       |struct DoGenerateMask {
  100|       |	static const size_t Value = DoGenerateMask<Pos-1, Byte>::Value << 8 | (size_t) Byte;
  101|       |};
  102|       |
  103|       |template<unsigned char Byte>
  104|       |struct DoGenerateMask<0, Byte> {
  105|       |	static const size_t Value = 0;
  106|       |};
  107|       |
  108|       |template<unsigned char Byte>
  109|       |struct GenerateMask {
  110|       |	static const size_t Value = DoGenerateMask<sizeof(size_t), Byte>::Value;
  111|       |};
  112|       |
  113|       |
  114|       |// Common implementation of mask comparison logic suitable for
  115|       |// any instruction set
  116|       |struct BasicInstructionSet {
  117|       |	typedef size_t Vector;
  118|       |
  119|       |	// Check bytes in the chunk against bytes in the mask
  120|       |	static inline Vector CheckBytes(Vector mask, Vector chunk)
  121|      0|	{
  122|      0|		size_t mc = chunk ^ mask;
  123|      0|		return ((mc - GenerateMask<0x01>::Value) & ~mc & GenerateMask<0x80>::Value);
  124|      0|	}
  125|       |
  126|      0|	static inline Vector Or(Vector mask1, Vector mask2) { return (mask1 | mask2); }
  127|       |
  128|      0|	static inline bool IsAnySet(Vector mask) { return (mask != 0); }
  129|       |};
  130|       |
  131|       |}}
  132|       |
  133|       |#if defined(__SSE2__)
  134|       |#include <emmintrin.h>
  135|       |
  136|       |namespace Pire {
  137|       |namespace Impl {
  138|       |
  139|       |// SSE2-optimized mask comparison logic
  140|       |struct AvailSSE2 {
  141|       |	typedef __m128i Vector;
  142|       |
  143|       |	static inline Vector CheckBytes(Vector mask, Vector chunk)
  144|  2.44M|	{
  145|  2.44M|		return _mm_cmpeq_epi8(mask, chunk);
  146|  2.44M|	}
  147|       |
  148|       |	static inline Vector Or(Vector mask1, Vector mask2)
  149|      0|	{
  150|      0|		return _mm_or_si128(mask1, mask2);
  151|      0|	}
  152|       |
  153|       |	static inline bool IsAnySet(Vector mask)
  154|  2.44M|	{
  155|  2.44M|		return _mm_movemask_epi8(mask);
  156|  2.44M|	}
  157|       |};
  158|       |
  159|       |typedef AvailSSE2 AvailInstructionSet;
  160|       |
  161|  2.44M|inline AvailSSE2::Vector ToLittleEndian(AvailSSE2::Vector x) { return x; }
  162|       |
  163|       |}}
  164|       |
  165|       |#elif defined(__MMX__)
  166|       |#include <mmintrin.h>
  167|       |
  168|       |namespace Pire {
  169|       |namespace Impl {
  170|       |
  171|       |// MMX-optimized mask comparison logic
  172|       |struct AvailMMX {
  173|       |	typedef __m64 Vector;
  174|       |
  175|       |	static inline Vector CheckBytes(Vector mask, Vector chunk)
  176|       |	{
  177|       |		return _mm_cmpeq_pi8(mask, chunk);
  178|       |	}
  179|       |
  180|       |	static inline Vector Or(Vector mask1, Vector mask2)
  181|       |	{
  182|       |		return _mm_or_si64(mask1, mask2);
  183|       |	}
  184|       |
  185|       |	static inline bool IsAnySet(Vector mask)
  186|       |	{
  187|       |		union {
  188|       |			Vector mmxMask;
  189|       |			ui64 ui64Mask;
  190|       |		};
  191|       |		mmxMask = mask;
  192|       |		return ui64Mask;
  193|       |	}
  194|       |};
  195|       |
  196|       |typedef AvailMMX AvailInstructionSet;
  197|       |
  198|       |inline AvailMMX::Vector ToLittleEndian(AvailMMX::Vector x) { return x; }
  199|       |
  200|       |}}
  201|       |
  202|       |#else // no SSE and MMX
  203|       |
  204|       |namespace Pire {
  205|       |namespace Impl {
  206|       |
  207|       |typedef BasicInstructionSet AvailInstructionSet;
  208|       |
  209|       |}}
  210|       |
  211|       |#endif
  212|       |
  213|       |namespace Pire {
  214|       |namespace Impl {
  215|       |
  216|       |typedef AvailInstructionSet::Vector Word;
  217|       |
  218|  2.44M|inline Word CheckBytes(Word mask, Word chunk) { return AvailInstructionSet::CheckBytes(mask, chunk); }
  219|       |
  220|      0|inline Word Or(Word mask1, Word mask2) { return AvailInstructionSet::Or(mask1, mask2); }
  221|       |
  222|  2.44M|inline bool IsAnySet(Word mask) { return AvailInstructionSet::IsAnySet(mask); }
  223|       |
  224|       |// MaxSizeWord type is largest integer type supported by the plaform including
  225|       |// all possible SSE extensions that are are known for this platform (even if these
  226|       |// extensions are not available at compile time)
  227|       |// It is used for alignments and save/load data structures to produce data format
  228|       |// compatible between all platforms with the same endianness and pointer size
  229|       |template <size_t Size> struct MaxWordSizeHelper;
  230|       |
  231|       |// Maximum size of SSE register is 128 bit on x86 and x86_64
  232|       |template <>
  233|       |struct MaxWordSizeHelper<16> {
  234|       |	struct MaxSizeWord {
  235|       |		char val[16];
  236|       |	};
  237|       |};
  238|       |
  239|       |typedef MaxWordSizeHelper<16>::MaxSizeWord MaxSizeWord;
  240|       |
  241|       |// MaxSizeWord size should be a multiple of size_t size and a multipe of Word size
  242|       |PIRE_STATIC_ASSERT(
  243|       |	(sizeof(MaxSizeWord) % sizeof(size_t) == 0) &&
  244|       |	(sizeof(MaxSizeWord) % sizeof(Word) == 0));
  245|       |
  246|       |inline size_t FillSizeT(char c)
  247|   100k|{
  248|   100k|	size_t w = c;
  249|   100k|	w &= 0x0ff;
  250|   400k|	for (size_t i = 8; i != sizeof(size_t)*8; i <<= 1)
  251|   300k|		w = (w << i) | w;
  252|   100k|	return w;
  253|   100k|}
  254|       |
  255|       |}}
  256|       |
  257|       |#endif
  258|       |

/home/johnpaul/pire/pire/re_lexer.cpp:
    1|       |/*
    2|       | * re_lexer.cpp -- implementation of Lexer class
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#include <ctype.h>
   25|       |#include "stub/utf8.h"
   26|       |#include "stub/singleton.h"
   27|       |#include <stdexcept>
   28|       |#include "re_lexer.h"
   29|       |#include "re_parser.h"
   30|       |#include "read_unicode.h"
   31|       |#include "fsm.h"
   32|       |#include "stub/stl.h"
   33|       |
   34|       |namespace Pire {
   35|       |
   36|       |namespace Impl {
   37|       |	int yre_parse(Pire::Lexer& lexer);
   38|       |}
   39|       |
   40|  1.70M|Term Term::Character(wchar32 c) { Term::CharacterRange cr; cr.first.insert(Term::String(1, c)); cr.second = false; return Term(TokenTypes::Letters, cr); }
   41|      0|Term Term::Repetition(int lower, int upper) { return Term(TokenTypes::Count, RepetitionCount(lower, upper)); }
   42|   100k|Term Term::Dot() { return Term(TokenTypes::Dot, DotTag()); }
   43|      0|Term Term::BeginMark() { return Term(TokenTypes::BeginMark, BeginTag()); }
   44|      0|Term Term::EndMark() { return Term(TokenTypes::EndMark, EndTag()); }
   45|       |
   46|   100k|Lexer::~Lexer() = default;
   47|       |
   48|       |wchar32 Lexer::GetChar()
   49|  4.10M|{
   50|  4.10M|	if (m_input.empty())
   51|   100k|		return End;
   52|  4.00M|	else if (m_input.front() == '\\') {
   53|      0|		m_input.pop_front();
   54|      0|		if (m_input.empty())
   55|      0|			Error("Regexp must not end with a backslash");
   56|      0|		wchar32 ch = m_input.front();
   57|      0|		m_input.pop_front();
   58|      0|		return Control | ch;
   59|  4.00M|	} else {
   60|  4.00M|		wchar32 ch = m_input.front();
   61|  4.00M|		m_input.pop_front();
   62|  4.00M|		return ch;
   63|  4.00M|	}
   64|  4.10M|}
   65|       |
   66|       |wchar32 Lexer::PeekChar()
   67|  2.10M|{
   68|  2.10M|	if (m_input.empty())
   69|   100k|		return End;
   70|  2.00M|	else
   71|  2.00M|		return m_input.front();
   72|  2.10M|}
   73|       |
   74|       |void Lexer::UngetChar(wchar32 c)
   75|  2.10M|{
   76|  2.10M|	if (c != End)
   77|  2.00M|		m_input.push_front(c);
   78|  2.10M|}
   79|       |
   80|       |namespace {
   81|       |	class CompareFeaturesByPriority: public ybinary_function<const Feature::Ptr&, const Feature::Ptr&, bool> {
   82|       |	public:
   83|       |		bool operator()(const Feature::Ptr& a, const Feature::Ptr& b) const
   84|   500k|		{
   85|   500k|			return a->Priority() < b->Priority();
   86|   500k|		}
   87|       |	};
   88|       |}
   89|       |
   90|       |Lexer& Lexer::AddFeature(Feature::Ptr& feature)
   91|      0|{
   92|      0|	feature->m_lexer = this;
   93|      0|	m_features.insert(LowerBound(m_features.begin(), m_features.end(), feature, CompareFeaturesByPriority()), std::move(feature));
   94|      0|	return *this;
   95|      0|}
   96|       |
   97|       |Lexer& Lexer::AddFeature(Feature::Ptr&& feature)
   98|   400k|{
   99|   400k|    feature->m_lexer = this;
  100|   400k|    m_features.insert(LowerBound(m_features.begin(), m_features.end(), feature, CompareFeaturesByPriority()), std::move(feature));
  101|   400k|    return *this;
  102|   400k|}
  103|       |
  104|       |Term Lexer::DoLex()
  105|  2.10M|{
  106|  2.10M|	static const char* controls = "|().*+?^$\\";
  107|  2.10M|	for (;;) {
  108|  2.10M|		UngetChar(GetChar());
  109|  2.10M|		wchar32 ch = PeekChar();
  110|  2.10M|		if (ch == End)
  111|   100k|			return Term(TokenTypes::End);
  112|  8.00M|		for (auto&& i : m_features) {
  113|  8.00M|			if (i->Accepts(ch)) {
  114|      0|				Term ret = i->Lex();
  115|      0|				if (ret.Type())
  116|      0|					return ret;
  117|      0|			}
  118|  8.00M|		}
  119|  2.00M|		ch = GetChar();
  120|       |
  121|  2.00M|		if (ch == '|')
  122|      0|			return Term(TokenTypes::Or);
  123|  2.00M|		else if (ch == '(') {
  124|   100k|			return Term(TokenTypes::Open);
  125|  1.90M|		} else if (ch == ')')
  126|   100k|			return Term(TokenTypes::Close);
  127|  1.80M|		else if (ch == '.')
  128|   100k|			return Term::Dot();
  129|  1.70M|		else if (ch == '*')
  130|      0|			return Term::Repetition(0, Inf);
  131|  1.70M|		else if (ch == '+')
  132|      0|			return Term::Repetition(1, Inf);
  133|  1.70M|		else if (ch == '?')
  134|      0|			return Term::Repetition(0, 1);
  135|  1.70M|		else if (ch == '^')
  136|      0|			return Term::BeginMark();
  137|  1.70M|		else if (ch == '$')
  138|      0|			return Term::EndMark();
  139|  1.70M|		else if ((ch & ControlMask) == Control && strchr(controls, ch & ~ControlMask))
  140|      0|			return Term::Character(ch & ~ControlMask);
  141|  1.70M|		else
  142|  1.70M|			return Term::Character(ch);
  143|  2.00M|	}
  144|  2.10M|}
  145|       |
  146|       |Term Lexer::Lex()
  147|  2.10M|{
  148|  2.10M|	Term t = DoLex();
  149|       |
  150|  10.5M|	for (auto i = m_features.rbegin(), ie = m_features.rend(); i != ie; ++i)
  151|  8.40M|		(*i)->Alter(t);
  152|       |
  153|  2.10M|	if (t.Value().IsA<Term::CharacterRange>()) {
  154|  1.70M|		const auto& chars = t.Value().As<Term::CharacterRange>();
  155|       |		//std::cerr << "lex: type " << t.type() << "; chars = { " << join(chars.first.begin(), chars.first.end(), ", ") << " }" << std::endl;
  156|  1.70M|		for (auto&& i : chars.first)
  157|  1.70M|			for (auto&& j : i)
  158|  1.70M|				if ((j & ControlMask) == Control)
  159|      0|					Error("Control character in tokens sequence");
  160|  1.70M|	}
  161|       |	
  162|  2.10M|	int type = t.Type();
  163|  2.10M|	if (type == TokenTypes::Letters)
  164|  1.70M|		type = YRE_LETTERS;
  165|   400k|	else if (type == TokenTypes::Count)
  166|      0|		type = YRE_COUNT;
  167|   400k|	else if (type == TokenTypes::Dot)
  168|   100k|		type = YRE_DOT;
  169|   300k|	else if (type == TokenTypes::Open)
  170|   100k|		type = '(';
  171|   200k|	else if (type == TokenTypes::Close)
  172|   100k|		type = ')';
  173|   100k|	else if (type == TokenTypes::Or)
  174|      0|		type = '|';
  175|   100k|	else if (type == TokenTypes::And)
  176|      0|		type = YRE_AND;
  177|   100k|	else if (type == TokenTypes::Not)
  178|      0|		type = YRE_NOT;
  179|   100k|	else if (type == TokenTypes::BeginMark)
  180|      0|		type = '^';
  181|   100k|	else if (type == TokenTypes::EndMark)
  182|      0|		type = '$';
  183|   100k|	else if (type == TokenTypes::End)
  184|   100k|		type = 0;
  185|  2.10M|	return Term(type, t.Value());
  186|  2.10M|}
  187|       |
  188|       |void Lexer::Parenthesized(Fsm& fsm)
  189|   100k|{
  190|   500k|	for (auto i = m_features.rbegin(), ie = m_features.rend(); i != ie; ++i)
  191|   400k|		(*i)->Parenthesized(fsm);
  192|   100k|}
  193|       |
  194|       |wchar32 Feature::CorrectChar(wchar32 c, const char* controls)
  195|      0|{
  196|      0|	bool ctrl = (strchr(controls, c & 0xFF) != 0);
  197|      0|	if ((c & ControlMask) == Control && ctrl)
  198|      0|		return c & ~ControlMask;
  199|      0|	if (c <= 0xFF && ctrl)
  200|      0|		return c | Control;
  201|      0|	return c;
  202|      0|}
  203|       |
  204|       |namespace {
  205|       |	class EnableUnicodeSequencesImpl : public UnicodeReader {
  206|       |	public:
  207|  2.00M|		bool Accepts(wchar32 c) const {
  208|  2.00M|			return c == (Control | 'x');
  209|  2.00M|		}
  210|       |
  211|      0|		Term Lex() {
  212|      0|			return Term::Character(ReadUnicodeCharacter());
  213|      0|		}
  214|       |	};
  215|       |
  216|       |	class CharacterRangeReader: public UnicodeReader {
  217|       |	public:
  218|  2.00M|		bool Accepts(wchar32 c) const { return c == '[' || c == (Control | '[') || c == (Control | ']'); }
  219|       |
  220|       |		Term Lex()
  221|      0|		{
  222|      0|			static const char* controls = "^[]-\\";
  223|      0|			static const char* controls2 = "*+{}()$?.&~";
  224|      0|			wchar32 ch = CorrectChar(GetChar(), controls);
  225|      0|			if (ch == '[' || ch == ']')
  226|      0|				return Term::Character(ch);
  227|       |
  228|      0|			Term::CharacterRange cs;
  229|      0|			ch = CorrectChar(GetChar(), controls);
  230|      0|			if (ch == (Control | '^')) {
  231|      0|				cs.second = true;
  232|      0|				ch = CorrectChar(GetChar(), controls);
  233|      0|			}
  234|       |
  235|      0|			bool firstUnicode;
  236|      0|			wchar32 unicodeSymbol = 0;
  237|       |
  238|      0|			for (; ch != End && ch != (Control | ']'); ch = CorrectChar(GetChar(), controls)) {
  239|      0|				if (ch == (Control | 'x')) {
  240|      0|					UngetChar(ch);
  241|      0|					firstUnicode = true;
  242|      0|					unicodeSymbol = ReadUnicodeCharacter();
  243|      0|				} else {
  244|      0|					firstUnicode = false;
  245|      0|				}
  246|       |
  247|      0|				if (((ch & ControlMask) != Control || firstUnicode) && CorrectChar(PeekChar(), controls) == (Control | '-')) {
  248|      0|					GetChar();
  249|      0|					wchar32 current = GetChar();
  250|       |
  251|      0|					bool secondUnicode = (current == (Control | 'x'));
  252|       |
  253|      0|					wchar32 begin = (firstUnicode) ? unicodeSymbol : ch;
  254|      0|					wchar32 end;
  255|      0|					if (secondUnicode) {
  256|      0|						UngetChar(current);
  257|      0|						end = ReadUnicodeCharacter();
  258|      0|					} else {
  259|      0|						end = CorrectChar(current, controls);
  260|      0|						if ((end & ControlMask) == Control)
  261|      0|							Error("Wrong character range");
  262|      0|					}
  263|       |
  264|      0|					for (ch = begin; ch <= end; ++ch) {
  265|      0|						cs.first.insert(Term::String(1, ch));
  266|      0|					}
  267|      0|				} else if (ch == (Control | '-')) {
  268|      0|					cs.first.insert(Term::String(1, '-'));
  269|      0|				}
  270|      0|				else if ((ch & ControlMask) == Control && (strchr(controls2, ch & ~ControlMask) || strchr(controls, ch & ~ControlMask))) {
  271|      0|					cs.first.insert(Term::String(1, ch & ~ControlMask));
  272|      0|				}
  273|      0|				else if ((ch & ControlMask) != Control || !strchr(controls, ch & ~ControlMask)) {
  274|      0|					cs.first.insert(Term::String(1, (firstUnicode) ? unicodeSymbol : ch));
  275|      0|				} else {
  276|      0|					Error("Wrong character in range");
  277|      0|				}
  278|      0|			}
  279|      0|			if (ch == End)
  280|      0|				Error("Unexpected end of pattern");
  281|       |
  282|      0|			return Term(TokenTypes::Letters, cs);
  283|      0|		}
  284|       |	};
  285|       |
  286|       |	class RepetitionCountReader: public Feature {
  287|       |	public:
  288|  2.00M|		bool Accepts(wchar32 c) const { return c == '{' || c == (Control | '{') || c == (Control | '}'); }
  289|       |
  290|       |		Term Lex()
  291|      0|		{
  292|      0|			wchar32 ch = GetChar();
  293|      0|			if (ch == (Control | '{') || ch == (Control | '}'))
  294|      0|				return Term::Character(ch & ~ControlMask);
  295|      0|			ch = GetChar();
  296|      0|			int lower = 0, upper = 0;
  297|       |
  298|      0|			if (!is_digit(ch))
  299|      0|				Error("Wrong repetition count");
  300|       |
  301|      0|			for (; is_digit(ch); ch = GetChar())
  302|      0|				lower = lower * 10 + (ch - '0');
  303|      0|			if (ch == '}')
  304|      0|				return Term::Repetition(lower, lower);
  305|      0|			else if (ch != ',')
  306|      0|				Error("Wrong repetition count");
  307|       |
  308|      0|			ch = GetChar();
  309|      0|			if (ch == '}')
  310|      0|				return Term::Repetition(lower, Inf);
  311|      0|			else if (!is_digit(ch))
  312|      0|				Error("Wrong repetition count");
  313|      0|			for (; is_digit(ch); ch = GetChar())
  314|      0|				upper = upper * 10 + (ch - '0');
  315|       |
  316|      0|			if (ch != '}')
  317|      0|				Error("Wrong repetition count");
  318|      0|			return Term::Repetition(lower, upper);
  319|      0|		}
  320|       |	};
  321|       |
  322|       |	class CaseInsensitiveImpl: public Feature {
  323|       |	public:
  324|       |		void Alter(Term& t)
  325|      0|		{
  326|      0|			if (t.Value().IsA<Term::CharacterRange>()) {
  327|      0|				typedef Term::CharacterRange::first_type CharSet;
  328|      0|				const CharSet& old = t.Value().As<Term::CharacterRange>().first;
  329|      0|				CharSet altered;
  330|      0|				for (auto&& i : old) {
  331|      0|					if (i.size() == 1) {
  332|      0|						altered.insert(Term::String(1, to_upper(i[0])));
  333|      0|						altered.insert(Term::String(1, to_lower(i[0])));
  334|      0|					} else
  335|      0|						altered.insert(i);
  336|      0|				}
  337|      0|				t = Term(t.Type(), Term::CharacterRange(altered, t.Value().As<Term::CharacterRange>().second));
  338|      0|			}
  339|      0|		}
  340|       |	};
  341|       |	class AndNotSupportImpl: public Feature {
  342|       |	public:
  343|       |		bool Accepts(wchar32 c) const
  344|      0|		{
  345|      0|			return c == '&' || c == '~' || c == (Control | '&') || c == (Control | '~');
  346|      0|		}
  347|       |		
  348|       |		Term Lex()
  349|      0|		{
  350|      0|			wchar32 ch = GetChar();
  351|      0|			if (ch == (Control | '&') || ch == (Control | '~'))
  352|      0|				return Term::Character(ch & ~ControlMask);
  353|      0|			else if (ch == '&')
  354|      0|				return Term(TokenTypes::And);
  355|      0|			else if (ch == '~')
  356|      0|				return Term(TokenTypes::Not);
  357|      0|			else {
  358|      0|				Error("Pire::AndNotSupport::Lex(): strange input character");
  359|      0|				return Term(0); // Make compiler happy
  360|      0|			}
  361|      0|		}
  362|       |	};
  363|       |}
  364|       |
  365|       |namespace Features {
  366|      0|	Feature::Ptr CaseInsensitive() { return Feature::Ptr(new CaseInsensitiveImpl); }
  367|       |	Feature::Ptr CharClasses();
  368|      0|	Feature::Ptr AndNotSupport() { return Feature::Ptr(new AndNotSupportImpl); }
  369|       |};
  370|       |
  371|       |void Lexer::InstallDefaultFeatures()
  372|   100k|{
  373|   100k|	AddFeature(Feature::Ptr(new CharacterRangeReader));
  374|   100k|	AddFeature(Feature::Ptr(new RepetitionCountReader));
  375|   100k|	AddFeature(Features::CharClasses());
  376|   100k|	AddFeature(Feature::Ptr(new EnableUnicodeSequencesImpl));
  377|   100k|}
  378|       |
  379|       |Fsm Lexer::Parse()
  380|   100k|{
  381|   100k|	if (!Impl::yre_parse(*this))
  382|   100k|		return m_retval.As<Fsm>();
  383|      0|	else {
  384|      0|		Error("Syntax error in regexp");
  385|      0|		return Fsm(); // Make compiler happy
  386|      0|	}
  387|   100k|}
  388|       |
  389|       |}

/home/johnpaul/pire/pire/re_lexer.h:
    1|       |/*
    2|       | * re_lexer.h -- definition required for parsing regexps
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#ifndef PIRE_RE_LEXER_H
   25|       |#define PIRE_RE_LEXER_H
   26|       |
   27|       |
   28|       |#include "encoding.h"
   29|       |#include "any.h"
   30|       |#include "stub/defaults.h"
   31|       |#include "stub/stl.h"
   32|       |#include <vector>
   33|       |#include <stack>
   34|       |#include <set>
   35|       |#include <utility>
   36|       |#include <stdexcept>
   37|       |#include <utility>
   38|       |#include <string.h>
   39|       |
   40|       |namespace Pire {
   41|       |
   42|       |namespace Consts {
   43|       |enum { Inf = -1 };
   44|       |
   45|       |static const wchar32 Control     = 0xF000;
   46|       |static const wchar32 ControlMask = 0xFF00;
   47|       |static const wchar32 End         = Control | 0xFF;
   48|       |};
   49|       |
   50|       |using namespace Consts;
   51|       |
   52|       |namespace TokenTypes {
   53|       |enum {
   54|       |	None = 0,
   55|       |	Letters,
   56|       |	Count,
   57|       |	Dot,
   58|       |	Open,
   59|       |	Close,
   60|       |	Or,
   61|       |	And,
   62|       |	Not,
   63|       |	BeginMark,
   64|       |	EndMark,
   65|       |	End
   66|       |};
   67|       |}
   68|       |
   69|       |/**
   70|       |* A single terminal character in regexp pattern.
   71|       |* Consists of a type (a character, a repetition count, an opening parenthesis, etc...)
   72|       |* and optional value.
   73|       |*/
   74|       |class Term {
   75|       |public:
   76|       |	typedef TVector<wchar32> String;
   77|       |	typedef TSet<String> Strings;
   78|       |
   79|       |	typedef ypair<int, int> RepetitionCount;
   80|       |	typedef ypair<Strings, bool> CharacterRange;
   81|       |
   82|       |	struct DotTag {};
   83|       |	struct BeginTag {};
   84|       |	struct EndTag {};
   85|       |
   86|   300k|	Term(int type): m_type(type) {}
   87|  3.50M|	template<class T> Term(int type, T t): m_type(type), m_value(t) {}
  ------------------
  | _ZN4Pire4TermC2INS_5ypairINS_4TSetINS_7TVectorIjSaIjEEESt4lessIS6_ESaIS6_EEEbEEEEiT_:
  |   87|  3.40M|	template<class T> Term(int type, T t): m_type(type), m_value(t) {}
  ------------------
  | Unexecuted instantiation: _ZN4Pire4TermC2INS_5ypairIiiEEEEiT_
  ------------------
  | _ZN4Pire4TermC2INS0_6DotTagEEEiT_:
  |   87|   100k|	template<class T> Term(int type, T t): m_type(type), m_value(t) {}
  ------------------
  | Unexecuted instantiation: _ZN4Pire4TermC2INS0_8BeginTagEEEiT_
  ------------------
  | Unexecuted instantiation: _ZN4Pire4TermC2INS0_6EndTagEEEiT_
  ------------------
   88|  2.10M|	Term(int type, const Any& value): m_type(type), m_value(value) {}
   89|       |
   90|       |	static Term Character(wchar32 c);
   91|       |	static Term Repetition(int lower, int upper);
   92|       |	static Term Dot();
   93|       |	static Term BeginMark();
   94|       |	static Term EndMark();
   95|       |
   96|  5.90M|	int Type() const  { return m_type; }
   97|  13.6M|	const Any& Value() const { return m_value; }
   98|       |private:
   99|       |	int m_type;
  100|       |	Any m_value;
  101|       |};
  102|       |
  103|       |class Feature;
  104|       |
  105|       |/**
  106|       |* A class performing regexp pattern parsing.
  107|       |*/
  108|       |class Lexer {
  109|       |public:
  110|       |	// One-size-fits-all constructor set.
  111|       |	Lexer()
  112|       |		: m_encoding(&Encodings::Latin1())
  113|      0|	{ InstallDefaultFeatures(); }
  114|       |
  115|       |	explicit Lexer(const char* str)
  116|       |		: m_encoding(&Encodings::Latin1())
  117|      0|	{
  118|      0|		InstallDefaultFeatures();
  119|      0|		Assign(str, str + strlen(str));
  120|      0|	}
  121|       |	template<class T> explicit Lexer(const T& t)
  122|       |		: m_encoding(&Encodings::Latin1())
  123|       |	{
  124|       |		InstallDefaultFeatures();
  125|       |		Assign(t.begin(), t.end());
  126|       |	}
  127|       |
  128|       |	template<class Iter> Lexer(Iter begin, Iter end)
  129|       |		: m_encoding(&Encodings::Latin1())
  130|   100k|	{
  131|   100k|		InstallDefaultFeatures();
  132|   100k|		Assign(begin, end);
  133|   100k|	}
  134|       |	~Lexer();
  135|       |
  136|       |	template<class Iter> void Assign(Iter begin, Iter end)
  137|   100k|	{
  138|   100k|		m_input.clear();
  139|   100k|		std::copy(begin, end, std::back_inserter(m_input));
  140|   100k|	}
  ------------------
  | _ZN4Pire5Lexer6AssignIN9__gnu_cxx17__normal_iteratorIPjSt6vectorIjSaIjEEEEEEvT_S9_:
  |  137|   100k|	{
  |  138|   100k|		m_input.clear();
  |  139|   100k|		std::copy(begin, end, std::back_inserter(m_input));
  |  140|   100k|	}
  ------------------
  | Unexecuted instantiation: _ZN4Pire5Lexer6AssignIPKcEEvT_S4_
  ------------------
  141|       |
  142|       |	/// The main lexer function. Extracts and returns the next term in input sequence.
  143|       |	Term Lex();
  144|       |	/// Installs an additional lexer feature.
  145|       |	/// We declare both lvalue and rvalue reference types to fix some linker errors.
  146|       |	Lexer& AddFeature(std::unique_ptr<Feature>& a);
  147|       |	Lexer& AddFeature(std::unique_ptr<Feature>&& a);
  148|       |
  149|  3.90M|	const Pire::Encoding& Encoding() const { return *m_encoding; }
  150|   100k|	Lexer& SetEncoding(const Pire::Encoding& encoding) { m_encoding = &encoding; return *this; }
  151|      0|	void SetErrMsg(const char* msg) { m_errmsg = msg; }
  152|      0|	void SetErrMsg(ystring msg) { m_errmsg = msg; }
  153|   100k|	ystring& ErrMsg() { return m_errmsg; }
  154|       |
  155|   100k|	Any& Retval() { return m_retval; }
  156|       |
  157|       |	Fsm Parse();
  158|       |
  159|       |	void Parenthesized(Fsm& fsm);
  160|       |
  161|       |private:
  162|       |	Term DoLex();
  163|       |
  164|       |	wchar32 GetChar();
  165|       |	wchar32 PeekChar();
  166|       |	void UngetChar(wchar32 c);
  167|       |
  168|      0|	void Error(const char* msg) { throw Pire::Error(msg); }
  169|       |
  170|       |	void InstallDefaultFeatures();
  171|       |
  172|       |	TDeque<wchar32> m_input;
  173|       |	const Pire::Encoding* m_encoding;
  174|       |	TVector<std::unique_ptr<Feature>> m_features;
  175|       |	Any m_retval;
  176|       |	ystring m_errmsg;
  177|       |
  178|       |	friend class Feature;
  179|       |
  180|       |	Lexer(const Lexer&);
  181|       |	Lexer& operator = (const Lexer&);
  182|       |};
  183|       |
  184|       |/**
  185|       |* A basic class for Pire customization.
  186|       |* Features can be installed in the lexer and alter its behaviour.
  187|       |*/
  188|       |class Feature {
  189|       |public:
  190|       |	/// Precedence of features. The less the priority, the earlier
  191|       |	/// will Lex() be called, and the later will Alter() and Parenthesized() be called.
  192|   700k|	virtual int Priority() const { return 50; }
  193|       |
  194|       |	/// Lexer will call this function to check whether the feature
  195|       |	/// wants to handle the next part of the input sequence in its
  196|       |	/// specific way. If it does not, features Lex() will not be called.
  197|  2.00M|	virtual bool Accepts(wchar32 /*c*/) const { return false; }
  198|       |	/// Should eat up some part of the input sequence, handle it
  199|       |	/// somehow and produce a terminal.
  200|      0|	virtual Term Lex() { return Term(0); }
  201|       |
  202|       |	/// This function recieves a shiny new terminal, and the feature
  203|       |	/// has a chance to hack it somehow if it wants.
  204|  6.30M|	virtual void Alter(Term&) {}
  205|       |	/// This function recieves a parenthesized part of a pattern, and the feature
  206|       |	/// has a chance to hack it somehow if it wants (its the way to implement
  207|       |	/// those perl-style (?@#$%:..) clauses).
  208|   400k|	virtual void Parenthesized(Fsm&) {}
  209|       |
  210|       |	using Ptr = std::unique_ptr<Feature>;
  211|       |
  212|   400k|	virtual ~Feature() = default;
  213|       |
  214|       |protected:
  215|       |
  216|       |	// These functions are exposed versions of the corresponding lexer functions.
  217|      0|	const Pire::Encoding& Encoding() const { return m_lexer->Encoding(); }
  218|      0|	wchar32 GetChar() { return m_lexer->GetChar(); }
  219|      0|	wchar32 PeekChar() { return m_lexer->PeekChar(); }
  220|      0|	void UngetChar(wchar32 c) { m_lexer->UngetChar(c); }
  221|       |	wchar32 CorrectChar(wchar32 c, const char* controls);
  222|      0|	void Error(const char* msg) { m_lexer->Error(msg); }
  223|       |
  224|       |private:
  225|       |	friend class Lexer;
  226|       |	Lexer* m_lexer;
  227|       |};
  228|       |
  229|       |namespace Features {
  230|       |	/// Disables case sensitivity
  231|       |	Feature::Ptr CaseInsensitive();
  232|       |
  233|       |	/**
  234|       |	* Adds two more operations:
  235|       |	*  (pattern1)&(pattern2) -- matches those strings which match both /pattern1/ and /pattern2/;
  236|       |	*  ~(pattern)            -- matches those strings which do not match /pattern/.
  237|       |	*/
  238|       |	Feature::Ptr AndNotSupport();
  239|       |}
  240|       |
  241|       |}
  242|       |
  243|       |#endif

/home/johnpaul/pire/pire/re_parser.cpp:
    1|       |/* A Bison parser, made by GNU Bison 3.8.2.  */
    2|       |
    3|       |/* Bison implementation for Yacc-like parsers in C
    4|       |
    5|       |   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
    6|       |   Inc.
    7|       |
    8|       |   This program is free software: you can redistribute it and/or modify
    9|       |   it under the terms of the GNU General Public License as published by
   10|       |   the Free Software Foundation, either version 3 of the License, or
   11|       |   (at your option) any later version.
   12|       |
   13|       |   This program is distributed in the hope that it will be useful,
   14|       |   but WITHOUT ANY WARRANTY; without even the implied warranty of
   15|       |   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   16|       |   GNU General Public License for more details.
   17|       |
   18|       |   You should have received a copy of the GNU General Public License
   19|       |   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
   20|       |
   21|       |/* As a special exception, you may create a larger work that contains
   22|       |   part or all of the Bison parser skeleton and distribute that work
   23|       |   under terms of your choice, so long as that work isn't itself a
   24|       |   parser generator using the skeleton or a modified version thereof
   25|       |   as a parser skeleton.  Alternatively, if you modify or redistribute
   26|       |   the parser skeleton itself, you may (at your option) remove this
   27|       |   special exception, which will cause the skeleton and the resulting
   28|       |   Bison output files to be licensed under the GNU General Public
   29|       |   License without this special exception.
   30|       |
   31|       |   This special exception was added by the Free Software Foundation in
   32|       |   version 2.2 of Bison.  */
   33|       |
   34|       |/* C LALR(1) parser skeleton written by Richard Stallman, by
   35|       |   simplifying the original so-called "semantic" parser.  */
   36|       |
   37|       |/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
   38|       |   especially those whose name start with YY_ or yy_.  They are
   39|       |   private implementation details that can be changed or removed.  */
   40|       |
   41|       |/* All symbols defined below should begin with yy or YY, to avoid
   42|       |   infringing on user name space.  This should be done even for local
   43|       |   variables, as they might otherwise be expanded by user macros.
   44|       |   There are some unavoidable exceptions within include files to
   45|       |   define necessary library symbols; they are noted "INFRINGES ON
   46|       |   USER NAME SPACE" below.  */
   47|       |
   48|       |/* Identify Bison output, and Bison version.  */
   49|       |#define YYBISON 30802
   50|       |
   51|       |/* Bison version string.  */
   52|       |#define YYBISON_VERSION "3.8.2"
   53|       |
   54|       |/* Skeleton name.  */
   55|       |#define YYSKELETON_NAME "yacc.c"
   56|       |
   57|       |/* Pure parsers.  */
   58|       |#define YYPURE 1
   59|       |
   60|       |/* Push parsers.  */
   61|       |#define YYPUSH 0
   62|       |
   63|       |/* Pull parsers.  */
   64|       |#define YYPULL 1
   65|       |
   66|       |
   67|       |
   68|       |
   69|       |/* First part of user prologue.  */
   70|       |#line 1 "re_parser.y"
   71|       | // -*- mode: c++ -*-
   72|       |
   73|       |/*
   74|       | * re_parser.ypp -- the main regexp parsing routine
   75|       | *
   76|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
   77|       | *                          Alexander Gololobov <agololobov@gmail.com>
   78|       | *
   79|       | * This file is part of Pire, the Perl Incompatible
   80|       | * Regular Expressions library.
   81|       | *
   82|       | * Pire is free software: you can redistribute it and/or modify
   83|       | * it under the terms of the GNU Lesser Public License as published by
   84|       | * the Free Software Foundation, either version 3 of the License, or
   85|       | * (at your option) any later version.
   86|       | * 
   87|       | * Pire is distributed in the hope that it will be useful,
   88|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   89|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   90|       | * GNU Lesser Public License for more details.
   91|       | * You should have received a copy of the GNU Lesser Public License
   92|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   93|       | */
   94|       |
   95|       |
   96|       |#ifdef _MSC_VER
   97|       |// Disable yacc warnings
   98|       |#pragma warning(disable: 4060) // switch contains no 'case' or 'default' statements
   99|       |#pragma warning(disable: 4065) // switch contains 'default' but no 'case' statements
  100|       |#pragma warning(disable: 4102) // unreferenced label 'yyerrlabl'
  101|       |#endif
  102|       |
  103|       |#ifdef __GNUC__
  104|       |#pragma GCC diagnostic ignored "-Wuninitialized" // 'yylval' may be used uninitialized
  105|       |#endif
  106|       |
  107|       |#include <stdexcept>
  108|       |
  109|       |#include "fsm.h"
  110|       |#include "re_lexer.h"
  111|       |#include "any.h"
  112|       |#include "stub/stl.h"
  113|       |
  114|   500k|#define YYSTYPE Any*
  115|       |#define YYSTYPE_IS_TRIVIAL 0
  116|       |
  117|       |namespace {
  118|       |
  119|       |using namespace Pire;
  120|       |using Pire::Fsm;
  121|       |using Pire::Encoding;
  122|       |
  123|       |int  yylex(YYSTYPE*, Lexer&);
  124|       |void yyerror(const char*);
  125|       |void yyerror(Pire::Lexer&, const char*);
  126|       |
  127|       |Fsm& ConvertToFSM(const Encoding& encoding, Any* any);
  128|       |void AppendRange(const Encoding& encoding, Fsm& a, const Term::CharacterRange& cr);
  129|       |
  130|       |#ifdef YYBYACC
  131|       |#define YYPARSE_PARAM ,Pire::Lexer& rlex /* Yes, the leading comma is really needed here */
  132|       |#define YYLEX_PARAM rlex
  133|       |#endif
  134|       |
  135|       |
  136|       |#line 137 "re_parser.tab.c"
  137|       |
  138|       |# ifndef YY_CAST
  139|       |#  ifdef __cplusplus
  140|  13.2M|#   define YY_CAST(Type, Val) static_cast<Type> (Val)
  141|       |#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
  142|       |#  else
  143|       |#   define YY_CAST(Type, Val) ((Type) (Val))
  144|       |#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
  145|       |#  endif
  146|       |# endif
  147|       |# ifndef YY_NULLPTR
  148|       |#  if defined __cplusplus
  149|       |#   if 201103L <= __cplusplus
  150|       |#    define YY_NULLPTR nullptr
  151|       |#   else
  152|       |#    define YY_NULLPTR 0
  153|       |#   endif
  154|       |#  else
  155|       |#   define YY_NULLPTR ((void*)0)
  156|       |#  endif
  157|       |# endif
  158|       |
  159|       |#include "re_parser.h"
  160|       |/* Symbol kind.  */
  161|       |enum yysymbol_kind_t
  162|       |{
  163|       |  YYSYMBOL_YYEMPTY = -2,
  164|       |  YYSYMBOL_YYEOF = 0,                      /* "end of file"  */
  165|       |  YYSYMBOL_YYerror = 1,                    /* error  */
  166|       |  YYSYMBOL_YYUNDEF = 2,                    /* "invalid token"  */
  167|       |  YYSYMBOL_YRE_LETTERS = 3,                /* YRE_LETTERS  */
  168|       |  YYSYMBOL_YRE_COUNT = 4,                  /* YRE_COUNT  */
  169|       |  YYSYMBOL_YRE_DOT = 5,                    /* YRE_DOT  */
  170|       |  YYSYMBOL_YRE_AND = 6,                    /* YRE_AND  */
  171|       |  YYSYMBOL_YRE_NOT = 7,                    /* YRE_NOT  */
  172|       |  YYSYMBOL_8_ = 8,                         /* '|'  */
  173|       |  YYSYMBOL_9_ = 9,                         /* '^'  */
  174|       |  YYSYMBOL_10_ = 10,                       /* '$'  */
  175|       |  YYSYMBOL_11_ = 11,                       /* '('  */
  176|       |  YYSYMBOL_12_ = 12,                       /* ')'  */
  177|       |  YYSYMBOL_YYACCEPT = 13,                  /* $accept  */
  178|       |  YYSYMBOL_regexp = 14,                    /* regexp  */
  179|       |  YYSYMBOL_alternative = 15,               /* alternative  */
  180|       |  YYSYMBOL_conjunction = 16,               /* conjunction  */
  181|       |  YYSYMBOL_negation = 17,                  /* negation  */
  182|       |  YYSYMBOL_concatenation = 18,             /* concatenation  */
  183|       |  YYSYMBOL_iteration = 19,                 /* iteration  */
  184|       |  YYSYMBOL_term = 20                       /* term  */
  185|       |};
  186|       |typedef enum yysymbol_kind_t yysymbol_kind_t;
  187|       |
  188|       |
  189|       |
  190|       |
  191|       |#ifdef short
  192|       |# undef short
  193|       |#endif
  194|       |
  195|       |/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
  196|       |   <limits.h> and (if available) <stdint.h> are included
  197|       |   so that the code can choose integer types of a good width.  */
  198|       |
  199|       |#ifndef __PTRDIFF_MAX__
  200|       |# include <limits.h> /* INFRINGES ON USER NAME SPACE */
  201|       |# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
  202|       |#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
  203|       |#  define YY_STDINT_H
  204|       |# endif
  205|       |#endif
  206|       |
  207|       |/* Narrow types that promote to a signed type and that can represent a
  208|       |   signed or unsigned integer of at least N bits.  In tables they can
  209|       |   save space and decrease cache pressure.  Promoting to a signed type
  210|       |   helps avoid bugs in integer arithmetic.  */
  211|       |
  212|       |#ifdef __INT_LEAST8_MAX__
  213|       |typedef __INT_LEAST8_TYPE__ yytype_int8;
  214|       |#elif defined YY_STDINT_H
  215|       |typedef int_least8_t yytype_int8;
  216|       |#else
  217|       |typedef signed char yytype_int8;
  218|       |#endif
  219|       |
  220|       |#ifdef __INT_LEAST16_MAX__
  221|       |typedef __INT_LEAST16_TYPE__ yytype_int16;
  222|       |#elif defined YY_STDINT_H
  223|       |typedef int_least16_t yytype_int16;
  224|       |#else
  225|       |typedef short yytype_int16;
  226|       |#endif
  227|       |
  228|       |/* Work around bug in HP-UX 11.23, which defines these macros
  229|       |   incorrectly for preprocessor constants.  This workaround can likely
  230|       |   be removed in 2023, as HPE has promised support for HP-UX 11.23
  231|       |   (aka HP-UX 11i v2) only through the end of 2022; see Table 2 of
  232|       |   <https://h20195.www2.hpe.com/V2/getpdf.aspx/4AA4-7673ENW.pdf>.  */
  233|       |#ifdef __hpux
  234|       |# undef UINT_LEAST8_MAX
  235|       |# undef UINT_LEAST16_MAX
  236|       |# define UINT_LEAST8_MAX 255
  237|       |# define UINT_LEAST16_MAX 65535
  238|       |#endif
  239|       |
  240|       |#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
  241|       |typedef __UINT_LEAST8_TYPE__ yytype_uint8;
  242|       |#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
  243|       |       && UINT_LEAST8_MAX <= INT_MAX)
  244|       |typedef uint_least8_t yytype_uint8;
  245|       |#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
  246|       |typedef unsigned char yytype_uint8;
  247|       |#else
  248|       |typedef short yytype_uint8;
  249|       |#endif
  250|       |
  251|       |#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
  252|       |typedef __UINT_LEAST16_TYPE__ yytype_uint16;
  253|       |#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
  254|       |       && UINT_LEAST16_MAX <= INT_MAX)
  255|       |typedef uint_least16_t yytype_uint16;
  256|       |#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
  257|       |typedef unsigned short yytype_uint16;
  258|       |#else
  259|       |typedef int yytype_uint16;
  260|       |#endif
  261|       |
  262|       |#ifndef YYPTRDIFF_T
  263|       |# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
  264|   100k|#  define YYPTRDIFF_T __PTRDIFF_TYPE__
  265|       |#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
  266|       |# elif defined PTRDIFF_MAX
  267|       |#  ifndef ptrdiff_t
  268|       |#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
  269|       |#  endif
  270|       |#  define YYPTRDIFF_T ptrdiff_t
  271|       |#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
  272|       |# else
  273|       |#  define YYPTRDIFF_T long
  274|       |#  define YYPTRDIFF_MAXIMUM LONG_MAX
  275|       |# endif
  276|       |#endif
  277|       |
  278|       |#ifndef YYSIZE_T
  279|       |# ifdef __SIZE_TYPE__
  280|       |#  define YYSIZE_T __SIZE_TYPE__
  281|       |# elif defined size_t
  282|       |#  define YYSIZE_T size_t
  283|       |# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
  284|       |#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
  285|       |#  define YYSIZE_T size_t
  286|       |# else
  287|       |#  define YYSIZE_T unsigned
  288|       |# endif
  289|       |#endif
  290|       |
  291|       |#define YYSIZE_MAXIMUM                                  \
  292|       |  YY_CAST (YYPTRDIFF_T,                                 \
  293|       |           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
  294|       |            ? YYPTRDIFF_MAXIMUM                         \
  295|       |            : YY_CAST (YYSIZE_T, -1)))
  296|       |
  297|       |#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))
  298|       |
  299|       |
  300|       |/* Stored state numbers (used for stacks). */
  301|       |typedef yytype_int8 yy_state_t;
  302|       |
  303|       |/* State numbers in computations.  */
  304|       |typedef int yy_state_fast_t;
  305|       |
  306|       |#ifndef YY_
  307|       |# if defined YYENABLE_NLS && YYENABLE_NLS
  308|       |#  if ENABLE_NLS
  309|       |#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
  310|       |#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
  311|       |#  endif
  312|       |# endif
  313|       |# ifndef YY_
  314|      0|#  define YY_(Msgid) Msgid
  315|       |# endif
  316|       |#endif
  317|       |
  318|       |
  319|       |#ifndef YY_ATTRIBUTE_PURE
  320|       |# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
  321|       |#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
  322|       |# else
  323|       |#  define YY_ATTRIBUTE_PURE
  324|       |# endif
  325|       |#endif
  326|       |
  327|       |#ifndef YY_ATTRIBUTE_UNUSED
  328|       |# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
  329|       |#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
  330|       |# else
  331|       |#  define YY_ATTRIBUTE_UNUSED
  332|       |# endif
  333|       |#endif
  334|       |
  335|       |/* Suppress unused-variable warnings by "using" E.  */
  336|       |#if ! defined lint || defined __GNUC__
  337|   400k|# define YY_USE(E) ((void) (E))
  338|       |#else
  339|       |# define YY_USE(E) /* empty */
  340|       |#endif
  341|       |
  342|       |/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
  343|       |#if defined __GNUC__ && ! defined __ICC && 406 <= __GNUC__ * 100 + __GNUC_MINOR__
  344|       |# if __GNUC__ * 100 + __GNUC_MINOR__ < 407
  345|       |#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
  346|       |    _Pragma ("GCC diagnostic push")                                     \
  347|       |    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")
  348|       |# else
  349|       |#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
  350|       |    _Pragma ("GCC diagnostic push")                                     \
  351|       |    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
  352|       |    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
  353|       |# endif
  354|       |# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
  355|       |    _Pragma ("GCC diagnostic pop")
  356|       |#else
  357|   200k|# define YY_INITIAL_VALUE(Value) Value
  358|       |#endif
  359|       |#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  360|       |# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  361|       |# define YY_IGNORE_MAYBE_UNINITIALIZED_END
  362|       |#endif
  363|       |#ifndef YY_INITIAL_VALUE
  364|       |# define YY_INITIAL_VALUE(Value) /* Nothing. */
  365|       |#endif
  366|       |
  367|       |#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
  368|       |# define YY_IGNORE_USELESS_CAST_BEGIN                          \
  369|       |    _Pragma ("GCC diagnostic push")                            \
  370|       |    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
  371|       |# define YY_IGNORE_USELESS_CAST_END            \
  372|       |    _Pragma ("GCC diagnostic pop")
  373|       |#endif
  374|       |#ifndef YY_IGNORE_USELESS_CAST_BEGIN
  375|       |# define YY_IGNORE_USELESS_CAST_BEGIN
  376|       |# define YY_IGNORE_USELESS_CAST_END
  377|       |#endif
  378|       |
  379|       |
  380|  8.80M|#define YY_ASSERT(E) ((void) (0 && (E)))
  381|       |
  382|       |#if !defined yyoverflow
  383|       |
  384|       |/* The parser invokes alloca or malloc; define the necessary symbols.  */
  385|       |
  386|       |# ifdef YYSTACK_USE_ALLOCA
  387|       |#  if YYSTACK_USE_ALLOCA
  388|       |#   ifdef __GNUC__
  389|       |#    define YYSTACK_ALLOC __builtin_alloca
  390|       |#   elif defined __BUILTIN_VA_ARG_INCR
  391|       |#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
  392|       |#   elif defined _AIX
  393|       |#    define YYSTACK_ALLOC __alloca
  394|       |#   elif defined _MSC_VER
  395|       |#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
  396|       |#    define alloca _alloca
  397|       |#   else
  398|       |#    define YYSTACK_ALLOC alloca
  399|       |#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
  400|       |#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
  401|       |      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
  402|       |#     ifndef EXIT_SUCCESS
  403|       |#      define EXIT_SUCCESS 0
  404|       |#     endif
  405|       |#    endif
  406|       |#   endif
  407|       |#  endif
  408|       |# endif
  409|       |
  410|       |# ifdef YYSTACK_ALLOC
  411|       |   /* Pacify GCC's 'empty if-body' warning.  */
  412|       |#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
  413|       |#  ifndef YYSTACK_ALLOC_MAXIMUM
  414|       |    /* The OS might guarantee only one guard page at the bottom of the stack,
  415|       |       and a page size can be as small as 4096 bytes.  So we cannot safely
  416|       |       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
  417|       |       to allow for a few compiler-allocated temporary stack slots.  */
  418|       |#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
  419|       |#  endif
  420|       |# else
  421|       |#  define YYSTACK_ALLOC YYMALLOC
  422|      0|#  define YYSTACK_FREE YYFREE
  423|       |#  ifndef YYSTACK_ALLOC_MAXIMUM
  424|       |#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
  425|       |#  endif
  426|       |#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
  427|       |       && ! ((defined YYMALLOC || defined malloc) \
  428|       |             && (defined YYFREE || defined free)))
  429|       |#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
  430|       |#   ifndef EXIT_SUCCESS
  431|       |#    define EXIT_SUCCESS 0
  432|       |#   endif
  433|       |#  endif
  434|       |#  ifndef YYMALLOC
  435|       |#   define YYMALLOC malloc
  436|       |#   if ! defined malloc && ! defined EXIT_SUCCESS
  437|       |void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
  438|       |#   endif
  439|       |#  endif
  440|       |#  ifndef YYFREE
  441|      0|#   define YYFREE free
  442|       |#   if ! defined free && ! defined EXIT_SUCCESS
  443|       |void free (void *); /* INFRINGES ON USER NAME SPACE */
  444|       |#   endif
  445|       |#  endif
  446|       |# endif
  447|       |#endif /* !defined yyoverflow */
  448|       |
  449|       |#if (! defined yyoverflow \
  450|       |     && (! defined __cplusplus \
  451|       |         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
  452|       |
  453|       |/* A type that is properly aligned for any stack member.  */
  454|       |union yyalloc
  455|       |{
  456|       |  yy_state_t yyss_alloc;
  457|       |  YYSTYPE yyvs_alloc;
  458|       |};
  459|       |
  460|       |/* The size of the maximum gap between one aligned stack and the next.  */
  461|       |# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)
  462|       |
  463|       |/* The size of an array large to enough to hold all stacks, each with
  464|       |   N elements.  */
  465|       |# define YYSTACK_BYTES(N) \
  466|       |     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \
  467|       |      + YYSTACK_GAP_MAXIMUM)
  468|       |
  469|       |# define YYCOPY_NEEDED 1
  470|       |
  471|       |/* Relocate STACK from its old location to the new one.  The
  472|       |   local variables YYSIZE and YYSTACKSIZE give the old and new number of
  473|       |   elements in the stack, and YYPTR gives the new location of the
  474|       |   stack.  Advance YYPTR to a properly aligned location for the next
  475|       |   stack.  */
  476|       |# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
  477|       |    do                                                                  \
  478|       |      {                                                                 \
  479|       |        YYPTRDIFF_T yynewbytes;                                         \
  480|       |        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
  481|       |        Stack = &yyptr->Stack_alloc;                                    \
  482|       |        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
  483|       |        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
  484|       |      }                                                                 \
  485|       |    while (0)
  486|       |
  487|       |#endif
  488|       |
  489|       |#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
  490|       |/* Copy COUNT objects from SRC to DST.  The source and destination do
  491|       |   not overlap.  */
  492|       |# ifndef YYCOPY
  493|       |#  if defined __GNUC__ && 1 < __GNUC__
  494|       |#   define YYCOPY(Dst, Src, Count) \
  495|       |      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
  496|       |#  else
  497|       |#   define YYCOPY(Dst, Src, Count)              \
  498|       |      do                                        \
  499|       |        {                                       \
  500|       |          YYPTRDIFF_T yyi;                      \
  501|       |          for (yyi = 0; yyi < (Count); yyi++)   \
  502|       |            (Dst)[yyi] = (Src)[yyi];            \
  503|       |        }                                       \
  504|       |      while (0)
  505|       |#  endif
  506|       |# endif
  507|       |#endif /* !YYCOPY_NEEDED */
  508|       |
  509|       |/* YYFINAL -- State number of the termination state.  */
  510|  8.80M|#define YYFINAL  8
  511|       |/* YYLAST -- Last index in YYTABLE.  */
  512|  13.6M|#define YYLAST   17
  513|       |
  514|       |/* YYNTOKENS -- Number of terminals.  */
  515|  6.60M|#define YYNTOKENS  13
  516|       |/* YYNNTS -- Number of nonterminals.  */
  517|       |#define YYNNTS  8
  518|       |/* YYNRULES -- Number of rules.  */
  519|       |#define YYNRULES  17
  520|       |/* YYNSTATES -- Number of states.  */
  521|       |#define YYNSTATES  23
  522|       |
  523|       |/* YYMAXUTOK -- Last valid token kind.  */
  524|  4.20M|#define YYMAXUTOK   262
  525|       |
  526|       |
  527|       |/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
  528|       |   as returned by yylex, with out-of-bounds checking.  */
  529|       |#define YYTRANSLATE(YYX)                                \
  530|  4.20M|  (0 <= (YYX) && (YYX) <= YYMAXUTOK                     \
  531|  4.20M|   ? YY_CAST (yysymbol_kind_t, yytranslate[YYX])        \
  532|  4.20M|   : YYSYMBOL_YYUNDEF)
  533|       |
  534|       |/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
  535|       |   as returned by yylex.  */
  536|       |static const yytype_int8 yytranslate[] =
  537|       |{
  538|       |       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  539|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  540|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  541|       |       2,     2,     2,     2,     2,     2,    10,     2,     2,     2,
  542|       |      11,    12,     2,     2,     2,     2,     2,     2,     2,     2,
  543|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  544|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  545|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  546|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  547|       |       2,     2,     2,     2,     9,     2,     2,     2,     2,     2,
  548|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  549|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  550|       |       2,     2,     2,     2,     8,     2,     2,     2,     2,     2,
  551|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  552|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  553|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  554|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  555|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  556|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  557|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  558|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  559|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  560|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  561|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  562|       |       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
  563|       |       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
  564|       |       5,     6,     7
  565|       |};
  566|       |
  567|       |#if YYDEBUG
  568|       |/* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
  569|       |static const yytype_uint8 yyrline[] =
  570|       |{
  571|       |       0,    83,    83,    93,    94,    98,    99,   103,   104,   108,
  572|       |     109,   123,   124,   154,   155,   156,   157,   158
  573|       |};
  574|       |#endif
  575|       |
  576|       |/** Accessing symbol of state STATE.  */
  577|   200k|#define YY_ACCESSING_SYMBOL(State) YY_CAST (yysymbol_kind_t, yystos[State])
  578|       |
  579|       |#if YYDEBUG || 0
  580|       |/* The user-facing name of the symbol whose (internal) number is
  581|       |   YYSYMBOL.  No bounds checking.  */
  582|       |static const char *yysymbol_name (yysymbol_kind_t yysymbol) YY_ATTRIBUTE_UNUSED;
  583|       |
  584|       |/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
  585|       |   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
  586|       |static const char *const yytname[] =
  587|       |{
  588|       |  "\"end of file\"", "error", "\"invalid token\"", "YRE_LETTERS",
  589|       |  "YRE_COUNT", "YRE_DOT", "YRE_AND", "YRE_NOT", "'|'", "'^'", "'$'", "'('",
  590|       |  "')'", "$accept", "regexp", "alternative", "conjunction", "negation",
  591|       |  "concatenation", "iteration", "term", YY_NULLPTR
  592|       |};
  593|       |
  594|       |static const char *
  595|       |yysymbol_name (yysymbol_kind_t yysymbol)
  596|       |{
  597|       |  return yytname[yysymbol];
  598|       |}
  599|       |#endif
  600|       |
  601|  8.70M|#define YYPACT_NINF (-8)
  602|       |
  603|       |#define yypact_value_is_default(Yyn) \
  604|  8.70M|  ((Yyn) == YYPACT_NINF)
  605|       |
  606|       |#define YYTABLE_NINF (-1)
  607|       |
  608|       |#define yytable_value_is_error(Yyn) \
  609|      0|  0
  610|       |
  611|       |/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
  612|       |   STATE-NUM.  */
  613|       |static const yytype_int8 yypact[] =
  614|       |{
  615|       |      -4,    -8,     4,     1,     5,    -8,    -3,    -3,    -8,    -4,
  616|       |      -4,    -8,    -8,    -8,    -8,    -4,    -8,     6,     5,    -8,
  617|       |      -7,    -8,    -8
  618|       |};
  619|       |
  620|       |/* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
  621|       |   Performed when YYTABLE does not specify something else to do.  Zero
  622|       |   means the default is an error.  */
  623|       |static const yytype_int8 yydefact[] =
  624|       |{
  625|       |       9,     9,     0,     2,     3,     5,     7,     8,     1,     9,
  626|       |       9,    13,    14,    15,    16,     9,    10,    11,     4,     6,
  627|       |       0,    12,    17
  628|       |};
  629|       |
  630|       |/* YYPGOTO[NTERM-NUM].  */
  631|       |static const yytype_int8 yypgoto[] =
  632|       |{
  633|       |      -8,    -8,    -2,     3,     7,    13,    -8,    -8
  634|       |};
  635|       |
  636|       |/* YYDEFGOTO[NTERM-NUM].  */
  637|       |static const yytype_int8 yydefgoto[] =
  638|       |{
  639|       |       0,     2,     3,     4,     5,     6,    16,    17
  640|       |};
  641|       |
  642|       |/* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
  643|       |   positive, shift that token.  If negative, reduce the rule whose
  644|       |   number is the opposite.  If YYTABLE_NINF, syntax error.  */
  645|       |static const yytype_int8 yytable[] =
  646|       |{
  647|       |      11,     9,    12,     1,     8,    22,    13,    14,    15,     9,
  648|       |      21,    10,    18,    20,     7,     0,     0,    19
  649|       |};
  650|       |
  651|       |static const yytype_int8 yycheck[] =
  652|       |{
  653|       |       3,     8,     5,     7,     0,    12,     9,    10,    11,     8,
  654|       |       4,     6,     9,    15,     1,    -1,    -1,    10
  655|       |};
  656|       |
  657|       |/* YYSTOS[STATE-NUM] -- The symbol kind of the accessing symbol of
  658|       |   state STATE-NUM.  */
  659|       |static const yytype_int8 yystos[] =
  660|       |{
  661|       |       0,     7,    14,    15,    16,    17,    18,    18,     0,     8,
  662|       |       6,     3,     5,     9,    10,    11,    19,    20,    16,    17,
  663|       |      15,     4,    12
  664|       |};
  665|       |
  666|       |/* YYR1[RULE-NUM] -- Symbol kind of the left-hand side of rule RULE-NUM.  */
  667|       |static const yytype_int8 yyr1[] =
  668|       |{
  669|       |       0,    13,    14,    15,    15,    16,    16,    17,    17,    18,
  670|       |      18,    19,    19,    20,    20,    20,    20,    20
  671|       |};
  672|       |
  673|       |/* YYR2[RULE-NUM] -- Number of symbols on the right-hand side of rule RULE-NUM.  */
  674|       |static const yytype_int8 yyr2[] =
  675|       |{
  676|       |       0,     2,     1,     1,     3,     1,     3,     1,     2,     0,
  677|       |       2,     1,     2,     1,     1,     1,     1,     3
  678|       |};
  679|       |
  680|       |
  681|       |enum { YYENOMEM = -2 };
  682|       |
  683|       |#define yyerrok         (yyerrstatus = 0)
  684|       |#define yyclearin       (yychar = YYEMPTY)
  685|       |
  686|   100k|#define YYACCEPT        goto yyacceptlab
  687|      0|#define YYABORT         goto yyabortlab
  688|      0|#define YYERROR         goto yyerrorlab
  689|      0|#define YYNOMEM         goto yyexhaustedlab
  690|       |
  691|       |
  692|       |#define YYRECOVERING()  (!!yyerrstatus)
  693|       |
  694|       |#define YYBACKUP(Token, Value)                                    \
  695|       |  do                                                              \
  696|       |    if (yychar == YYEMPTY)                                        \
  697|       |      {                                                           \
  698|       |        yychar = (Token);                                         \
  699|       |        yylval = (Value);                                         \
  700|       |        YYPOPSTACK (yylen);                                       \
  701|       |        yystate = *yyssp;                                         \
  702|       |        goto yybackup;                                            \
  703|       |      }                                                           \
  704|       |    else                                                          \
  705|       |      {                                                           \
  706|       |        yyerror (rlex, YY_("syntax error: cannot back up")); \
  707|       |        YYERROR;                                                  \
  708|       |      }                                                           \
  709|       |  while (0)
  710|       |
  711|       |/* Backward compatibility with an undocumented macro.
  712|       |   Use YYerror or YYUNDEF. */
  713|       |#define YYERRCODE YYUNDEF
  714|       |
  715|       |
  716|       |/* Enable debugging if requested.  */
  717|       |#if YYDEBUG
  718|       |
  719|       |# ifndef YYFPRINTF
  720|       |#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
  721|       |#  define YYFPRINTF fprintf
  722|       |# endif
  723|       |
  724|       |# define YYDPRINTF(Args)                        \
  725|       |do {                                            \
  726|       |  if (yydebug)                                  \
  727|       |    YYFPRINTF Args;                             \
  728|       |} while (0)
  729|       |
  730|       |
  731|       |
  732|       |
  733|       |# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)                    \
  734|       |do {                                                                      \
  735|       |  if (yydebug)                                                            \
  736|       |    {                                                                     \
  737|       |      YYFPRINTF (stderr, "%s ", Title);                                   \
  738|       |      yy_symbol_print (stderr,                                            \
  739|       |                  Kind, Value, rlex); \
  740|       |      YYFPRINTF (stderr, "\n");                                           \
  741|       |    }                                                                     \
  742|       |} while (0)
  743|       |
  744|       |
  745|       |/*-----------------------------------.
  746|       || Print this symbol's value on YYO.  |
  747|       |`-----------------------------------*/
  748|       |
  749|       |static void
  750|       |yy_symbol_value_print (FILE *yyo,
  751|       |                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, Pire::Lexer& rlex)
  752|       |{
  753|       |  FILE *yyoutput = yyo;
  754|       |  YY_USE (yyoutput);
  755|       |  YY_USE (rlex);
  756|       |  if (!yyvaluep)
  757|       |    return;
  758|       |  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  759|       |  YY_USE (yykind);
  760|       |  YY_IGNORE_MAYBE_UNINITIALIZED_END
  761|       |}
  762|       |
  763|       |
  764|       |/*---------------------------.
  765|       || Print this symbol on YYO.  |
  766|       |`---------------------------*/
  767|       |
  768|       |static void
  769|       |yy_symbol_print (FILE *yyo,
  770|       |                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, Pire::Lexer& rlex)
  771|       |{
  772|       |  YYFPRINTF (yyo, "%s %s (",
  773|       |             yykind < YYNTOKENS ? "token" : "nterm", yysymbol_name (yykind));
  774|       |
  775|       |  yy_symbol_value_print (yyo, yykind, yyvaluep, rlex);
  776|       |  YYFPRINTF (yyo, ")");
  777|       |}
  778|       |
  779|       |/*------------------------------------------------------------------.
  780|       || yy_stack_print -- Print the state stack from its BOTTOM up to its |
  781|       || TOP (included).                                                   |
  782|       |`------------------------------------------------------------------*/
  783|       |
  784|       |static void
  785|       |yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
  786|       |{
  787|       |  YYFPRINTF (stderr, "Stack now");
  788|       |  for (; yybottom <= yytop; yybottom++)
  789|       |    {
  790|       |      int yybot = *yybottom;
  791|       |      YYFPRINTF (stderr, " %d", yybot);
  792|       |    }
  793|       |  YYFPRINTF (stderr, "\n");
  794|       |}
  795|       |
  796|       |# define YY_STACK_PRINT(Bottom, Top)                            \
  797|       |do {                                                            \
  798|       |  if (yydebug)                                                  \
  799|       |    yy_stack_print ((Bottom), (Top));                           \
  800|       |} while (0)
  801|       |
  802|       |
  803|       |/*------------------------------------------------.
  804|       || Report that the YYRULE is going to be reduced.  |
  805|       |`------------------------------------------------*/
  806|       |
  807|       |static void
  808|       |yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp,
  809|       |                 int yyrule, Pire::Lexer& rlex)
  810|       |{
  811|       |  int yylno = yyrline[yyrule];
  812|       |  int yynrhs = yyr2[yyrule];
  813|       |  int yyi;
  814|       |  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
  815|       |             yyrule - 1, yylno);
  816|       |  /* The symbols being reduced.  */
  817|       |  for (yyi = 0; yyi < yynrhs; yyi++)
  818|       |    {
  819|       |      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
  820|       |      yy_symbol_print (stderr,
  821|       |                       YY_ACCESSING_SYMBOL (+yyssp[yyi + 1 - yynrhs]),
  822|       |                       &yyvsp[(yyi + 1) - (yynrhs)], rlex);
  823|       |      YYFPRINTF (stderr, "\n");
  824|       |    }
  825|       |}
  826|       |
  827|       |# define YY_REDUCE_PRINT(Rule)          \
  828|       |do {                                    \
  829|       |  if (yydebug)                          \
  830|       |    yy_reduce_print (yyssp, yyvsp, Rule, rlex); \
  831|       |} while (0)
  832|       |
  833|       |/* Nonzero means print parse trace.  It is left uninitialized so that
  834|       |   multiple parsers can coexist.  */
  835|       |int yydebug;
  836|       |#else /* !YYDEBUG */
  837|  11.5M|# define YYDPRINTF(Args) ((void) 0)
  838|       |# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)
  839|       |# define YY_STACK_PRINT(Bottom, Top)
  840|       |# define YY_REDUCE_PRINT(Rule)
  841|       |#endif /* !YYDEBUG */
  842|       |
  843|       |
  844|       |/* YYINITDEPTH -- initial size of the parser's stacks.  */
  845|       |#ifndef YYINITDEPTH
  846|   100k|# define YYINITDEPTH 200
  847|       |#endif
  848|       |
  849|       |/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
  850|       |   if the built-in stack extension method is used).
  851|       |
  852|       |   Do not make this value too large; the results are undefined if
  853|       |   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
  854|       |   evaluated with infinite-precision integer arithmetic.  */
  855|       |
  856|       |#ifndef YYMAXDEPTH
  857|       |# define YYMAXDEPTH 10000
  858|       |#endif
  859|       |
  860|       |
  861|       |
  862|       |
  863|       |
  864|       |
  865|       |/*-----------------------------------------------.
  866|       || Release the memory associated to this symbol.  |
  867|       |`-----------------------------------------------*/
  868|       |
  869|       |static void
  870|       |yydestruct (const char *yymsg,
  871|       |            yysymbol_kind_t yykind, YYSTYPE *yyvaluep, Pire::Lexer& rlex)
  872|   200k|{
  873|   200k|  YY_USE (yyvaluep);
  874|   200k|  YY_USE (rlex);
  875|   200k|  if (!yymsg)
  876|      0|    yymsg = "Deleting";
  877|   200k|  YY_SYMBOL_PRINT (yymsg, yykind, yyvaluep, yylocationp);
  878|       |
  879|   200k|  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
  880|   200k|  switch (yykind)
  881|   200k|    {
  882|      0|    case YYSYMBOL_YRE_LETTERS: /* YRE_LETTERS  */
  883|      0|#line 78 "re_parser.y"
  884|      0|            { delete (*yyvaluep); }
  885|      0|#line 886 "re_parser.tab.c"
  886|      0|        break;
  887|       |
  888|      0|    case YYSYMBOL_YRE_COUNT: /* YRE_COUNT  */
  889|      0|#line 78 "re_parser.y"
  890|      0|            { delete (*yyvaluep); }
  891|      0|#line 892 "re_parser.tab.c"
  892|      0|        break;
  893|       |
  894|      0|    case YYSYMBOL_YRE_DOT: /* YRE_DOT  */
  895|      0|#line 78 "re_parser.y"
  896|      0|            { delete (*yyvaluep); }
  897|      0|#line 898 "re_parser.tab.c"
  898|      0|        break;
  899|       |
  900|      0|    case YYSYMBOL_YRE_AND: /* YRE_AND  */
  901|      0|#line 78 "re_parser.y"
  902|      0|            { delete (*yyvaluep); }
  903|      0|#line 904 "re_parser.tab.c"
  904|      0|        break;
  905|       |
  906|      0|    case YYSYMBOL_YRE_NOT: /* YRE_NOT  */
  907|      0|#line 78 "re_parser.y"
  908|      0|            { delete (*yyvaluep); }
  909|      0|#line 910 "re_parser.tab.c"
  910|      0|        break;
  911|       |
  912|      0|    case YYSYMBOL_8_: /* '|'  */
  913|      0|#line 78 "re_parser.y"
  914|      0|            { delete (*yyvaluep); }
  915|      0|#line 916 "re_parser.tab.c"
  916|      0|        break;
  917|       |
  918|      0|    case YYSYMBOL_9_: /* '^'  */
  919|      0|#line 78 "re_parser.y"
  920|      0|            { delete (*yyvaluep); }
  921|      0|#line 922 "re_parser.tab.c"
  922|      0|        break;
  923|       |
  924|      0|    case YYSYMBOL_10_: /* '$'  */
  925|      0|#line 78 "re_parser.y"
  926|      0|            { delete (*yyvaluep); }
  927|      0|#line 928 "re_parser.tab.c"
  928|      0|        break;
  929|       |
  930|      0|    case YYSYMBOL_11_: /* '('  */
  931|      0|#line 78 "re_parser.y"
  932|      0|            { delete (*yyvaluep); }
  933|      0|#line 934 "re_parser.tab.c"
  934|      0|        break;
  935|       |
  936|      0|    case YYSYMBOL_12_: /* ')'  */
  937|      0|#line 78 "re_parser.y"
  938|      0|            { delete (*yyvaluep); }
  939|      0|#line 940 "re_parser.tab.c"
  940|      0|        break;
  941|       |
  942|   100k|    case YYSYMBOL_regexp: /* regexp  */
  943|   100k|#line 78 "re_parser.y"
  944|   100k|            { delete (*yyvaluep); }
  945|   100k|#line 946 "re_parser.tab.c"
  946|   100k|        break;
  947|       |
  948|      0|    case YYSYMBOL_alternative: /* alternative  */
  949|      0|#line 78 "re_parser.y"
  950|      0|            { delete (*yyvaluep); }
  951|      0|#line 952 "re_parser.tab.c"
  952|      0|        break;
  953|       |
  954|      0|    case YYSYMBOL_conjunction: /* conjunction  */
  955|      0|#line 78 "re_parser.y"
  956|      0|            { delete (*yyvaluep); }
  957|      0|#line 958 "re_parser.tab.c"
  958|      0|        break;
  959|       |
  960|      0|    case YYSYMBOL_negation: /* negation  */
  961|      0|#line 78 "re_parser.y"
  962|      0|            { delete (*yyvaluep); }
  963|      0|#line 964 "re_parser.tab.c"
  964|      0|        break;
  965|       |
  966|      0|    case YYSYMBOL_concatenation: /* concatenation  */
  967|      0|#line 78 "re_parser.y"
  968|      0|            { delete (*yyvaluep); }
  969|      0|#line 970 "re_parser.tab.c"
  970|      0|        break;
  971|       |
  972|      0|    case YYSYMBOL_iteration: /* iteration  */
  973|      0|#line 78 "re_parser.y"
  974|      0|            { delete (*yyvaluep); }
  975|      0|#line 976 "re_parser.tab.c"
  976|      0|        break;
  977|       |
  978|      0|    case YYSYMBOL_term: /* term  */
  979|      0|#line 78 "re_parser.y"
  980|      0|            { delete (*yyvaluep); }
  981|      0|#line 982 "re_parser.tab.c"
  982|      0|        break;
  983|       |
  984|   100k|      default:
  985|   100k|        break;
  986|   200k|    }
  987|   200k|  YY_IGNORE_MAYBE_UNINITIALIZED_END
  988|   200k|}
  989|       |
  990|       |
  991|       |
  992|       |
  993|       |
  994|       |
  995|       |/*----------.
  996|       || yyparse.  |
  997|       |`----------*/
  998|       |
  999|       |int
 1000|       |yyparse (Pire::Lexer& rlex)
 1001|   100k|{
 1002|       |/* Lookahead token kind.  */
 1003|   100k|int yychar;
 1004|       |
 1005|       |
 1006|       |/* The semantic value of the lookahead symbol.  */
 1007|       |/* Default value used for initialization, for pacifying older GCCs
 1008|       |   or non-GCC compilers.  */
 1009|   100k|YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
 1010|   100k|YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 1011|       |
 1012|       |    /* Number of syntax errors so far.  */
 1013|   100k|    int yynerrs = 0;
 1014|       |
 1015|   100k|    yy_state_fast_t yystate = 0;
 1016|       |    /* Number of tokens to shift before error messages enabled.  */
 1017|   100k|    int yyerrstatus = 0;
 1018|       |
 1019|       |    /* Refer to the stacks through separate pointers, to allow yyoverflow
 1020|       |       to reallocate them elsewhere.  */
 1021|       |
 1022|       |    /* Their size.  */
 1023|   100k|    YYPTRDIFF_T yystacksize = YYINITDEPTH;
 1024|       |
 1025|       |    /* The state stack: array, bottom, top.  */
 1026|   100k|    yy_state_t yyssa[YYINITDEPTH];
 1027|   100k|    yy_state_t *yyss = yyssa;
 1028|   100k|    yy_state_t *yyssp = yyss;
 1029|       |
 1030|       |    /* The semantic value stack: array, bottom, top.  */
 1031|   100k|    YYSTYPE yyvsa[YYINITDEPTH];
 1032|   100k|    YYSTYPE *yyvs = yyvsa;
 1033|   100k|    YYSTYPE *yyvsp = yyvs;
 1034|       |
 1035|   100k|  int yyn;
 1036|       |  /* The return value of yyparse.  */
 1037|   100k|  int yyresult;
 1038|       |  /* Lookahead symbol kind.  */
 1039|   100k|  yysymbol_kind_t yytoken = YYSYMBOL_YYEMPTY;
 1040|       |  /* The variables used to return semantic value and location from the
 1041|       |     action routines.  */
 1042|   100k|  YYSTYPE yyval;
 1043|       |
 1044|       |
 1045|       |
 1046|  6.90M|#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 1047|       |
 1048|       |  /* The number of symbols on the RHS of the reduced rule.
 1049|       |     Keep to zero when no symbol should be popped.  */
 1050|   100k|  int yylen = 0;
 1051|       |
 1052|   100k|  YYDPRINTF ((stderr, "Starting parse\n"));
 1053|       |
 1054|   100k|  yychar = YYEMPTY; /* Cause a token to be read.  */
 1055|       |
 1056|   100k|  goto yysetstate;
 1057|       |
 1058|       |
 1059|       |/*------------------------------------------------------------.
 1060|       || yynewstate -- push a new state, which is found in yystate.  |
 1061|       |`------------------------------------------------------------*/
 1062|  8.70M|yynewstate:
 1063|       |  /* In all cases, when you get here, the value and location stacks
 1064|       |     have just been pushed.  So pushing a state here evens the stacks.  */
 1065|  8.70M|  yyssp++;
 1066|       |
 1067|       |
 1068|       |/*--------------------------------------------------------------------.
 1069|       || yysetstate -- set current state (the top of the stack) to yystate.  |
 1070|       |`--------------------------------------------------------------------*/
 1071|  8.80M|yysetstate:
 1072|  8.80M|  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 1073|  8.80M|  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
 1074|  8.80M|  YY_IGNORE_USELESS_CAST_BEGIN
 1075|  8.80M|  *yyssp = YY_CAST (yy_state_t, yystate);
 1076|  8.80M|  YY_IGNORE_USELESS_CAST_END
 1077|  8.80M|  YY_STACK_PRINT (yyss, yyssp);
 1078|       |
 1079|  8.80M|  if (yyss + yystacksize - 1 <= yyssp)
 1080|      0|#if !defined yyoverflow && !defined YYSTACK_RELOCATE
 1081|      0|    YYNOMEM;
 1082|       |#else
 1083|       |    {
 1084|       |      /* Get the current used size of the three stacks, in elements.  */
 1085|       |      YYPTRDIFF_T yysize = yyssp - yyss + 1;
 1086|       |
 1087|       |# if defined yyoverflow
 1088|       |      {
 1089|       |        /* Give user a chance to reallocate the stack.  Use copies of
 1090|       |           these so that the &'s don't force the real ones into
 1091|       |           memory.  */
 1092|       |        yy_state_t *yyss1 = yyss;
 1093|       |        YYSTYPE *yyvs1 = yyvs;
 1094|       |
 1095|       |        /* Each stack pointer address is followed by the size of the
 1096|       |           data in use in that stack, in bytes.  This used to be a
 1097|       |           conditional around just the two extra args, but that might
 1098|       |           be undefined if yyoverflow is a macro.  */
 1099|       |        yyoverflow (YY_("memory exhausted"),
 1100|       |                    &yyss1, yysize * YYSIZEOF (*yyssp),
 1101|       |                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
 1102|       |                    &yystacksize);
 1103|       |        yyss = yyss1;
 1104|       |        yyvs = yyvs1;
 1105|       |      }
 1106|       |# else /* defined YYSTACK_RELOCATE */
 1107|       |      /* Extend the stack our own way.  */
 1108|       |      if (YYMAXDEPTH <= yystacksize)
 1109|       |        YYNOMEM;
 1110|       |      yystacksize *= 2;
 1111|       |      if (YYMAXDEPTH < yystacksize)
 1112|       |        yystacksize = YYMAXDEPTH;
 1113|       |
 1114|       |      {
 1115|       |        yy_state_t *yyss1 = yyss;
 1116|       |        union yyalloc *yyptr =
 1117|       |          YY_CAST (union yyalloc *,
 1118|       |                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
 1119|       |        if (! yyptr)
 1120|       |          YYNOMEM;
 1121|       |        YYSTACK_RELOCATE (yyss_alloc, yyss);
 1122|       |        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
 1123|       |#  undef YYSTACK_RELOCATE
 1124|       |        if (yyss1 != yyssa)
 1125|       |          YYSTACK_FREE (yyss1);
 1126|       |      }
 1127|       |# endif
 1128|       |
 1129|       |      yyssp = yyss + yysize - 1;
 1130|       |      yyvsp = yyvs + yysize - 1;
 1131|       |
 1132|       |      YY_IGNORE_USELESS_CAST_BEGIN
 1133|       |      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
 1134|       |                  YY_CAST (long, yystacksize)));
 1135|       |      YY_IGNORE_USELESS_CAST_END
 1136|       |
 1137|       |      if (yyss + yystacksize - 1 <= yyssp)
 1138|       |        YYABORT;
 1139|       |    }
 1140|       |#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
 1141|       |
 1142|       |
 1143|  8.80M|  if (yystate == YYFINAL)
 1144|   100k|    YYACCEPT;
 1145|       |
 1146|  8.70M|  goto yybackup;
 1147|       |
 1148|       |
 1149|       |/*-----------.
 1150|       || yybackup.  |
 1151|       |`-----------*/
 1152|  8.70M|yybackup:
 1153|       |  /* Do appropriate processing given the current state.  Read a
 1154|       |     lookahead token if we need one and don't already have one.  */
 1155|       |
 1156|       |  /* First try to decide what to do without reference to lookahead token.  */
 1157|  8.70M|  yyn = yypact[yystate];
 1158|  8.70M|  if (yypact_value_is_default (yyn))
 1159|  4.00M|    goto yydefault;
 1160|       |
 1161|       |  /* Not known => get a lookahead token if don't already have one.  */
 1162|       |
 1163|       |  /* YYCHAR is either empty, or end-of-input, or a valid lookahead.  */
 1164|  4.70M|  if (yychar == YYEMPTY)
 1165|  2.10M|    {
 1166|  2.10M|      YYDPRINTF ((stderr, "Reading a token\n"));
 1167|  2.10M|      yychar = yylex (&yylval, rlex);
 1168|  2.10M|    }
 1169|       |
 1170|  4.70M|  if (yychar <= YYEOF)
 1171|   500k|    {
 1172|   500k|      yychar = YYEOF;
 1173|   500k|      yytoken = YYSYMBOL_YYEOF;
 1174|   500k|      YYDPRINTF ((stderr, "Now at end of input.\n"));
 1175|   500k|    }
 1176|  4.20M|  else if (yychar == YYerror)
 1177|      0|    {
 1178|       |      /* The scanner already issued an error message, process directly
 1179|       |         to error recovery.  But do not keep the error token as
 1180|       |         lookahead, it is too special and may lead us to an endless
 1181|       |         loop in error recovery. */
 1182|      0|      yychar = YYUNDEF;
 1183|      0|      yytoken = YYSYMBOL_YYerror;
 1184|      0|      goto yyerrlab1;
 1185|      0|    }
 1186|  4.20M|  else
 1187|  4.20M|    {
 1188|  4.20M|      yytoken = YYTRANSLATE (yychar);
 1189|  4.20M|      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
 1190|  4.20M|    }
 1191|       |
 1192|       |  /* If the proper action on seeing token YYTOKEN is to reduce or to
 1193|       |     detect an error, take that action.  */
 1194|  4.70M|  yyn += yytoken;
 1195|  4.70M|  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
 1196|  2.60M|    goto yydefault;
 1197|  2.10M|  yyn = yytable[yyn];
 1198|  2.10M|  if (yyn <= 0)
 1199|      0|    {
 1200|      0|      if (yytable_value_is_error (yyn))
 1201|      0|        goto yyerrlab;
 1202|      0|      yyn = -yyn;
 1203|      0|      goto yyreduce;
 1204|      0|    }
 1205|       |
 1206|       |  /* Count tokens shifted since error; after three, turn off error
 1207|       |     status.  */
 1208|  2.10M|  if (yyerrstatus)
 1209|      0|    yyerrstatus--;
 1210|       |
 1211|       |  /* Shift the lookahead token.  */
 1212|  2.10M|  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
 1213|  2.10M|  yystate = yyn;
 1214|  2.10M|  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
 1215|  2.10M|  *++yyvsp = yylval;
 1216|  2.10M|  YY_IGNORE_MAYBE_UNINITIALIZED_END
 1217|       |
 1218|       |  /* Discard the shifted token.  */
 1219|  2.10M|  yychar = YYEMPTY;
 1220|  2.10M|  goto yynewstate;
 1221|       |
 1222|       |
 1223|       |/*-----------------------------------------------------------.
 1224|       || yydefault -- do the default action for the current state.  |
 1225|       |`-----------------------------------------------------------*/
 1226|  6.60M|yydefault:
 1227|  6.60M|  yyn = yydefact[yystate];
 1228|  6.60M|  if (yyn == 0)
 1229|      0|    goto yyerrlab;
 1230|  6.60M|  goto yyreduce;
 1231|       |
 1232|       |
 1233|       |/*-----------------------------.
 1234|       || yyreduce -- do a reduction.  |
 1235|       |`-----------------------------*/
 1236|  6.60M|yyreduce:
 1237|       |  /* yyn is the number of a rule to reduce with.  */
 1238|  6.60M|  yylen = yyr2[yyn];
 1239|       |
 1240|       |  /* If YYLEN is nonzero, implement the default value of the action:
 1241|       |     '$$ = $1'.
 1242|       |
 1243|       |     Otherwise, the following line sets YYVAL to garbage.
 1244|       |     This behavior is undocumented and Bison
 1245|       |     users should not rely upon it.  Assigning to YYVAL
 1246|       |     unconditionally makes the parser a bit smaller, and it avoids a
 1247|       |     GCC warning that YYVAL may be used uninitialized.  */
 1248|  6.60M|  yyval = yyvsp[1-yylen];
 1249|       |
 1250|       |
 1251|  6.60M|  YY_REDUCE_PRINT (yyn);
 1252|  6.60M|  switch (yyn)
 1253|  6.60M|    {
 1254|   100k|  case 2: /* regexp: alternative  */
 1255|   100k|#line 84 "re_parser.y"
 1256|   100k|                {
 1257|   100k|			ConvertToFSM(rlex.Encoding(), yyvsp[0]);
 1258|   100k|			DoSwap(rlex.Retval(), *yyvsp[0]);
 1259|   100k|			delete yyvsp[0];
 1260|   100k|			yyval = nullptr;
 1261|   100k|		}
 1262|   100k|#line 1263 "re_parser.tab.c"
 1263|   100k|    break;
 1264|       |
 1265|      0|  case 4: /* alternative: alternative '|' conjunction  */
 1266|      0|#line 94 "re_parser.y"
 1267|      0|                                      { ConvertToFSM(rlex.Encoding(), (yyval = yyvsp[-2])) |= ConvertToFSM(rlex.Encoding(), yyvsp[0]); delete yyvsp[-1]; delete yyvsp[0]; }
 1268|      0|#line 1269 "re_parser.tab.c"
 1269|      0|    break;
 1270|       |
 1271|      0|  case 6: /* conjunction: conjunction YRE_AND negation  */
 1272|      0|#line 99 "re_parser.y"
 1273|      0|                                       { ConvertToFSM(rlex.Encoding(), (yyval = yyvsp[-2])) &= ConvertToFSM(rlex.Encoding(), yyvsp[0]); delete yyvsp[-1]; delete yyvsp[0]; }
 1274|      0|#line 1275 "re_parser.tab.c"
 1275|      0|    break;
 1276|       |
 1277|      0|  case 8: /* negation: YRE_NOT concatenation  */
 1278|      0|#line 104 "re_parser.y"
 1279|      0|                                { ConvertToFSM(rlex.Encoding(), (yyval = yyvsp[0])).Complement(); delete yyvsp[-1]; }
 1280|      0|#line 1281 "re_parser.tab.c"
 1281|      0|    break;
 1282|       |
 1283|   200k|  case 9: /* concatenation: %empty  */
 1284|   200k|#line 108 "re_parser.y"
 1285|   200k|          { yyval = new Any(Fsm()); }
 1286|   200k|#line 1287 "re_parser.tab.c"
 1287|   200k|    break;
 1288|       |
 1289|  1.90M|  case 10: /* concatenation: concatenation iteration  */
 1290|  1.90M|#line 110 "re_parser.y"
 1291|  1.90M|                {
 1292|  1.90M|			Fsm& a = ConvertToFSM(rlex.Encoding(), (yyval = yyvsp[-1]));
 1293|  1.90M|			if (yyvsp[0]->IsA<Term::CharacterRange>() && !yyvsp[0]->As<Term::CharacterRange>().second)
 1294|  1.70M|				AppendRange(rlex.Encoding(), a, yyvsp[0]->As<Term::CharacterRange>());
 1295|   200k|			else if (yyvsp[0]->IsA<Term::DotTag>())
 1296|   100k|				rlex.Encoding().AppendDot(a);
 1297|   100k|			else
 1298|   100k|				a += ConvertToFSM(rlex.Encoding(), yyvsp[0]);
 1299|  1.90M|			delete yyvsp[0];
 1300|  1.90M|		}
 1301|  1.90M|#line 1302 "re_parser.tab.c"
 1302|  1.90M|    break;
 1303|       |
 1304|      0|  case 12: /* iteration: term YRE_COUNT  */
 1305|      0|#line 125 "re_parser.y"
 1306|      0|                {
 1307|      0|			Fsm& orig = ConvertToFSM(rlex.Encoding(), yyvsp[-1]);
 1308|      0|			yyval = new Any(orig);
 1309|      0|			Fsm& cur = yyval->As<Fsm>();
 1310|      0|			const Term::RepetitionCount& repc = yyvsp[0]->As<Term::RepetitionCount>();
 1311|       |
 1312|       |
 1313|      0|			if (repc.first == 0 && repc.second == 1) {
 1314|      0|				Fsm empty;
 1315|      0|				cur |= empty;
 1316|      0|			} else if (repc.first == 0 && repc.second == Inf) {
 1317|      0|				cur.Iterate();
 1318|      0|			} else if (repc.first == 1 && repc.second == Inf) {
 1319|      0|				cur += *cur;
 1320|      0|			} else {
 1321|      0|				cur *= repc.first;
 1322|      0|				if (repc.second == Inf) {
 1323|      0|					cur += *orig;
 1324|      0|				} else if (repc.second != repc.first) {
 1325|      0|					cur += (orig | Fsm()) * (repc.second - repc.first);
 1326|      0|				}
 1327|      0|			}
 1328|      0|			rlex.Parenthesized(yyval->As<Fsm>());
 1329|      0|			delete yyvsp[-1];
 1330|      0|			delete yyvsp[0];
 1331|      0|		}
 1332|      0|#line 1333 "re_parser.tab.c"
 1333|      0|    break;
 1334|       |
 1335|   100k|  case 17: /* term: '(' alternative ')'  */
 1336|   100k|#line 158 "re_parser.y"
 1337|   100k|                                   { yyval = yyvsp[-1]; rlex.Parenthesized(yyval->As<Fsm>()); delete yyvsp[-2]; delete yyvsp[0]; }
 1338|   100k|#line 1339 "re_parser.tab.c"
 1339|   100k|    break;
 1340|       |
 1341|       |
 1342|      0|#line 1343 "re_parser.tab.c"
 1343|       |
 1344|  4.30M|      default: break;
 1345|  6.60M|    }
 1346|       |  /* User semantic actions sometimes alter yychar, and that requires
 1347|       |     that yytoken be updated with the new translation.  We take the
 1348|       |     approach of translating immediately before every use of yytoken.
 1349|       |     One alternative is translating here after every semantic action,
 1350|       |     but that translation would be missed if the semantic action invokes
 1351|       |     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
 1352|       |     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
 1353|       |     incorrect destructor might then be invoked immediately.  In the
 1354|       |     case of YYERROR or YYBACKUP, subsequent parser actions might lead
 1355|       |     to an incorrect destructor call or verbose syntax error message
 1356|       |     before the lookahead is translated.  */
 1357|  6.60M|  YY_SYMBOL_PRINT ("-> $$ =", YY_CAST (yysymbol_kind_t, yyr1[yyn]), &yyval, &yyloc);
 1358|       |
 1359|  6.60M|  YYPOPSTACK (yylen);
 1360|  6.60M|  yylen = 0;
 1361|       |
 1362|  6.60M|  *++yyvsp = yyval;
 1363|       |
 1364|       |  /* Now 'shift' the result of the reduction.  Determine what state
 1365|       |     that goes to, based on the state we popped back to and the rule
 1366|       |     number reduced by.  */
 1367|  6.60M|  {
 1368|  6.60M|    const int yylhs = yyr1[yyn] - YYNTOKENS;
 1369|  6.60M|    const int yyi = yypgoto[yylhs] + *yyssp;
 1370|  6.60M|    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
 1371|  6.60M|               ? yytable[yyi]
 1372|  6.60M|               : yydefgoto[yylhs]);
 1373|  6.60M|  }
 1374|       |
 1375|  6.60M|  goto yynewstate;
 1376|       |
 1377|       |
 1378|       |/*--------------------------------------.
 1379|       || yyerrlab -- here on detecting error.  |
 1380|       |`--------------------------------------*/
 1381|      0|yyerrlab:
 1382|       |  /* Make sure we have latest lookahead translation.  See comments at
 1383|       |     user semantic actions for why this is necessary.  */
 1384|      0|  yytoken = yychar == YYEMPTY ? YYSYMBOL_YYEMPTY : YYTRANSLATE (yychar);
 1385|       |  /* If not already recovering from an error, report this error.  */
 1386|      0|  if (!yyerrstatus)
 1387|      0|    {
 1388|      0|      ++yynerrs;
 1389|      0|      yyerror (rlex, YY_("syntax error"));
 1390|      0|    }
 1391|       |
 1392|      0|  if (yyerrstatus == 3)
 1393|      0|    {
 1394|       |      /* If just tried and failed to reuse lookahead token after an
 1395|       |         error, discard it.  */
 1396|       |
 1397|      0|      if (yychar <= YYEOF)
 1398|      0|        {
 1399|       |          /* Return failure if at end of input.  */
 1400|      0|          if (yychar == YYEOF)
 1401|      0|            YYABORT;
 1402|      0|        }
 1403|      0|      else
 1404|      0|        {
 1405|      0|          yydestruct ("Error: discarding",
 1406|      0|                      yytoken, &yylval, rlex);
 1407|      0|          yychar = YYEMPTY;
 1408|      0|        }
 1409|      0|    }
 1410|       |
 1411|       |  /* Else will try to reuse lookahead token after shifting the error
 1412|       |     token.  */
 1413|      0|  goto yyerrlab1;
 1414|       |
 1415|       |
 1416|       |/*---------------------------------------------------.
 1417|       || yyerrorlab -- error raised explicitly by YYERROR.  |
 1418|       |`---------------------------------------------------*/
 1419|      0|yyerrorlab:
 1420|       |  /* Pacify compilers when the user code never invokes YYERROR and the
 1421|       |     label yyerrorlab therefore never appears in user code.  */
 1422|      0|  if (0)
 1423|      0|    YYERROR;
 1424|      0|  ++yynerrs;
 1425|       |
 1426|       |  /* Do not reclaim the symbols of the rule whose action triggered
 1427|       |     this YYERROR.  */
 1428|      0|  YYPOPSTACK (yylen);
 1429|      0|  yylen = 0;
 1430|      0|  YY_STACK_PRINT (yyss, yyssp);
 1431|      0|  yystate = *yyssp;
 1432|      0|  goto yyerrlab1;
 1433|       |
 1434|       |
 1435|       |/*-------------------------------------------------------------.
 1436|       || yyerrlab1 -- common code for both syntax error and YYERROR.  |
 1437|       |`-------------------------------------------------------------*/
 1438|      0|yyerrlab1:
 1439|      0|  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
 1440|       |
 1441|       |  /* Pop stack until we find a state that shifts the error token.  */
 1442|      0|  for (;;)
 1443|      0|    {
 1444|      0|      yyn = yypact[yystate];
 1445|      0|      if (!yypact_value_is_default (yyn))
 1446|      0|        {
 1447|      0|          yyn += YYSYMBOL_YYerror;
 1448|      0|          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYSYMBOL_YYerror)
 1449|      0|            {
 1450|      0|              yyn = yytable[yyn];
 1451|      0|              if (0 < yyn)
 1452|      0|                break;
 1453|      0|            }
 1454|      0|        }
 1455|       |
 1456|       |      /* Pop the current state because it cannot handle the error token.  */
 1457|      0|      if (yyssp == yyss)
 1458|      0|        YYABORT;
 1459|       |
 1460|       |
 1461|      0|      yydestruct ("Error: popping",
 1462|      0|                  YY_ACCESSING_SYMBOL (yystate), yyvsp, rlex);
 1463|      0|      YYPOPSTACK (1);
 1464|      0|      yystate = *yyssp;
 1465|      0|      YY_STACK_PRINT (yyss, yyssp);
 1466|      0|    }
 1467|       |
 1468|      0|  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
 1469|      0|  *++yyvsp = yylval;
 1470|      0|  YY_IGNORE_MAYBE_UNINITIALIZED_END
 1471|       |
 1472|       |
 1473|       |  /* Shift the error token.  */
 1474|      0|  YY_SYMBOL_PRINT ("Shifting", YY_ACCESSING_SYMBOL (yyn), yyvsp, yylsp);
 1475|       |
 1476|      0|  yystate = yyn;
 1477|      0|  goto yynewstate;
 1478|       |
 1479|       |
 1480|       |/*-------------------------------------.
 1481|       || yyacceptlab -- YYACCEPT comes here.  |
 1482|       |`-------------------------------------*/
 1483|   100k|yyacceptlab:
 1484|   100k|  yyresult = 0;
 1485|   100k|  goto yyreturnlab;
 1486|       |
 1487|       |
 1488|       |/*-----------------------------------.
 1489|       || yyabortlab -- YYABORT comes here.  |
 1490|       |`-----------------------------------*/
 1491|      0|yyabortlab:
 1492|      0|  yyresult = 1;
 1493|      0|  goto yyreturnlab;
 1494|       |
 1495|       |
 1496|       |/*-----------------------------------------------------------.
 1497|       || yyexhaustedlab -- YYNOMEM (memory exhaustion) comes here.  |
 1498|       |`-----------------------------------------------------------*/
 1499|      0|yyexhaustedlab:
 1500|      0|  yyerror (rlex, YY_("memory exhausted"));
 1501|      0|  yyresult = 2;
 1502|      0|  goto yyreturnlab;
 1503|       |
 1504|       |
 1505|       |/*----------------------------------------------------------.
 1506|       || yyreturnlab -- parsing is finished, clean up and return.  |
 1507|       |`----------------------------------------------------------*/
 1508|   100k|yyreturnlab:
 1509|   100k|  if (yychar != YYEMPTY)
 1510|      0|    {
 1511|       |      /* Make sure we have latest lookahead translation.  See comments at
 1512|       |         user semantic actions for why this is necessary.  */
 1513|      0|      yytoken = YYTRANSLATE (yychar);
 1514|      0|      yydestruct ("Cleanup: discarding lookahead",
 1515|      0|                  yytoken, &yylval, rlex);
 1516|      0|    }
 1517|       |  /* Do not reclaim the symbols of the rule whose action triggered
 1518|       |     this YYABORT or YYACCEPT.  */
 1519|   100k|  YYPOPSTACK (yylen);
 1520|   100k|  YY_STACK_PRINT (yyss, yyssp);
 1521|   300k|  while (yyssp != yyss)
 1522|   200k|    {
 1523|   200k|      yydestruct ("Cleanup: popping",
 1524|   200k|                  YY_ACCESSING_SYMBOL (+*yyssp), yyvsp, rlex);
 1525|   200k|      YYPOPSTACK (1);
 1526|   200k|    }
 1527|   100k|#ifndef yyoverflow
 1528|   100k|  if (yyss != yyssa)
 1529|      0|    YYSTACK_FREE (yyss);
 1530|   100k|#endif
 1531|       |
 1532|   100k|  return yyresult;
 1533|      0|}
 1534|       |
 1535|       |#line 161 "re_parser.y"
 1536|       |
 1537|       |
 1538|       |int yylex(YYSTYPE* lval, Pire::Lexer& rlex)
 1539|  2.10M|{
 1540|  2.10M|	try {
 1541|  2.10M|		Pire::Term term = rlex.Lex();
 1542|  2.10M|		if (!term.Value().Empty())
 1543|  1.80M|			*lval = new Any(term.Value());
 1544|   300k|		else
 1545|   300k|			*lval = nullptr;
 1546|  2.10M|		return term.Type();
 1547|  2.10M|	} catch (Pire::Error &e) {
 1548|      0|		rlex.SetErrMsg(e.what());
 1549|      0|		return 0;
 1550|      0|	}
 1551|  2.10M|}
 1552|       |
 1553|       |void yyerror(const char* str)
 1554|      0|{
 1555|      0|}
 1556|       |
 1557|       |void yyerror(Pire::Lexer& rlex, const char* str)
 1558|      0|{
 1559|      0|	if (!rlex.ErrMsg().empty())
 1560|      0|		rlex.SetErrMsg(ystring("Regexp parse error: ").append(str));
 1561|       |
 1562|      0|	yyerror(str);
 1563|      0|}
 1564|       |
 1565|       |void AppendRange(const Encoding& encoding, Fsm& a, const Term::CharacterRange& cr)
 1566|  1.70M|{
 1567|  1.70M|	TVector<ystring> strings;
 1568|       |
 1569|  1.70M|	for (auto&& i : cr.first) {
 1570|  1.70M|		ystring s;
 1571|  1.70M|		for (auto&& j : i) {
 1572|  1.70M|			ystring c = encoding.ToLocal(j);
 1573|  1.70M|			if (c.empty()) {
 1574|      0|				s.clear();
 1575|      0|				break;
 1576|      0|			} else
 1577|  1.70M|				s += encoding.ToLocal(j);
 1578|  1.70M|		}
 1579|  1.70M|		if (!s.empty())
 1580|  1.70M|			strings.push_back(s);
 1581|  1.70M|	}
 1582|  1.70M|	if (strings.empty())
 1583|       |		// Strings accepted by this FSM are not representable in the current encoding.
 1584|       |		// Hence, FSM will accept nothing, and we simply can clear it.
 1585|      0|		a = Fsm::MakeFalse();
 1586|  1.70M|	else
 1587|  1.70M|		a.AppendStrings(strings);
 1588|  1.70M|}
 1589|       |
 1590|       |Fsm& ConvertToFSM(const Encoding& encoding, Any* any)
 1591|  2.10M|{
 1592|  2.10M|	if (any->IsA<Fsm>())
 1593|  2.10M|		return any->As<Fsm>();
 1594|       |
 1595|      0|	Any ret = Fsm();
 1596|      0|	Fsm& a = ret.As<Fsm>();
 1597|       |
 1598|      0|	if (any->IsA<Term::DotTag>()) {
 1599|      0|		encoding.AppendDot(a);
 1600|      0|	} else if (any->IsA<Term::BeginTag>()) {
 1601|      0|		a.AppendSpecial(BeginMark);
 1602|      0|	} else if (any->IsA<Term::EndTag>()) {
 1603|      0|		a.AppendSpecial(EndMark);
 1604|      0|	} else {
 1605|      0|		Term::CharacterRange cr = any->As<Term::CharacterRange>();
 1606|      0|		AppendRange(encoding, a, cr);
 1607|      0|		if (cr.second) {
 1608|      0|			Fsm x;
 1609|      0|			encoding.AppendDot(x);
 1610|      0|			x.Complement();
 1611|      0|			a |= x;
 1612|      0|			a.Complement();
 1613|      0|			a.RemoveDeadEnds();
 1614|      0|		}
 1615|      0|	}
 1616|      0|	any->Swap(ret);
 1617|      0|	return a;
 1618|  2.10M|}
 1619|       |
 1620|       |} // namespace
 1621|       |
 1622|       |#if defined(PPP) && !defined(HAVE_CONFIG_H)
 1623|       |// Workaround for some braindamaged byaccs which cannot decide what yyparse() should look like 
 1624|       |static int yyparse(void*, Pire::Lexer& rlex);
 1625|       |
 1626|       |namespace Pire {
 1627|       |	namespace Impl {
 1628|       |		int yre_parse(Pire::Lexer& rlex)
 1629|       |		{
 1630|       |			int rc = yyparse(0, rlex);
 1631|       |
 1632|       |			if (!rlex.ErrMsg().empty())
 1633|       |				throw Error(rlex.ErrMsg());
 1634|       |			return rc;
 1635|       |		}
 1636|       |	}
 1637|       |}
 1638|       |#else
 1639|       |namespace Pire {
 1640|       |	namespace Impl {
 1641|       |		int yre_parse(Pire::Lexer& rlex)
 1642|   100k|		{
 1643|   100k|			int rc = yyparse(rlex);
 1644|       |
 1645|   100k|			if (!rlex.ErrMsg().empty())
 1646|      0|				throw Error(rlex.ErrMsg());
 1647|   100k|			return rc;
 1648|   100k|		}
 1649|       |	}
 1650|       |}
 1651|       |#endif

/home/johnpaul/pire/pire/read_unicode.cpp:
    1|       |/*
    2|       | * read_unicode.cpp -- implementation of the UnicodeReader.
    3|       | *
    4|       | * Copyright (c) 2018-2019 YANDEX LLC, Andrey Logvin <andry@logvin.net>
    5|       | *                                     Karina Usmanova <usmanova.karin@yandex.ru>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | *
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |#include "read_unicode.h"
   24|       |
   25|       |namespace Pire {
   26|      0|	wchar32 UnicodeReader::ReadUnicodeCharacter() {
   27|      0|		ystring hexStr;
   28|      0|		GetChar();
   29|      0|		wchar32 ch = PeekChar();
   30|       |
   31|      0|		if (ch == '{') {
   32|      0|			GetChar();
   33|      0|			hexStr = ReadHexDigit(
   34|      0|					[](wchar32 ch, size_t numAdded) -> bool { return ch == End || (numAdded != 0 && ch == '}'); });
   35|      0|			ch = GetChar();
   36|      0|			if (ch != '}') {
   37|      0|				Error("Pire::UnicodeReader::ReadUnicodeCharacter(): \"\\x{...\" sequence should be closed by \"}\"");
   38|      0|			}
   39|      0|		} else {
   40|      0|			hexStr = ReadHexDigit([](wchar32, size_t numAdded) -> bool { return numAdded == 2; });
   41|      0|			if (hexStr.size() != 2) {
   42|      0|				Error("Pire::UnicodeReader::ReadUnicodeCharacter(): \"\\x...\" sequence should contain two symbols");
   43|      0|			}
   44|      0|		}
   45|      0|		return HexToDec(hexStr);
   46|      0|	}
   47|       |
   48|      0|	bool UnicodeReader::IsHexDigit(wchar32 ch) {
   49|      0|		return ch < 256 && std::isxdigit(ch) != 0;
   50|      0|	}
   51|       |
   52|      0|	ystring UnicodeReader::ReadHexDigit(std::function<bool(wchar32, size_t)> shouldStop) {
   53|      0|		ystring result;
   54|      0|		wchar32 ch = GetChar();
   55|      0|		while (!shouldStop(ch, result.size())) {
   56|      0|			if (!IsHexDigit(ch)) {
   57|      0|				Error("Pire::UnicodeReader::ReadHexDigit(): \"\\x...\" sequence contains non-valid hex number");
   58|      0|			}
   59|      0|			result.push_back(ch);
   60|      0|			ch = GetChar();
   61|      0|		}
   62|      0|		UngetChar(ch);
   63|      0|		return result;
   64|      0|	}
   65|       |
   66|      0|	wchar32 UnicodeReader::HexToDec(const ystring &hexStr) {
   67|      0|		wchar32 converted;
   68|      0|		try {
   69|      0|			converted = std::stoul(hexStr, 0, 16);
   70|      0|		} catch (std::out_of_range &) {
   71|      0|			converted = MaxUnicode + 1;
   72|      0|		}
   73|      0|		if (converted > MaxUnicode) {
   74|      0|			Error("Pire::UnicodeReader::HexToDec(): hex number in \"\\x...\" sequence is too large");
   75|      0|		}
   76|      0|		return converted;
   77|      0|	}
   78|       |}

/home/johnpaul/pire/pire/run.h:
    1|       |/*
    2|       | * run.h -- routines for running scanners on strings.
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#ifndef PIRE_RE_SCANNER_H
   25|       |#define PIRE_RE_SCANNER_H
   26|       |
   27|       |#include "defs.h"
   28|       |#include "stub/stl.h"
   29|       |#include "stub/memstreams.h"
   30|       |#include "scanners/pair.h"
   31|       |#include "platform.h"
   32|       |
   33|       |namespace Pire {
   34|       |
   35|       |	template<class Scanner>
   36|       |	struct StDumper {
   37|       |		StDumper(const Scanner& sc, typename Scanner::State st): m_sc(&sc), m_st(st) {}
   38|       |		void Dump(yostream& stream) const { stream << m_sc->StateIndex(m_st) << (m_sc->Final(m_st) ? " [final]" : ""); }
   39|       |	private:
   40|       |		const Scanner* m_sc;
   41|       |		typename Scanner::State m_st;
   42|       |	};
   43|       |
   44|       |	template<class Scanner> StDumper<Scanner> StDump(const Scanner& sc, typename Scanner::State st) { return StDumper<Scanner>(sc, st); }
   45|       |	template<class Scanner> yostream& operator << (yostream& stream, const StDumper<Scanner>& stdump) { stdump.Dump(stream); return stream; }
   46|       |}
   47|       |
   48|       |namespace Pire {
   49|       |
   50|       |template<class Scanner>
   51|       |PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
   52|       |void Step(const Scanner& scanner, typename Scanner::State& state, Char ch)
   53|  14.5M|{
   54|  14.5M|	Y_ASSERT(ch < MaxCharUnaligned);
   55|  14.5M|	typename Scanner::Action a = scanner.Next(state, ch);
   56|  14.5M|	scanner.TakeAction(state, a);
   57|  14.5M|}
   58|       |
   59|       |namespace Impl {
   60|       |
   61|       |	enum Action { Continue, Stop };
   62|       |
   63|       |	template<class Scanner>
   64|       |	struct RunPred {
   65|       |		PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
   66|  14.3M|		Action operator()(const Scanner&, const typename Scanner::State&, const char*) const { return Continue; }
   67|       |	};
   68|       |	
   69|       |	template<class Scanner>
   70|       |	struct ShortestPrefixPred {
   71|       |		explicit ShortestPrefixPred(const char*& pos): m_pos(&pos) {}
   72|       |
   73|       |		PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
   74|       |		Action operator()(const Scanner& sc, const typename Scanner::State& st, const char* pos) const
   75|       |		{
   76|       |			if (sc.Final(st)) {
   77|       |				*m_pos = pos;
   78|       |				return Stop;
   79|       |			} else {
   80|       |				return (sc.Dead(st) ? Stop : Continue);
   81|       |			}
   82|       |		}
   83|       |	private:
   84|       |		const char** m_pos;
   85|       |	};
   86|       |	
   87|       |	template<class Scanner>
   88|       |	struct LongestPrefixPred {
   89|       |		explicit LongestPrefixPred(const char*& pos): m_pos(&pos) {}
   90|       |		
   91|       |		PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
   92|       |		Action operator()(const Scanner& sc, const typename Scanner::State& st, const char* pos) const
   93|       |		{
   94|       |			if (sc.Final(st))
   95|       |				*m_pos = pos;
   96|       |			return (sc.Dead(st) ? Stop : Continue);
   97|       |		}
   98|       |	private:
   99|       |		const char** m_pos;
  100|       |	};
  101|       |
  102|       |}
  103|       |
  104|       |#ifndef PIRE_DEBUG
  105|       |
  106|       |namespace Impl {
  107|       |
  108|       |	template<class Scanner, class Pred>
  109|       |	PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
  110|       |	Action SafeRunChunk(const Scanner& scanner, typename Scanner::State& state, const size_t* p, size_t pos, size_t size, Pred pred)
  111|  80.2k|	{
  112|  80.2k|		Y_ASSERT(pos <= sizeof(size_t));
  113|  80.2k|		Y_ASSERT(size <= sizeof(size_t));
  114|  80.2k|		Y_ASSERT(pos + size <= sizeof(size_t));
  115|       |
  116|  80.2k|        if (PIRE_UNLIKELY(size == 0))
  117|      1|            return Continue;
  118|       |
  119|  80.2k|		const char* ptr = (const char*) p + pos;
  120|   385k|		for (; size--; ++ptr) {
  121|   305k|			Step(scanner, state, (unsigned char) *ptr);
  122|   305k|			if (pred(scanner, state, ptr + 1) == Stop)
  123|      0|				return Stop;
  124|   305k|		}
  125|  80.2k|		return Continue;
  126|  80.2k|	}
  127|       |
  128|       |	/// Effectively runs a scanner on a short data chunk, fit completely into one machine word.
  129|       |	template<class Scanner, class Pred>
  130|       |	PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
  131|       |	Action RunChunk(const Scanner& scanner, typename Scanner::State& state, const size_t* p, size_t pos, size_t size, Pred pred)
  132|  1.76M|	{
  133|  1.76M|		Y_ASSERT(pos <= sizeof(size_t));
  134|  1.76M|		Y_ASSERT(size <= sizeof(size_t));
  135|  1.76M|		Y_ASSERT(pos + size <= sizeof(size_t));
  136|       |
  137|  1.76M|		if (PIRE_UNLIKELY(size == 0))
  138|      0|			return Continue;
  139|       |
  140|  1.76M|		size_t chunk = Impl::ToLittleEndian(*p) >> 8*pos;
  141|  1.76M|		const char* ptr = (const char*) p + pos + size + 1;
  142|       |
  143|  15.8M|		for (size_t i = size; i != 0; --i) {
  144|  14.0M|			Step(scanner, state, chunk & 0xFF);
  145|  14.0M|			if (pred(scanner, state, ptr - i) == Stop)
  146|      0|				return Stop;
  147|  14.0M|			chunk >>= 8;
  148|  14.0M|		}
  149|       |
  150|  1.76M|		return Continue;
  151|  1.76M|	}
  152|       |	
  153|       |	template<class Scanner>
  154|       |	struct AlignedRunner {
  155|       |
  156|       |		// Generic version for LongestPrefix()/ShortestPrefix() impelementations
  157|       |		template<class Pred>
  158|       |		static inline PIRE_HOT_FUNCTION
  159|       |		Action RunAligned(const Scanner& scanner, typename Scanner::State& state, const size_t* begin, const size_t* end, Pred stop)
  160|       |		{
  161|       |			typename Scanner::State st = state;
  162|       |			Action ret = Continue;
  163|       |			for (; begin != end && (ret = RunChunk(scanner, st, begin, 0, sizeof(void*), stop)) == Continue; ++begin)
  164|       |				;
  165|       |			state = st;
  166|       |			return ret;
  167|       |		}
  168|       |
  169|       |		// A special version for Run() impelementation that skips predicate checks
  170|       |		static inline PIRE_HOT_FUNCTION
  171|       |		Action RunAligned(const Scanner& scanner, typename Scanner::State& state, const size_t* begin, const size_t* end, RunPred<Scanner>)
  172|       |		{
  173|       |			typename Scanner::State st = state;
  174|       |			for (; begin != end; ++begin) {
  175|       |				size_t chunk = *begin;
  176|       |				for (size_t i = sizeof(chunk); i != 0; --i) {
  177|       |					Step(scanner, st, chunk & 0xFF);
  178|       |					chunk >>= 8;
  179|       |				}
  180|       |			}
  181|       |			state = st;
  182|       |			return Continue;
  183|       |		}
  184|       |	};
  185|       |
  186|       |	/// The main function: runs a scanner through given memory range.
  187|       |	template<class Scanner, class Pred>
  188|       |	inline void DoRun(const Scanner& scanner, typename Scanner::State& st, const char* begin, const char* end, Pred pred)
  189|   100k|	{
  190|   100k|		const size_t* head = reinterpret_cast<const size_t*>((reinterpret_cast<uintptr_t>(begin)) & ~(sizeof(size_t)-1));
  191|   100k|		const size_t* tail = reinterpret_cast<const size_t*>((reinterpret_cast<uintptr_t>(end)) & ~(sizeof(size_t)-1));
  192|       |
  193|   100k|		size_t headSize = ((const char*) head + sizeof(size_t) - begin); // The distance from @p begin to the end of the word containing @p begin
  194|   100k|		size_t tailSize = end - (const char*) tail; // The distance from the beginning of the word containing @p end to the @p end
  195|       |
  196|   100k|		Y_ASSERT(headSize >= 1 && headSize <= sizeof(size_t));
  197|   100k|		Y_ASSERT(tailSize < sizeof(size_t));
  198|       |
  199|   100k|		if (head == tail) {
  200|  7.91k|			Impl::SafeRunChunk(scanner, st, head, sizeof(size_t) - headSize, end - begin, pred);
  201|  7.91k|			return;
  202|  7.91k|		}
  203|       |
  204|       |		// st is passed by reference to this function. If we use it directly on each step the compiler will have to
  205|       |		// update it in memory because of pointer aliasing assumptions. Copying it into a local var allows the
  206|       |		// compiler to store it in a register. This saves some instructions and cycles
  207|  92.0k|		typename Scanner::State state = st;
  208|       |
  209|  92.0k|		if (begin != (const char*) head) {
  210|      0|			if (Impl::RunChunk(scanner, state, head, sizeof(size_t) - headSize, headSize, pred) == Stop) {
  211|      0|				st = state;
  212|      0|				return;
  213|      0|			}
  214|      0|			++head;
  215|      0|		}
  216|       |
  217|  92.0k|		if (Impl::AlignedRunner<Scanner>::RunAligned(scanner, state, head, tail, pred) == Stop) {
  218|      0|			st = state;
  219|      0|			return;
  220|      0|		}
  221|       |
  222|  92.0k|		if (tailSize)
  223|  72.3k|			Impl::SafeRunChunk(scanner, state, tail, 0, tailSize, pred);
  224|       |
  225|  92.0k|		st = state;
  226|  92.0k|	}
  227|       |
  228|       |}
  229|       |
  230|       |/// Runs two scanners through given memory range simultaneously.
  231|       |/// This is several percent faster than running them independently.
  232|       |template<class Scanner1, class Scanner2>
  233|       |inline void Run(const Scanner1& scanner1, const Scanner2& scanner2, typename Scanner1::State& state1, typename Scanner2::State& state2, const char* begin, const char* end)
  234|       |{
  235|       |	typedef ScannerPair<Scanner1, Scanner2> Scanners;
  236|       |	Scanners pair(scanner1, scanner2);
  237|       |	typename Scanners::State states(state1, state2);
  238|       |	Run(pair, states, begin, end);
  239|       |	state1 = states.first;
  240|       |	state2 = states.second;
  241|       |}
  242|       |
  243|       |#else
  244|       |
  245|       |namespace Impl {
  246|       |	/// A debug version of all Run() methods.
  247|       |	template<class Scanner, class Pred>
  248|       |	inline void DoRun(const Scanner& scanner, typename Scanner::State& state, const char* begin, const char* end, Pred pred)
  249|       |	{
  250|       |		Cdbg << "Running regexp on string " << ystring(begin, ymin(end - begin, static_cast<ptrdiff_t>(100u))) << Endl;
  251|       |		Cdbg << "Initial state " << StDump(scanner, state) << Endl;
  252|       |
  253|       |		if (pred(scanner, state, begin) == Stop) {
  254|       |			Cdbg << " exiting" << Endl;
  255|       |			return;
  256|       |		}
  257|       |
  258|       |		for (; begin != end; ++begin) {
  259|       |			Step(scanner, state, (unsigned char)*begin);
  260|       |			Cdbg << *begin << " => state " << StDump(scanner, state) << Endl;
  261|       |			if (pred(scanner, state, begin + 1) == Stop) {
  262|       |				Cdbg << " exiting" << Endl;
  263|       |				return;
  264|       |			}
  265|       |		}
  266|       |	}
  267|       |}
  268|       |
  269|       |#endif
  270|       |	
  271|       |template<class Scanner>
  272|       |void Run(const Scanner& sc, typename Scanner::State& st, const char* begin, const char* end)
  273|   100k|{
  274|   100k|	Impl::DoRun(sc, st, begin, end, Impl::RunPred<Scanner>());
  275|   100k|}
  276|       |
  277|       |template<class Scanner>
  278|       |const char* LongestPrefix(const Scanner& sc, const char* begin, const char* end, bool throughBeginMark = false, bool throughEndMark = false)
  279|       |{
  280|       |	typename Scanner::State st;
  281|       |	sc.Initialize(st);
  282|       |	if (throughBeginMark)
  283|       |		Pire::Step(sc, st, BeginMark);
  284|       |	const char* pos = (sc.Final(st) ? begin : 0);
  285|       |	Impl::DoRun(sc, st, begin, end, Impl::LongestPrefixPred<Scanner>(pos));
  286|       |	if (throughEndMark) {
  287|       |		Pire::Step(sc, st, EndMark);
  288|       |		if (sc.Final(st))
  289|       |			pos = end;
  290|       |	}
  291|       |	return pos;
  292|       |}
  293|       |
  294|       |template<class Scanner>
  295|       |const char* ShortestPrefix(const Scanner& sc, const char* begin, const char* end, bool throughBeginMark = false, bool throughEndMark = false)
  296|       |{
  297|       |	typename Scanner::State st;
  298|       |	sc.Initialize(st);
  299|       |	if (throughBeginMark)
  300|       |		Pire::Step(sc, st, BeginMark);
  301|       |	if (sc.Final(st))
  302|       |		return begin;
  303|       |	const char* pos = 0;
  304|       |	Impl::DoRun(sc, st, begin, end, Impl::ShortestPrefixPred<Scanner>(pos));
  305|       |	if (throughEndMark) {
  306|       |		Pire::Step(sc, st, EndMark);
  307|       |		if (sc.Final(st) && pos == 0)
  308|       |			pos = end;
  309|       |	}
  310|       |	return pos;
  311|       |}
  312|       |
  313|       |	
  314|       |/// The same as above, but scans string in reverse direction
  315|       |/// (consider using Fsm::Reverse() for using in this function).
  316|       |template<class Scanner>
  317|       |inline const char* LongestSuffix(const Scanner& scanner, const char* rbegin, const char* rend, bool throughEndMark = false, bool throughBeginMark = false)
  318|       |{
  319|       |	typename Scanner::State state;
  320|       |	scanner.Initialize(state);
  321|       |	if (throughEndMark)
  322|       |		Step(scanner, state, EndMark);
  323|       |	PIRE_IFDEBUG(Cdbg << "Running LongestSuffix on string " << ystring(rbegin - ymin(rbegin - rend, static_cast<ptrdiff_t>(100u)) + 1, rbegin + 1) << Endl);
  324|       |	PIRE_IFDEBUG(Cdbg << "Initial state " << StDump(scanner, state) << Endl);
  325|       |
  326|       |	const char* pos = 0;
  327|       |	while (rbegin != rend && !scanner.Dead(state)) {
  328|       |		if (scanner.Final(state))
  329|       |			pos = rbegin;
  330|       |		Step(scanner, state, (unsigned char)*rbegin);
  331|       |		PIRE_IFDEBUG(Cdbg << *rbegin << " => state " << StDump(scanner, state) << Endl);
  332|       |		--rbegin;
  333|       |	}
  334|       |	if (scanner.Final(state))
  335|       |		pos = rbegin;
  336|       |	if (throughBeginMark) {
  337|       |		Step(scanner, state, BeginMark);
  338|       |		if (scanner.Final(state))
  339|       |			pos = rbegin;
  340|       |	}
  341|       |	return pos;
  342|       |}
  343|       |
  344|       |/// The same as above, but scans string in reverse direction
  345|       |template<class Scanner>
  346|       |inline const char* ShortestSuffix(const Scanner& scanner, const char* rbegin, const char* rend, bool throughEndMark = false, bool throughBeginMark = false)
  347|       |{
  348|       |	typename Scanner::State state;
  349|       |	scanner.Initialize(state);
  350|       |	if (throughEndMark)
  351|       |		Step(scanner, state, EndMark);
  352|       |	PIRE_IFDEBUG(Cdbg << "Running ShortestSuffix on string " << ystring(rbegin - ymin(rbegin - rend, static_cast<ptrdiff_t>(100u)) + 1, rbegin + 1) << Endl);
  353|       |	PIRE_IFDEBUG(Cdbg << "Initial state " << StDump(scanner, state) << Endl);
  354|       |
  355|       |	for (; rbegin != rend && !scanner.Final(state) && !scanner.Dead(state); --rbegin) {
  356|       |		scanner.Next(state, (unsigned char)*rbegin);
  357|       |		PIRE_IFDEBUG(Cdbg << *rbegin << " => state " << StDump(scanner, state) << Endl);
  358|       |	}
  359|       |	if (throughBeginMark)
  360|       |		Step(scanner, state, BeginMark);
  361|       |	return scanner.Final(state) ? rbegin : 0;
  362|       |}
  363|       |
  364|       |
  365|       |template<class Scanner>
  366|       |class RunHelper {
  367|       |public:
  368|       |	RunHelper(const Scanner& sc, typename Scanner::State st): Sc(&sc), St(st) {}
  369|   100k|	explicit RunHelper(const Scanner& sc): Sc(&sc) { Sc->Initialize(St); }
  370|       |
  371|   200k|	RunHelper<Scanner>& Step(Char letter) { Pire::Step(*Sc, St, letter); return *this; }
  372|   100k|	RunHelper<Scanner>& Run(const char* begin, const char* end) { Pire::Run(*Sc, St, begin, end); return *this; }
  373|   100k|	RunHelper<Scanner>& Run(const char* str, size_t size) { return Run(str, str + size); }
  374|       |	RunHelper<Scanner>& Run(const ystring& str) { return Run(str.c_str(), str.c_str() + str.size()); }
  375|   100k|	RunHelper<Scanner>& Begin() { return Step(BeginMark); }
  376|   100k|	RunHelper<Scanner>& End() { return Step(EndMark); }
  377|       |
  378|       |	const typename Scanner::State& State() const { return St; }
  379|       |	struct Tag {};
  380|   100k|	operator const Tag*() const { return Sc->Final(St) ? (const Tag*) this : 0; }
  381|       |	bool operator ! () const { return !Sc->Final(St); }
  382|       |
  383|       |private:
  384|       |	const Scanner* Sc;
  385|       |	typename Scanner::State St;
  386|       |};
  387|       |
  388|       |template<class Scanner>
  389|   100k|RunHelper<Scanner> Runner(const Scanner& sc) { return RunHelper<Scanner>(sc); }
  390|       |
  391|       |template<class Scanner>
  392|       |RunHelper<Scanner> Runner(const Scanner& sc, typename Scanner::State st) { return RunHelper<Scanner>(sc, st); }
  393|       |
  394|       |
  395|       |/// Provided for testing purposes and convinience
  396|       |template<class Scanner>
  397|       |bool Matches(const Scanner& scanner, const char* begin, const char* end)
  398|       |{
  399|       |	return Runner(scanner).Run(begin, end);
  400|       |}
  401|       |
  402|       |/// Constructs an inline scanner in one statement
  403|       |template<class Scanner>
  404|       |Scanner MmappedScanner(const char* ptr, size_t size)
  405|       |{
  406|       |	Scanner s;
  407|       |	s.Mmap(ptr, size);
  408|       |	return s;
  409|       |}
  410|       |
  411|       |}
  412|       |
  413|       |#endif

/home/johnpaul/pire/pire/scanners/common.h:
    1|       |/*
    2|       | * common.h -- common declaration for Pire scanners
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |#ifndef PIRE_SCANNERS_COMMON_H_INCLUDED
   24|       |#define PIRE_SCANNERS_COMMON_H_INCLUDED
   25|       |
   26|       |#include <stdlib.h>
   27|       |#include "../align.h"
   28|       |#include "../stub/defaults.h"
   29|       |#include "../defs.h"
   30|       |#include "../platform.h"
   31|       |
   32|       |namespace Pire {
   33|       |	namespace ScannerIOTypes {
   34|       |		enum {
   35|       |			NoScanner = 0,
   36|       |			Scanner = 1,
   37|       |			SimpleScanner = 2,
   38|       |			SlowScanner = 3,
   39|       |			LoadedScanner = 4,
   40|       |			NoGlueLimitCountingScanner = 5,
   41|       |		};
   42|       |	}
   43|       |
   44|       |	struct Header {
   45|       |		ui32 Magic;
   46|       |		ui32 Version;
   47|       |		ui32 PtrSize;
   48|       |		ui32 MaxWordSize;
   49|       |		ui32 Type;
   50|       |		ui32 HdrSize;
   51|       |
   52|       |		static const ui32 MAGIC = 0x45524950;   // "PIRE" on litte-endian
   53|       |		static const ui32 RE_VERSION = 7;       // Should be incremented each time when the format of serialized scanner changes
   54|       |		static const ui32 RE_VERSION_WITH_MACTIONS = 6;  // LoadedScanner with m_actions, which is ignored
   55|       |
   56|       |		explicit Header(ui32 type, size_t hdrsize)
   57|       |			: Magic(MAGIC)
   58|       |			, Version(RE_VERSION)
   59|       |			, PtrSize(sizeof(void*))
   60|       |			, MaxWordSize(sizeof(Impl::MaxSizeWord))
   61|       |			, Type(type)
   62|       |			, HdrSize(hdrsize)
   63|      0|		{}
   64|       |
   65|       |		void Validate(ui32 type, size_t hdrsize) const
   66|      0|		{
   67|      0|			if (Magic != MAGIC || PtrSize != sizeof(void*) || MaxWordSize != sizeof(Impl::MaxSizeWord))
   68|      0|				throw Error("Serialized regexp incompatible with your system");
   69|      0|			if (Version != RE_VERSION && Version != RE_VERSION_WITH_MACTIONS)
   70|      0|				throw Error("You are trying to used an incompatible version of a serialized regexp");
   71|      0|			if (type != ScannerIOTypes::NoScanner && type != Type &&
   72|      0|			   !(type == ScannerIOTypes::LoadedScanner && Type == ScannerIOTypes::NoGlueLimitCountingScanner)) {
   73|      0|				throw Error("Serialized regexp incompatible with your system");
   74|      0|			}
   75|      0|			if (hdrsize != 0 && HdrSize != hdrsize)
   76|      0|				throw Error("Serialized regexp incompatible with your system");
   77|      0|		}
   78|       |	};
   79|       |
   80|       |	namespace Impl {
   81|       |		inline const void* AdvancePtr(const size_t*& ptr, size_t& size, size_t delta)
   82|      0|		{
   83|      0|			ptr = (const size_t*) ((const char*) ptr + delta);
   84|      0|			size -= delta;
   85|      0|			return (const void*) ptr;
   86|      0|		}
   87|       |
   88|       |		template<class T>
   89|       |		inline void MapPtr(T*& field, size_t count, const size_t*& p, size_t& size)
   90|      0|		{
   91|      0|			if (size < count * sizeof(*field))
   92|      0|				throw Error("EOF reached while mapping Pire::SlowScanner");
   93|      0|			field = (T*) p;
   94|      0|			Impl::AdvancePtr(p, size, count * sizeof(*field));
   95|      0|			Impl::AlignPtr(p, size);
   96|      0|		}
  ------------------
  | Unexecuted instantiation: _ZN4Pire4Impl6MapPtrIKNS_6HeaderEEEvRPT_mRPKmRm
  ------------------
  | Unexecuted instantiation: _ZN4Pire4Impl6MapPtrINS_11SlowScanner6LocalsEEEvRPT_mRPKmRm
  ------------------
  | Unexecuted instantiation: _ZN4Pire4Impl6MapPtrImEEvRPT_mRPKmRm
  ------------------
  | Unexecuted instantiation: _ZN4Pire4Impl6MapPtrIbEEvRPT_mRPKmRm
  ------------------
  | Unexecuted instantiation: _ZN4Pire4Impl6MapPtrIjEEvRPT_mRPKmRm
  ------------------
   97|       |
   98|       |		inline void CheckAlign(const void* ptr, size_t bound = sizeof(size_t))
   99|   100k|		{
  100|   100k|			if (!IsAligned(ptr, bound))
  101|      0|				throw Error("Tried to mmap scanner at misaligned address");
  102|   100k|		}
  103|       |
  104|       |		inline Header ValidateHeader(const size_t*& ptr, size_t& size, ui32 type, size_t hdrsize)
  105|      0|		{
  106|      0|			const Header* hdr;
  107|      0|			MapPtr(hdr, 1, ptr, size);
  108|      0|			hdr->Validate(type, hdrsize);
  109|      0|			return *hdr;
  110|      0|		}
  111|       |
  112|       |		inline Header ValidateHeader(yistream* s, ui32 type, size_t hdrsize)
  113|      0|		{
  114|      0|			Header hdr(ScannerIOTypes::NoScanner, 0);
  115|      0|			LoadPodType(s, hdr);
  116|      0|			AlignLoad(s, sizeof(hdr));
  117|      0|			hdr.Validate(type, hdrsize);
  118|      0|			return hdr;
  119|      0|		}
  120|       |	}
  121|       |}
  122|       |
  123|       |#endif

/home/johnpaul/pire/pire/scanners/half_final.h:
    1|       |#ifndef PIRE_SCANNERS_HALF_FINAL_H
    2|       |#define PIRE_SCANNERS_HALF_FINAL_H
    3|       |
    4|       |#include <string.h>
    5|       |#include "common.h"
    6|       |#include "multi.h"
    7|       |#include "../fsm.h"
    8|       |#include "../half_final_fsm.h"
    9|       |#include "../stub/stl.h"
   10|       |
   11|       |namespace Pire {
   12|       |
   13|       |namespace Impl {
   14|       |
   15|       |
   16|       |/*
   17|       | * A half final scanner -- the deterministic scanner having half-terminal states,
   18|       | * so it matches regexps in all terminal transitional states.
   19|       | *
   20|       | * The scanner can also count the number of substrings, that match each regexp. These substrings may intersect.
   21|       | *
   22|       | * Comparing it with scanner, it runs slower, but allows to glue significantly
   23|       | * larger number of scanners into one within the same size limits.
   24|       | *
   25|       | * The class is subclass of Scanner, having the same methods, but different state type.
   26|       | *
   27|       | * There are no restrictions for regexps and fsm's, for which it is built, but it
   28|       | * does not work properly if the matching text does not end with EndMark.
   29|       | *
   30|       | * For count to work correctly, the fsm should not be determined.
   31|       | */
   32|       |template<typename Relocation, typename Shortcutting>
   33|       |class HalfFinalScanner : public Scanner<Relocation, Shortcutting> {
   34|       |public:
   35|       |	typedef typename Impl::Scanner<Relocation, Shortcutting> Scanner;
   36|       |
   37|       |	HalfFinalScanner() : Scanner() {}
   38|       |
   39|       |	explicit HalfFinalScanner(Fsm fsm_, size_t distance = 0) {
   40|       |		if (distance) {
   41|       |			fsm_ = CreateApproxFsm(fsm_, distance);
   42|       |		}
   43|       |		HalfFinalFsm fsm(fsm_);
   44|       |		fsm.MakeScanner();
   45|       |		Scanner::Init(fsm.GetFsm().Size(), fsm.GetFsm().Letters(), fsm.GetFsm().Finals().size(), fsm.GetFsm().Initial(), 1);
   46|       |		BuildScanner(fsm.GetFsm(), *this);
   47|       |	}
   48|       |
   49|       |	explicit HalfFinalScanner(const HalfFinalFsm& fsm) {
   50|       |		Scanner::Init(fsm.GetFsm().Size(), fsm.GetFsm().Letters(), fsm.GetTotalCount(), fsm.GetFsm().Initial(), 1);
   51|       |		BuildScanner(fsm.GetFsm(), *this);
   52|       |		BuildFinals(fsm);
   53|       |	}
   54|       |
   55|       |	typedef typename Scanner::ScannerRowHeader ScannerRowHeader;
   56|       |	typedef typename Scanner::Action Action;
   57|       |
   58|       |	class State {
   59|       |	public:
   60|       |		typedef TVector<size_t>::const_iterator IdsIterator;
   61|       |
   62|       |		State() : ScannerState(0) {}
   63|       |
   64|       |		State(const typename Scanner::State& otherState) : ScannerState(otherState) {}
   65|       |
   66|       |		void GetMatchedRegexpsIds() {
   67|       |			MatchedRegexpsIds.clear();
   68|       |			for (size_t i = 0; i < MatchedRegexps.size(); i++) {
   69|       |				if (MatchedRegexps[i]) {
   70|       |					MatchedRegexpsIds.push_back(i);
   71|       |				}
   72|       |			}
   73|       |		}
   74|       |
   75|       |		IdsIterator IdsBegin() const {
   76|       |			return MatchedRegexpsIds.cbegin();
   77|       |		}
   78|       |
   79|       |		IdsIterator IdsEnd() const {
   80|       |			return MatchedRegexpsIds.cend();
   81|       |		}
   82|       |
   83|       |		bool operator==(const State& other) const {
   84|       |			return ScannerState == other.ScannerState && MatchedRegexps == other.MatchedRegexps;
   85|       |		}
   86|       |
   87|       |		bool operator!=(const State& other) const {
   88|       |			return ScannerState != other.ScannerState || MatchedRegexps != other.MatchedRegexps;
   89|       |		}
   90|       |
   91|       |		size_t Result(size_t regexp_id) const {
   92|       |			return MatchedRegexps[regexp_id];
   93|       |		}
   94|       |
   95|       |		void Save(yostream* s) const {
   96|       |			SavePodType(s, Pire::Header(5, sizeof(size_t)));
   97|       |			Impl::AlignSave(s, sizeof(Pire::Header));
   98|       |			auto stateSizePair = ymake_pair(ScannerState, MatchedRegexps.size());
   99|       |			SavePodType(s, stateSizePair);
  100|       |			Impl::AlignSave(s, sizeof(ypair<size_t, size_t>));
  101|       |			Y_ASSERT(0);
  102|       |		}
  103|       |
  104|       |		void Load(yistream* s) {
  105|       |			Impl::ValidateHeader(s, 5, sizeof(size_t));
  106|       |			ypair<size_t, size_t> stateSizePair;
  107|       |			LoadPodType(s, stateSizePair);
  108|       |			Impl::AlignLoad(s, sizeof(ypair<size_t, size_t>));
  109|       |			ScannerState = stateSizePair.first;
  110|       |			MatchedRegexps.clear();
  111|       |			MatchedRegexps.resize(stateSizePair.second);
  112|       |		}
  113|       |
  114|       |	private:
  115|       |		TVector<size_t> MatchedRegexpsIds;
  116|       |		typename Scanner::State ScannerState;
  117|       |		TVector<size_t> MatchedRegexps;
  118|       |
  119|       |		friend class HalfFinalScanner<Relocation, Shortcutting>;
  120|       |	};
  121|       |
  122|       |
  123|       |	/// Checks whether specified state is in any of the final sets
  124|       |	bool Final(const State& state) const { return Scanner::Final(state.ScannerState); }
  125|       |
  126|       |	/// Checks whether specified state is 'dead' (i.e. scanner will never
  127|       |	/// reach any final state from current one)
  128|       |	bool Dead(const State& state) const { return Scanner::Dead(state.ScannerState); }
  129|       |
  130|       |	typedef ypair<typename State::IdsIterator, typename State::IdsIterator> AcceptedRegexpsType;
  131|       |
  132|       |	AcceptedRegexpsType AcceptedRegexps(State& state) const {
  133|       |		state.GetMatchedRegexpsIds();
  134|       |		return ymake_pair(state.IdsBegin(), state.IdsEnd());
  135|       |	}
  136|       |
  137|       |	/// Returns an initial state for this scanner
  138|       |	void Initialize(State& state) const {
  139|       |		state.ScannerState = Scanner::m.initial;
  140|       |		state.MatchedRegexps.clear();
  141|       |		state.MatchedRegexps.resize(Scanner::m.regexpsCount);
  142|       |		TakeAction(state, 0);
  143|       |	}
  144|       |
  145|       |	Action NextTranslated(State& state, Char letter) const {
  146|       |		return Scanner::NextTranslated(state.ScannerState, letter);
  147|       |	}
  148|       |
  149|       |	/// Handles one character
  150|       |	Action Next(State& state, Char c) const {
  151|       |		return Scanner::NextTranslated(state.ScannerState, Scanner::Translate(c));
  152|       |	}
  153|       |
  154|       |	void TakeAction(State& state, Action) const {
  155|       |		if (Final(state)) {
  156|       |			size_t idx = StateIndex(state);
  157|       |			const size_t *it = Scanner::m_final + Scanner::m_finalIndex[idx];
  158|       |			while (*it != Scanner::End) {
  159|       |				state.MatchedRegexps[*it]++;
  160|       |				++it;
  161|       |			}
  162|       |		}
  163|       |	}
  164|       |
  165|       |	HalfFinalScanner(const HalfFinalScanner& s) : Scanner(s) {}
  166|       |
  167|       |	HalfFinalScanner(const Scanner& s) : Scanner(s) {}
  168|       |
  169|       |	HalfFinalScanner(HalfFinalScanner&& s) : Scanner(s) {}
  170|       |
  171|       |	HalfFinalScanner(Scanner&& s) : Scanner(s) {}
  172|       |
  173|       |	template<class AnotherRelocation>
  174|       |	HalfFinalScanner(const HalfFinalScanner<AnotherRelocation, Shortcutting>& s)
  175|       |			: Scanner(s) {}
  176|       |
  177|       |	template<class AnotherRelocation>
  178|       |	HalfFinalScanner(const Impl::Scanner<AnotherRelocation, Shortcutting>& s) : Scanner(s) {}
  179|       |
  180|      0|	void Swap(HalfFinalScanner& s) {
  181|      0|		Scanner::Swap(s);
  182|      0|	}
  ------------------
  | Unexecuted instantiation: _ZN4Pire4Impl16HalfFinalScannerINS0_11RelocatableENS0_9ExitMasksILm2EEEE4SwapERS5_
  ------------------
  | Unexecuted instantiation: _ZN4Pire4Impl16HalfFinalScannerINS0_14NonrelocatableENS0_9ExitMasksILm2EEEE4SwapERS5_
  ------------------
  183|       |
  184|       |	HalfFinalScanner& operator=(const HalfFinalScanner& s) {
  185|       |		HalfFinalScanner(s).Swap(*this);
  186|       |		return *this;
  187|       |	}
  188|       |
  189|       |	size_t StateIndex(const State& s) const {
  190|       |		return Scanner::StateIndex(s.ScannerState);
  191|       |	}
  192|       |
  193|       |	/**
  194|       |	 * Agglutinates two scanners together, producing a larger scanner.
  195|       |	 * Checking a string against that scanner effectively checks them against both agglutinated regexps
  196|       |	 * (detailed information about matched regexps can be obtained with AcceptedRegexps()).
  197|       |	 *
  198|       |	 * Returns default-constructed scanner in case of failure
  199|       |	 * (consult Scanner::Empty() to find out whether the operation was successful).
  200|       |	 */
  201|       |	static HalfFinalScanner Glue(const HalfFinalScanner& a, const HalfFinalScanner& b, size_t maxSize = 0) {
  202|       |		return Scanner::Glue(a, b, maxSize);
  203|       |	}
  204|       |
  205|       |	ScannerRowHeader& Header(const State& s) { return Scanner::Header(s.ScannerState); }
  206|       |
  207|       |	const ScannerRowHeader& Header(const State& s) const { return Scanner::Header(s.ScannerState); }
  208|       |
  209|       |private:
  210|       |	void BuildFinals(const HalfFinalFsm& fsm) {
  211|       |		Y_ASSERT(Scanner::m_buffer);
  212|       |		Y_ASSERT(fsm.GetFsm().Size() == Scanner::Size());
  213|       |		auto finalWriter = Scanner::m_final;
  214|       |		for (size_t state = 0; state < Scanner::Size(); ++state) {
  215|       |			Scanner::m_finalIndex[state] = finalWriter - Scanner::m_final;
  216|       |			for (size_t i = 0; i < fsm.GetCount(state); i++) {
  217|       |				*finalWriter++ = 0;
  218|       |			}
  219|       |			*finalWriter++ = static_cast<size_t>(-1);
  220|       |		}
  221|       |	}
  222|       |
  223|       |	template<class Scanner>
  224|       |	friend void Pire::BuildScanner(const Fsm&, Scanner&);
  225|       |
  226|       |	typedef State InternalState; // Needed for agglutination
  227|       |};
  228|       |
  229|       |}
  230|       |
  231|       |
  232|       |typedef Impl::HalfFinalScanner<Impl::Relocatable, Impl::ExitMasks<2> > HalfFinalScanner;
  233|       |typedef Impl::HalfFinalScanner<Impl::Relocatable, Impl::NoShortcuts> HalfFinalScannerNoMask;
  234|       |
  235|       |/**
  236|       | * Same as above, but does not allow relocation or mmap()-ing.
  237|       | * On the other hand, runs faster than HalfFinal.
  238|       | */
  239|       |typedef Impl::HalfFinalScanner<Impl::Nonrelocatable, Impl::ExitMasks<2> > NonrelocHalfFinalScanner;
  240|       |typedef Impl::HalfFinalScanner<Impl::Nonrelocatable, Impl::NoShortcuts> NonrelocHalfFinalScannerNoMask;
  241|       |
  242|       |}
  243|       |
  244|       |
  245|       |namespace std {
  246|      0|	inline void swap(Pire::HalfFinalScanner& a, Pire::HalfFinalScanner& b) {
  247|      0|		a.Swap(b);
  248|      0|	}
  249|       |
  250|      0|	inline void swap(Pire::NonrelocHalfFinalScanner& a, Pire::NonrelocHalfFinalScanner& b) {
  251|      0|		a.Swap(b);
  252|      0|	}
  253|       |}
  254|       |
  255|       |#endif

/home/johnpaul/pire/pire/scanners/multi.h:
    1|       |/*
    2|       | * multi.h -- definition of the Scanner
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | *
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#ifndef PIRE_SCANNERS_MULTI_H
   25|       |#define PIRE_SCANNERS_MULTI_H
   26|       |
   27|       |#include <cstring>
   28|       |#include <string.h>
   29|       |#include "common.h"
   30|       |#include "../approx_matching.h"
   31|       |#include "../stub/stl.h"
   32|       |#include "../fsm.h"
   33|       |#include "../partition.h"
   34|       |#include "../run.h"
   35|       |#include "../static_assert.h"
   36|       |#include "../stub/saveload.h"
   37|       |#include "../stub/lexical_cast.h"
   38|       |#include "../platform.h"
   39|       |#include "../glue.h"
   40|       |#include "../determine.h"
   41|       |
   42|       |namespace Pire {
   43|       |
   44|       |namespace Impl {
   45|       |
   46|      0|	inline static ssize_t SignExtend(i32 i) { return i; }
   47|       |	template<class T>
   48|       |	class ScannerGlueCommon;
   49|       |
   50|       |	template<class T>
   51|       |	class ScannerGlueTask;
   52|       |
   53|       |	// This strategy allows to mmap() saved representation of a scanner. This is achieved by
   54|       |	// storing shifts instead of addresses in the transition table.
   55|       |	struct Relocatable {
   56|       |		static const size_t Signature = 1;
   57|       |		// Please note that Transition size is hardcoded as 32 bits.
   58|       |		// This limits size of transition table to 4G, but compresses
   59|       |		// it twice compared to 64-bit transitions. In future Transition
   60|       |		// can be made a template parameter if this is a concern.
   61|       |		typedef ui32 Transition;
   62|       |
   63|       |		typedef const void* RetvalForMmap;
   64|       |
   65|      0|		static size_t Go(size_t state, Transition shift) { return state + SignExtend(shift); }
   66|      0|		static Transition Diff(size_t from, size_t to) { return static_cast<Transition>(to - from); }
   67|       |	};
   68|       |
   69|       |	// With this strategy the transition table stores addresses. This makes the scanner faster
   70|       |	// compared to mmap()-ed
   71|       |	struct Nonrelocatable {
   72|       |		static const size_t Signature = 2;
   73|       |		typedef size_t Transition;
   74|       |
   75|       |		// Generates a compile-time error if Scanner<Nonrelocatable>::Mmap()
   76|       |		// (which is unsupported) is mistakenly called
   77|       |		typedef struct {} RetvalForMmap;
   78|       |
   79|  20.5M|		static size_t Go(size_t /*state*/, Transition shift) { return shift; }
   80|  46.8M|		static Transition Diff(size_t /*from*/, size_t to) { return to; }
   81|       |	};
   82|       |
   83|       |
   84|       |// Scanner implementation parametrized by 
   85|       |//      - transition table representation strategy
   86|       |//      - strategy for fast forwarding through memory ranges
   87|       |template<class Relocation, class Shortcutting>
   88|       |class Scanner {
   89|       |protected:
   90|       |	enum {
   91|       |		 FinalFlag = 1,
   92|       |		 DeadFlag  = 2,
   93|       |		 Flags = FinalFlag | DeadFlag
   94|       |	};
   95|       |
   96|       |	static const size_t End = static_cast<size_t>(-1);
   97|       |
   98|       |public:
   99|       |	typedef typename Relocation::Transition Transition;
  100|       |
  101|       |	typedef ui16		Letter;
  102|       |	typedef ui32		Action;
  103|       |	typedef ui8		Tag;
  104|       |
  105|       |	/// Some properties of the particular state.
  106|       |	struct CommonRowHeader {
  107|       |		size_t Flags; ///< Holds FinalFlag, DeadFlag, etc...
  108|       |
  109|  2.60M|		CommonRowHeader(): Flags(0) {}
  110|       |
  111|       |		template <class OtherCommonRowHeader>
  112|       |		CommonRowHeader& operator =(const OtherCommonRowHeader& other)
  113|       |		{
  114|       |			Flags = other.Flags;
  115|       |			return *this;
  116|       |		}
  117|       |	};
  118|       |
  119|       |	typedef typename Shortcutting::template ExtendedRowHeader<Scanner> ScannerRowHeader;
  120|       |
  121|       |	Scanner() { Alias(Null()); }
  122|       |	
  123|       |	explicit Scanner(Fsm& fsm, size_t distance = 0)
  124|   100k|	{
  125|   100k|		if (distance) {
  126|      0|			fsm = CreateApproxFsm(fsm, distance);
  127|      0|		}
  128|   100k|		fsm.Canonize();
  129|   100k|		Init(fsm.Size(), fsm.Letters(), fsm.Finals().size(), fsm.Initial(), 1);
  130|   100k|		BuildScanner(fsm, *this);
  131|   100k|	}
  132|       |
  133|       |
  134|  8.10M|	size_t Size() const { return m.statesCount; }
  135|       |	bool Empty() const { return m_transitions == Null().m_transitions; }
  136|       |
  137|       |	typedef size_t State;
  138|       |
  139|       |	size_t RegexpsCount() const { return Empty() ? 0 : m.regexpsCount; }
  140|  8.80M|	size_t LettersCount() const { return m.lettersCount; }
  141|       |
  142|       |	/// Checks whether specified state is in any of the final sets
  143|   100k|	bool Final(const State& state) const { return (Header(state).Common.Flags & FinalFlag) != 0; }
  144|       |
  145|       |	/// Checks whether specified state is 'dead' (i.e. scanner will never
  146|       |	/// reach any final state from current one)
  147|       |	bool Dead(const State& state) const { return (Header(state).Common.Flags & DeadFlag) != 0; }
  148|       |
  149|       |	ypair<const size_t*, const size_t*> AcceptedRegexps(const State& state) const
  150|       |	{
  151|       |		size_t idx = (state - reinterpret_cast<size_t>(m_transitions)) /
  152|       |			(RowSize() * sizeof(Transition));
  153|       |		const size_t* b = m_final + m_finalIndex[idx];
  154|       |		const size_t* e = b;
  155|       |		while (*e != End)
  156|       |			++e;
  157|       |		return ymake_pair(b, e);
  158|       |	}
  159|       |
  160|       |	/// Returns an initial state for this scanner
  161|   100k|	void Initialize(State& state) const { state = m.initial; }
  162|       |
  163|       |	Char Translate(Char ch) const
  164|  14.5M|	{
  165|  14.5M|		return m_letters[static_cast<size_t>(ch)];
  166|  14.5M|	}
  167|       |
  168|       |	/// Handles one letter
  169|       |	Action NextTranslated(State& state, Char letter) const
  170|  14.5M|	{
  171|  14.5M|		PIRE_IFDEBUG(
  172|  14.5M|			Y_ASSERT(state >= (size_t)m_transitions);
  173|  14.5M|			Y_ASSERT(state < (size_t)(m_transitions + RowSize()*Size()));
  174|  14.5M|			Y_ASSERT((state - (size_t)m_transitions) % (RowSize()*sizeof(Transition)) == 0);
  175|  14.5M|		);
  176|       |
  177|  14.5M|		state = Relocation::Go(state, reinterpret_cast<const Transition*>(state)[letter]);
  178|       |
  179|  14.5M|		PIRE_IFDEBUG(
  180|  14.5M|			Y_ASSERT(state >= (size_t)m_transitions);
  181|  14.5M|			Y_ASSERT(state < (size_t)(m_transitions + RowSize()*Size()));
  182|  14.5M|			Y_ASSERT((state - (size_t)m_transitions) % (RowSize()*sizeof(Transition)) == 0);
  183|  14.5M|		);
  184|       |
  185|  14.5M|		return 0;
  186|  14.5M|	}
  187|       |
  188|       |	/// Handles one character
  189|       |	Action Next(State& state, Char c) const
  190|  14.5M|	{
  191|  14.5M|		return NextTranslated(state, Translate(c));
  192|  14.5M|	}
  193|       |
  194|  14.5M|	void TakeAction(State&, Action) const {}
  195|       |
  196|       |	Scanner(const Scanner& s): m(s.m)
  197|       |	{
  198|       |		if (!s.m_buffer) {
  199|       |			// Empty or mmap()-ed scanner
  200|       |			Alias(s);
  201|       |		} else {
  202|       |			// In-memory scanner
  203|       |			DeepCopy(s);
  204|       |		}
  205|       |	}
  206|       |
  207|       |	Scanner(Scanner&& s)
  208|       |	{
  209|       |		Alias(Null());
  210|       |		Swap(s);
  211|       |	}
  212|       |
  213|       |	template<class AnotherRelocation>
  214|       |	Scanner(const Scanner<AnotherRelocation, Shortcutting>& s)
  215|       |	{
  216|       |		if (s.Empty())
  217|       |			Alias(Null());
  218|       |		else
  219|       |			DeepCopy(s);
  220|       |	}
  221|       |
  222|       |	void Swap(Scanner& s)
  223|      0|	{
  224|      0|		Y_ASSERT(m.relocationSignature == s.m.relocationSignature);
  225|      0|		Y_ASSERT(m.shortcuttingSignature == s.m.shortcuttingSignature);
  226|      0|		DoSwap(m_buffer, s.m_buffer);
  227|      0|		DoSwap(m.statesCount, s.m.statesCount);
  228|      0|		DoSwap(m.lettersCount, s.m.lettersCount);
  229|      0|		DoSwap(m.regexpsCount, s.m.regexpsCount);
  230|      0|		DoSwap(m.initial, s.m.initial);
  231|      0|		DoSwap(m_letters, s.m_letters);
  232|      0|		DoSwap(m.finalTableSize, s.m.finalTableSize);
  233|      0|		DoSwap(m_final, s.m_final);
  234|      0|		DoSwap(m_finalIndex, s.m_finalIndex);
  235|      0|		DoSwap(m_transitions, s.m_transitions);
  236|      0|	}
  ------------------
  | Unexecuted instantiation: _ZN4Pire4Impl7ScannerINS0_11RelocatableENS0_9ExitMasksILm2EEEE4SwapERS5_
  ------------------
  | Unexecuted instantiation: _ZN4Pire4Impl7ScannerINS0_14NonrelocatableENS0_9ExitMasksILm2EEEE4SwapERS5_
  ------------------
  237|       |
  238|       |	Scanner& operator = (const Scanner& s) { Scanner(s).Swap(*this); return *this; }
  239|       |
  240|       |	/*
  241|       |	 * Constructs the scanner from mmap()-ed memory range, returning a pointer
  242|       |	 * to unconsumed part of the buffer.
  243|       |	 */
  244|       |	typename Relocation::RetvalForMmap Mmap(const void* ptr, size_t size)
  245|       |	{
  246|       |		Impl::CheckAlign(ptr, sizeof(size_t));
  247|       |		Scanner s;
  248|       |
  249|       |		const size_t* p = reinterpret_cast<const size_t*>(ptr);
  250|       |		Impl::ValidateHeader(p, size, ScannerIOTypes::Scanner, sizeof(m));
  251|       |		if (size < sizeof(s.m))
  252|       |			throw Error("EOF reached while mapping Pire::Scanner");
  253|       |
  254|       |		memcpy(&s.m, p, sizeof(s.m));
  255|       |		if (s.m.relocationSignature != Relocation::Signature)
  256|       |			throw Error("Type mismatch while mmapping Pire::Scanner");
  257|       |		Impl::AdvancePtr(p, size, sizeof(s.m));
  258|       |		Impl::AlignPtr(p, size);
  259|       |		
  260|       |		if (Shortcutting::Signature != s.m.shortcuttingSignature)
  261|       |			throw Error("This scanner has different shortcutting type");
  262|       |		
  263|       |		bool empty = *((const bool*) p);
  264|       |		Impl::AdvancePtr(p, size, sizeof(empty));
  265|       |		Impl::AlignPtr(p, size);
  266|       |		
  267|       |		if (empty)
  268|       |			s.Alias(Null());
  269|       |		else {
  270|       |			if (size < s.BufSize())
  271|       |				throw Error("EOF reached while mapping NPire::Scanner");
  272|       |			s.Markup(const_cast<size_t*>(p));
  273|       |			Impl::AdvancePtr(p, size, s.BufSize());
  274|       |			s.m.initial += reinterpret_cast<size_t>(s.m_transitions);
  275|       |		}
  276|       |
  277|       |		Swap(s);
  278|       |		return Impl::AlignPtr(p, size);
  279|       |	}
  280|       |
  281|       |	size_t StateIndex(State s) const
  282|       |	{
  283|       |		return (s - reinterpret_cast<size_t>(m_transitions)) / (RowSize() * sizeof(Transition));
  284|       |	}
  285|       |
  286|       |	/**
  287|       |	 * Agglutinates two scanners together, producing a larger scanner.
  288|       |	 * Checkig a string against that scanner effectively checks them against both agglutinated regexps
  289|       |	 * (detailed information about matched regexps can be obtained with AcceptedRegexps()).
  290|       |	 *
  291|       |	 * Returns default-constructed scanner in case of failure
  292|       |	 * (consult Scanner::Empty() to find out whether the operation was successful).
  293|       |	 */
  294|       |	static Scanner Glue(const Scanner& a, const Scanner& b, size_t maxSize = 0);
  295|       |
  296|       |	// Returns the size of the memory buffer used (or required) by scanner.
  297|       |	size_t BufSize() const
  298|   200k|	{
  299|   200k|		return AlignUp(
  300|   200k|			MaxChar * sizeof(Letter)                           // Letters translation table
  301|   200k|			+ m.finalTableSize * sizeof(size_t)                // Final table
  302|   200k|			+ m.statesCount * sizeof(size_t)                   // Final index
  303|   200k|			+ RowSize() * m.statesCount * sizeof(Transition),  // Transitions table
  304|   200k|		sizeof(size_t));
  305|   200k|	}
  306|       |
  307|       |	void Save(yostream*) const;
  308|       |	void Load(yistream*);
  309|       |
  310|  10.4M|	ScannerRowHeader& Header(State s) { return *(ScannerRowHeader*) s; }
  311|  2.88M|	const ScannerRowHeader& Header(State s) const { return *(const ScannerRowHeader*) s; }
  312|       |
  313|       |protected:
  314|       |
  315|       |	struct Locals {
  316|       |		ui32 statesCount;
  317|       |		ui32 lettersCount;
  318|       |		ui32 regexpsCount;
  319|       |		size_t initial;
  320|       |		ui32 finalTableSize;
  321|       |		size_t relocationSignature;
  322|       |		size_t shortcuttingSignature;
  323|       |	} m;
  324|       |
  325|       |	using BufferType = std::unique_ptr<char[]>;
  326|       |	BufferType m_buffer;
  327|       |	Letter* m_letters;
  328|       |
  329|       |	size_t* m_final;
  330|       |	size_t* m_finalIndex;
  331|       |
  332|       |	Transition* m_transitions;
  333|       |
  334|       |	// Only used to force Null() call during static initialization, when Null()::n can be
  335|       |	// initialized safely by compilers that don't support thread safe static local vars
  336|       |	// initialization
  337|       |	static const Scanner* m_null;
  338|       |
  339|       |	inline static const Scanner& Null()
  340|      1|	{
  341|      1|		static const Scanner n = Fsm::MakeFalse().Compile< Scanner<Relocation, Shortcutting> >();
  342|       |		// this comparison is only needed to make the compiler not completely throw away m_null 
  343|      1|		return (m_null == &n ? *m_null : n);
  344|      1|	}
  345|       |
  346|       |	// Returns transition row size in Transition's. Row size_in bytes should be a multiple of sizeof(MaxSizeWord)
  347|   151M|	size_t RowSize() const { return AlignUp(m.lettersCount + HEADER_SIZE, sizeof(MaxSizeWord)/sizeof(Transition)); }
  348|       |
  349|       |	static const size_t HEADER_SIZE = sizeof(ScannerRowHeader) / sizeof(Transition);
  350|       |	PIRE_STATIC_ASSERT(sizeof(ScannerRowHeader) % sizeof(Transition) == 0);
  351|       |
  352|       |	template<class Eq>
  353|       |	void Init(size_t states, const Partition<Char, Eq>& letters, size_t finalStatesCount, size_t startState, size_t regexpsCount = 1)
  354|   100k|	{
  355|   100k|		std::memset(&m, 0, sizeof(m));
  356|   100k|		m.relocationSignature = Relocation::Signature;
  357|   100k|		m.shortcuttingSignature = Shortcutting::Signature;
  358|   100k|		m.statesCount = states;
  359|   100k|		m.lettersCount = letters.Size();
  360|   100k|		m.regexpsCount = regexpsCount;
  361|   100k|		m.finalTableSize = finalStatesCount + states;
  362|       |
  363|   100k|		m_buffer = BufferType(new char[BufSize() + sizeof(size_t)]);
  364|   100k|		memset(m_buffer.get(), 0, BufSize() + sizeof(size_t));
  365|   100k|		Markup(AlignUp(m_buffer.get(), sizeof(size_t)));
  366|       |
  367|  2.70M|		for (size_t i = 0; i != Size(); ++i)
  368|  2.60M|			Header(IndexToState(i)) = ScannerRowHeader();
  369|       |
  370|   100k|		m.initial = reinterpret_cast<size_t>(m_transitions + startState * RowSize());
  371|       |
  372|       |		// Build letter translation table
  373|   100k|		for (auto&& letter : letters)
  374|  1.80M|			for (auto&& character : letter.second.second)
  375|  26.3M|				m_letters[character] = letter.second.first + HEADER_SIZE;
  376|   100k|	}
  377|       |
  378|       |	/*
  379|       |	 * Initializes pointers depending on buffer start, letters and states count
  380|       |	 */
  381|       |	void Markup(void* ptr)
  382|   100k|	{
  383|   100k|		Impl::CheckAlign(ptr, sizeof(size_t));
  384|   100k|		m_letters     = reinterpret_cast<Letter*>(ptr);
  385|   100k|		m_final	      = reinterpret_cast<size_t*>(m_letters + MaxChar);
  386|   100k|		m_finalIndex  = reinterpret_cast<size_t*>(m_final + m.finalTableSize);
  387|   100k|		m_transitions = reinterpret_cast<Transition*>(m_finalIndex + m.statesCount);
  388|   100k|	}
  389|       |
  390|       |	// Makes a shallow ("weak") copy of the given scanner.
  391|       |	// The copied scanner does not maintain lifetime of the original's entrails.
  392|       |	void Alias(const Scanner<Relocation, Shortcutting>& s)
  393|      0|	{
  394|      0|		memcpy(&m, &s.m, sizeof(m));
  395|      0|		m_buffer.reset();
  396|      0|		m_letters = s.m_letters;
  397|      0|		m_final = s.m_final;
  398|      0|		m_finalIndex = s.m_finalIndex;
  399|      0|		m_transitions = s.m_transitions;
  400|      0|	}
  401|       |	
  402|       |	template<class AnotherRelocation>
  403|       |	void DeepCopy(const Scanner<AnotherRelocation, Shortcutting>& s)
  404|       |	{
  405|       |		// Don't want memory leaks, but we cannot free the buffer because there might be aliased instances
  406|       |		Y_ASSERT(m_buffer == nullptr);
  407|       |
  408|       |		// Ensure that specializations of Scanner across different Relocations do not touch its Locals
  409|       |		PIRE_STATIC_ASSERT(sizeof(m) == sizeof(s.m));
  410|       |		memcpy(&m, &s.m, sizeof(s.m));
  411|       |		m.relocationSignature = Relocation::Signature;
  412|       |		m.shortcuttingSignature = Shortcutting::Signature;
  413|       |		m_buffer = BufferType(new char[BufSize() + sizeof(size_t)]);
  414|       |		std::memset(m_buffer.get(), 0, BufSize() + sizeof(size_t));
  415|       |		Markup(AlignUp(m_buffer.get(), sizeof(size_t)));
  416|       |
  417|       |		// Values in letter-to-leterclass table take into account row header size
  418|       |		for (size_t c = 0; c < MaxChar; ++c) {
  419|       |			m_letters[c] = s.m_letters[c] - s.HEADER_SIZE + HEADER_SIZE;
  420|       |			Y_ASSERT(c == Epsilon || m_letters[c] >= HEADER_SIZE);
  421|       |			Y_ASSERT(c == Epsilon || m_letters[c] < RowSize());
  422|       |		}
  423|       |		memcpy(m_final, s.m_final, m.finalTableSize * sizeof(*m_final));
  424|       |		memcpy(m_finalIndex, s.m_finalIndex, m.statesCount * sizeof(*m_finalIndex));
  425|       |
  426|       |		m.initial = IndexToState(s.StateIndex(s.m.initial));
  427|       |
  428|       |		for (size_t st = 0; st != m.statesCount; ++st) {
  429|       |			size_t oldstate = s.IndexToState(st);
  430|       |			size_t newstate = IndexToState(st);
  431|       |			Header(newstate) = s.Header(oldstate);
  432|       |			const typename Scanner<AnotherRelocation, Shortcutting>::Transition* os
  433|       |				= reinterpret_cast<const typename Scanner<AnotherRelocation, Shortcutting>::Transition*>(oldstate);
  434|       |			Transition* ns = reinterpret_cast<Transition*>(newstate);
  435|       |
  436|       |			for (size_t let = 0; let != LettersCount(); ++let) {
  437|       |				size_t destIndex = s.StateIndex(AnotherRelocation::Go(oldstate, os[let + s.HEADER_SIZE]));
  438|       |				Transition tr = Relocation::Diff(newstate, IndexToState(destIndex));
  439|       |				ns[let + HEADER_SIZE] = tr;
  440|       |				Y_ASSERT(Relocation::Go(newstate, tr) >= (size_t)m_transitions);
  441|       |				Y_ASSERT(Relocation::Go(newstate, tr) < (size_t)(m_transitions + RowSize()*Size()));
  442|       |			}
  443|       |		}
  444|       |	}
  445|       |
  446|       |
  447|       |	size_t IndexToState(size_t stateIndex) const
  448|   104M|	{
  449|   104M|		return reinterpret_cast<size_t>(m_transitions + stateIndex * RowSize());
  450|   104M|	}
  451|       |
  452|       |	void SetJump(size_t oldState, Char c, size_t newState, unsigned long /*payload*/ = 0)
  453|  46.8M|	{
  454|  46.8M|		Y_ASSERT(m_buffer);
  455|  46.8M|		Y_ASSERT(oldState < m.statesCount);
  456|  46.8M|		Y_ASSERT(newState < m.statesCount);
  457|       |
  458|  46.8M|		m_transitions[oldState * RowSize() + m_letters[c]]
  459|  46.8M|			= Relocation::Diff(IndexToState(oldState), IndexToState(newState));
  460|  46.8M|	}
  461|       |
  462|  46.8M|	unsigned long RemapAction(unsigned long action) { return action; }
  463|       |
  464|       |	void SetInitial(size_t state)
  465|       |	{
  466|       |		Y_ASSERT(m_buffer);
  467|       |		m.initial = IndexToState(state);
  468|       |	}
  469|       |
  470|       |	void SetTag(size_t state, size_t value)
  471|  2.60M|	{
  472|  2.60M|		Y_ASSERT(m_buffer);
  473|  2.60M|		Header(IndexToState(state)).Common.Flags = value;
  474|  2.60M|	}
  475|       |
  476|       |	// Fill shortcut masks for all the states
  477|       |	void BuildShortcuts()
  478|   100k|	{
  479|   100k|		Y_ASSERT(m_buffer);
  480|       |
  481|       |		// Build the mapping from letter classes to characters
  482|   100k|		TVector< TVector<char> > letters(RowSize());
  483|  25.7M|		for (unsigned ch = 0; ch != 1 << (sizeof(char)*8); ++ch)
  484|  25.6M|			letters[m_letters[ch]].push_back(ch);
  485|       |
  486|       |		// Loop through all states in the transition table and
  487|       |		// check if it is possible to setup shortcuts
  488|  2.70M|		for (size_t i = 0; i != Size(); ++i) {
  489|  2.60M|			State st = IndexToState(i);
  490|  2.60M|			ScannerRowHeader& header = Header(st);
  491|  2.60M|			Shortcutting::SetNoExit(header);
  492|  2.60M|			size_t ind = 0;
  493|  2.60M|			size_t let = HEADER_SIZE;
  494|  6.20M|			for (; let != LettersCount() + HEADER_SIZE; ++let) {
  495|       |				// Check if the transition is not the same state
  496|  6.00M|				if (Relocation::Go(st, reinterpret_cast<const Transition*>(st)[let]) != st) {
  497|  2.50M|					if (ind + letters[let].size() > Shortcutting::ExitMaskCount)
  498|  2.40M|						break;
  499|       |					// For each character setup a mask
  500|   100k|					for (auto&& character : letters[let]) {
  501|   100k|						Shortcutting::SetMask(header, ind, character);
  502|   100k|						++ind;
  503|   100k|					}
  504|   100k|				}
  505|  6.00M|			}
  506|       |
  507|  2.60M|			if (let != LettersCount() + HEADER_SIZE) {
  508|       |				// Not enough space in ExitMasks, so reset all masks (which leads to bypassing the optimization)
  509|  2.40M|				Shortcutting::SetNoShortcut(header);
  510|  2.40M|			}
  511|       |			// Fill the rest of the shortcut masks with the last used mask
  512|  2.60M|			Shortcutting::FinishMasks(header, ind);
  513|  2.60M|		}
  514|   100k|	}
  515|       |
  516|       |	// Fills final states table and builds shortcuts if possible
  517|       |	void FinishBuild()
  518|   100k|	{
  519|   100k|		Y_ASSERT(m_buffer);
  520|   100k|		auto finalWriter = m_final;
  521|  2.70M|		for (size_t state = 0; state != Size(); ++state) {
  522|  2.60M|			m_finalIndex[state] = finalWriter - m_final;
  523|  2.60M|			if (Header(IndexToState(state)).Common.Flags & FinalFlag)
  524|   100k|				*finalWriter++ = 0;
  525|  2.60M|			*finalWriter++ = static_cast<size_t>(-1);
  526|  2.60M|		}
  527|   100k|		BuildShortcuts();
  528|   100k|	}
  529|       |
  530|       |	size_t AcceptedRegexpsCount(size_t idx) const
  531|       |	{
  532|       |		const size_t* b = m_final + m_finalIndex[idx];
  533|       |		const size_t* e = b;
  534|       |		while (*e != End)
  535|       |			++e;
  536|       |		return e - b;
  537|       |	}
  538|       |
  539|       |	template <class Scanner>
  540|       |	friend void Pire::BuildScanner(const Fsm&, Scanner&);
  541|       |
  542|       |	typedef State InternalState; // Needed for agglutination
  543|       |	friend class ScannerGlueCommon<Scanner>;
  544|       |	friend class ScannerGlueTask<Scanner>;
  545|       |
  546|       |	template<class AnotherRelocation, class AnotherShortcutting>
  547|       |	friend class Scanner;
  548|       |
  549|       |    friend struct ScannerSaver;
  550|       |
  551|       |#ifndef PIRE_DEBUG
  552|       |	friend struct AlignedRunner< Scanner<Relocation, Shortcutting> >;
  553|       |#endif
  554|       |};
  555|       |
  556|       |// Helper class for Save/Load partial specialization
  557|       |struct ScannerSaver {
  558|       |	template<class Shortcutting>
  559|       |	static void SaveScanner(const Scanner<Relocatable, Shortcutting>& scanner, yostream* s)
  560|       |	{
  561|       |		typedef Scanner<Relocatable, Shortcutting> ScannerType;
  562|       |
  563|       |		typename ScannerType::Locals mc = scanner.m;
  564|       |		mc.initial -= reinterpret_cast<size_t>(scanner.m_transitions);
  565|       |		SavePodType(s, Pire::Header(ScannerIOTypes::Scanner, sizeof(mc)));
  566|       |		Impl::AlignSave(s, sizeof(Pire::Header));
  567|       |		SavePodType(s, mc);
  568|       |		Impl::AlignSave(s, sizeof(mc));
  569|       |		SavePodType(s, scanner.Empty());
  570|       |		Impl::AlignSave(s, sizeof(scanner.Empty()));
  571|       |		if (!scanner.Empty())
  572|       |			Impl::AlignedSaveArray(s, scanner.m_buffer.get(), scanner.BufSize());
  573|       |	}
  574|       |
  575|       |	template<class Shortcutting>
  576|       |	static void LoadScanner(Scanner<Relocatable, Shortcutting>& scanner, yistream* s)
  577|       |	{
  578|       |		typedef Scanner<Relocatable, Shortcutting> ScannerType;
  579|       |
  580|       |		Scanner<Relocatable, Shortcutting> sc;
  581|       |		Impl::ValidateHeader(s, ScannerIOTypes::Scanner, sizeof(sc.m));
  582|       |		LoadPodType(s, sc.m);
  583|       |		Impl::AlignLoad(s, sizeof(sc.m));
  584|       |		if (Shortcutting::Signature != sc.m.shortcuttingSignature)
  585|       |			throw Error("This scanner has different shortcutting type");
  586|       |		bool empty;
  587|       |		LoadPodType(s, empty);
  588|       |		Impl::AlignLoad(s, sizeof(empty));
  589|       |		
  590|       |		if (empty) {
  591|       |			sc.Alias(ScannerType::Null());
  592|       |		} else {
  593|       |			sc.m_buffer = std::unique_ptr<char[]>(new char[sc.BufSize()]);
  594|       |			Impl::AlignedLoadArray(s, sc.m_buffer.get(), sc.BufSize());
  595|       |			sc.Markup(sc.m_buffer.get());
  596|       |			sc.m.initial += reinterpret_cast<size_t>(sc.m_transitions);
  597|       |		}
  598|       |		scanner.Swap(sc);
  599|       |	}
  600|       |
  601|       |	// TODO: implement more effective serialization
  602|       |	// of nonrelocatable scanner if necessary
  603|       |	
  604|       |	template<class Shortcutting>
  605|       |	static void SaveScanner(const Scanner<Nonrelocatable, Shortcutting>& scanner, yostream* s)
  606|       |	{
  607|       |		Scanner<Relocatable, Shortcutting>(scanner).Save(s);
  608|       |	}
  609|       |	
  610|       |	template<class Shortcutting>
  611|       |	static void LoadScanner(Scanner<Nonrelocatable, Shortcutting>& scanner, yistream* s)
  612|       |	{
  613|       |		Scanner<Relocatable, Shortcutting> rs;
  614|       |		rs.Load(s);
  615|       |		Scanner<Nonrelocatable, Shortcutting>(rs).Swap(scanner);
  616|       |	}
  617|       |};
  618|       |
  619|       |
  620|       |template<class Relocation, class Shortcutting>
  621|       |void Scanner<Relocation, Shortcutting>::Save(yostream* s) const
  622|       |{
  623|       |	ScannerSaver::SaveScanner(*this, s);
  624|       |}
  625|       |
  626|       |template<class Relocation, class Shortcutting>
  627|       |void Scanner<Relocation, Shortcutting>::Load(yistream* s)
  628|       |{
  629|       |	ScannerSaver::LoadScanner(*this, s);
  630|       |}
  631|       |
  632|       |template<class Relocation, class Shortcutting>
  633|       |const Scanner<Relocation, Shortcutting>* Scanner<Relocation, Shortcutting>::m_null = &Null();
  634|       |
  635|       |// Shortcutting policy that checks state exit masks
  636|       |template <size_t MaskCount>
  637|       |class ExitMasks {
  638|       |private:
  639|       |	enum {
  640|       |		NO_SHORTCUT_MASK = 1, // the state doesn't have shortcuts
  641|       |		NO_EXIT_MASK  =    2  // the state has only transtions to itself (we can stop the scan)
  642|       |	};
  643|       |	
  644|       |	template<class ScannerRowHeader, unsigned N>
  645|       |	struct MaskCheckerBase {
  646|       |		static PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
  647|       |		bool Check(const ScannerRowHeader& hdr, size_t alignOffset, Word chunk)
  648|  2.44M|		{
  649|  2.44M|			Word mask = CheckBytes(hdr.Mask(N, alignOffset), chunk);
  650|  2.44M|			for (int i = N-1; i >= 0; --i) {
  651|      0|				mask = Or(mask, CheckBytes(hdr.Mask(i, alignOffset), chunk));
  652|      0|			}
  653|  2.44M|			return !IsAnySet(mask);
  654|  2.44M|		}
  ------------------
  | _ZN4Pire4Impl9ExitMasksILm2EE15MaskCheckerBaseINS2_17ExtendedRowHeaderINS0_7ScannerINS0_14NonrelocatableES2_EEEELj0EE5CheckERKS8_mDv2_x:
  |  648|  2.44M|		{
  |  649|  2.44M|			Word mask = CheckBytes(hdr.Mask(N, alignOffset), chunk);
  |  650|  2.44M|			for (int i = N-1; i >= 0; --i) {
  |  651|      0|				mask = Or(mask, CheckBytes(hdr.Mask(i, alignOffset), chunk));
  |  652|      0|			}
  |  653|  2.44M|			return !IsAnySet(mask);
  |  654|  2.44M|		}
  ------------------
  | Unexecuted instantiation: _ZN4Pire4Impl9ExitMasksILm2EE15MaskCheckerBaseINS2_17ExtendedRowHeaderINS0_7ScannerINS0_14NonrelocatableES2_EEEELj1EE5CheckERKS8_mDv2_x
  ------------------
  655|       |	
  656|       |		static PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
  657|       |		const Word* DoRun(const ScannerRowHeader& hdr, size_t alignOffset, const Word* begin, const Word* end)
  658|   869k|		{
  659|  2.50M|			for (; begin != end && Check(hdr, alignOffset, ToLittleEndian(*begin)); ++begin) {}
  660|   869k|			return begin;
  661|   869k|		}
  ------------------
  | _ZN4Pire4Impl9ExitMasksILm2EE15MaskCheckerBaseINS2_17ExtendedRowHeaderINS0_7ScannerINS0_14NonrelocatableES2_EEEELj0EE5DoRunERKS8_mPKDv2_xSE_:
  |  658|   869k|		{
  |  659|  2.50M|			for (; begin != end && Check(hdr, alignOffset, ToLittleEndian(*begin)); ++begin) {}
  |  660|   869k|			return begin;
  |  661|   869k|		}
  ------------------
  | Unexecuted instantiation: _ZN4Pire4Impl9ExitMasksILm2EE15MaskCheckerBaseINS2_17ExtendedRowHeaderINS0_7ScannerINS0_14NonrelocatableES2_EEEELj1EE5DoRunERKS8_mPKDv2_xSE_
  ------------------
  662|       |	};
  663|       |	
  664|       |	template<class ScannerRowHeader, unsigned N, unsigned Nmax>
  665|       |	struct MaskChecker : MaskCheckerBase<ScannerRowHeader, N>  {
  666|       |		typedef MaskCheckerBase<ScannerRowHeader, N> Base;
  667|       |		typedef MaskChecker<ScannerRowHeader, N+1, Nmax> Next;
  668|       |	
  669|       |		static PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
  670|       |		const Word* Run(const ScannerRowHeader& hdr, size_t alignOffset, const Word* begin, const Word* end)
  671|   869k|		{
  672|   869k|			if (hdr.Mask(N) == hdr.Mask(N + 1))
  673|   869k|				return Base::DoRun(hdr, alignOffset, begin, end);
  674|      0|			else
  675|      0|				return Next::Run(hdr, alignOffset, begin, end);
  676|   869k|		}
  677|       |	};
  678|       |	
  679|       |	template<class ScannerRowHeader, unsigned N>
  680|       |	struct MaskChecker<ScannerRowHeader, N, N> : MaskCheckerBase<ScannerRowHeader, N>  {
  681|       |		typedef MaskCheckerBase<ScannerRowHeader, N> Base;
  682|       |	
  683|       |		static PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
  684|       |		const Word* Run(const ScannerRowHeader& hdr, size_t alignOffset, const Word* begin, const Word* end)
  685|      0|		{
  686|      0|			return Base::DoRun(hdr, alignOffset, begin, end);
  687|      0|		}
  688|       |	};	
  689|       |
  690|       |	// Compares the ExitMask[0] value without SSE reads which seems to be more optimal
  691|       |	template <class Relocation>
  692|       |	static PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
  693|       |	bool CheckFirstMask(const Scanner<Relocation, ExitMasks<MaskCount> >& scanner, typename Scanner<Relocation, ExitMasks<MaskCount> >::State state, size_t val)
  694|  1.91M|	{
  695|  1.91M|		return (scanner.Header(state).Mask(0) == val);
  696|  1.91M|	}
  697|       |
  698|       |public:
  699|       |
  700|       |	static const size_t ExitMaskCount = MaskCount;
  701|       |	static const size_t Signature = 0x2000 + MaskCount;
  702|       |
  703|       |	template <class Scanner>
  704|       |	struct ExtendedRowHeader {
  705|       |	private:
  706|       |		/// In order to allow transition table to be aligned at sizeof(size_t) instead of
  707|       |		/// sizeof(Word) and still be able to read Masks at Word-aligned addresses each mask
  708|       |		/// occupies 2x space and only properly aligned part of it is read
  709|       |		enum {
  710|       |			SizeTInMaxSizeWord = sizeof(MaxSizeWord) / sizeof(size_t),
  711|       |			MaskSizeInSizeT = 2 * SizeTInMaxSizeWord,
  712|       |		};
  713|       |
  714|       |	public:	
  715|       |		static const size_t ExitMaskCount = MaskCount;
  716|       |
  717|       |		inline
  718|       |		const Word& Mask(size_t i, size_t alignOffset) const
  719|  2.44M|		{
  720|  2.44M|			Y_ASSERT(i < ExitMaskCount);
  721|  2.44M|			Y_ASSERT(alignOffset < SizeTInMaxSizeWord);
  722|  2.44M|			const Word* p = (const Word*)(ExitMasksArray + alignOffset + MaskSizeInSizeT * i);
  723|  2.44M|			Y_ASSERT(IsAligned(p, sizeof(Word)));
  724|  2.44M|			return *p;
  725|  2.44M|		}
  726|       |		
  727|       |		PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
  728|       |		size_t Mask(size_t i) const
  729|  6.25M|		{
  730|  6.25M|			Y_ASSERT(i < ExitMaskCount);
  731|  6.25M|			return ExitMasksArray[MaskSizeInSizeT*i];
  732|  6.25M|		}
  733|       |				
  734|       |		void SetMask(size_t i, size_t val)
  735|  12.9M|		{
  736|  64.5M|			for (size_t j = 0; j < MaskSizeInSizeT; ++j)
  737|  51.6M|				ExitMasksArray[MaskSizeInSizeT*i + j] = val;
  738|  12.9M|		}
  739|       |
  740|       |		ExtendedRowHeader()
  741|  2.60M|		{
  742|  7.80M|			for (size_t i = 0; i < ExitMaskCount; ++i)
  743|  5.20M|				SetMask(i, NO_SHORTCUT_MASK);
  744|  2.60M|		}
  745|       |		
  746|       |		template <class OtherScanner>
  747|       |		ExtendedRowHeader& operator =(const ExtendedRowHeader<OtherScanner>& other)
  748|       |		{
  749|       |			PIRE_STATIC_ASSERT(ExitMaskCount == ExtendedRowHeader<OtherScanner>::ExitMaskCount);
  750|       |			Common = other.Common;
  751|       |			for (size_t i = 0; i < ExitMaskCount; ++i)
  752|       |				SetMask(i, other.Mask(i));
  753|       |			return *this;
  754|       |		}
  755|       |
  756|       |	private:
  757|       |		/// If this state loops for all letters except particular set
  758|       |		/// (common thing when matching something like /.*[Aa]/),
  759|       |		/// each ExitMask contains that letter in each byte of size_t.
  760|       |		///
  761|       |		/// These masks are most commonly used for fast forwarding through parts
  762|       |		/// of the string matching /.*/ somewhere in the middle regexp.
  763|       |		size_t ExitMasksArray[ExitMaskCount * MaskSizeInSizeT];
  764|       |
  765|       |	public:
  766|       |		typename Scanner::CommonRowHeader Common;
  767|       |	};
  768|       |
  769|       |	template <class Header>
  770|       |	static void SetNoExit(Header& header)
  771|  2.60M|	{
  772|  2.60M|		header.SetMask(0, NO_EXIT_MASK);
  773|  2.60M|	}
  774|       |
  775|       |	template <class Header>
  776|       |	static void SetNoShortcut(Header& header)
  777|  2.40M|	{
  778|  2.40M|		header.SetMask(0, NO_SHORTCUT_MASK);
  779|  2.40M|	}
  780|       |
  781|       |	template <class Header>
  782|       |	static void SetMask(Header& header, size_t ind, char c)
  783|   100k|	{
  784|   100k|		header.SetMask(ind, FillSizeT(c));
  785|   100k|	}
  786|       |
  787|       |	template <class Header>
  788|       |	static void FinishMasks(Header& header, size_t ind)
  789|  2.60M|	{
  790|  2.60M|		if (ind == 0)
  791|  2.50M|			ind = 1;
  792|       |		// Fill the rest of the shortcut masks with the last used mask
  793|  2.60M|		size_t lastMask = header.Mask(ind - 1);
  794|  5.20M|		while (ind != ExitMaskCount) {
  795|  2.60M|			header.SetMask(ind, lastMask);
  796|  2.60M|			++ind;
  797|  2.60M|		}
  798|  2.60M|	}
  799|       |
  800|       |	template <class Relocation>
  801|       |	static PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
  802|       |	bool NoExit(const Scanner<Relocation, ExitMasks<MaskCount> >& scanner, typename Scanner<Relocation, ExitMasks<MaskCount> >::State state)
  803|   961k|	{
  804|   961k|		return CheckFirstMask(scanner, state, NO_EXIT_MASK);
  805|   961k|	}
  806|       |
  807|       |	template <class Relocation>
  808|       |	static PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
  809|       |	bool NoShortcut(const Scanner<Relocation, ExitMasks<MaskCount> >& scanner, typename Scanner<Relocation, ExitMasks<MaskCount> >::State state)
  810|   950k|	{
  811|   950k|		return CheckFirstMask(scanner, state, NO_SHORTCUT_MASK);
  812|   950k|	}
  813|       |
  814|       |	template <class Relocation>
  815|       |	static PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
  816|       |	const Word* Run(const Scanner<Relocation, ExitMasks<MaskCount> >& scanner, typename Scanner<Relocation, ExitMasks<MaskCount> >::State state, size_t alignOffset, const Word* begin, const Word* end)
  817|   869k|	{
  818|   869k|		return MaskChecker<typename Scanner<Relocation, ExitMasks<MaskCount> >::ScannerRowHeader, 0, MaskCount - 1>::Run(scanner.Header(state), alignOffset, begin, end);
  819|   869k|	}
  820|       |
  821|       |};
  822|       |
  823|       |
  824|       |// Shortcutting policy that doesn't do shortcuts
  825|       |struct NoShortcuts {
  826|       |
  827|       |	static const size_t ExitMaskCount = 0;
  828|       |	static const size_t Signature = 0x1000;
  829|       |
  830|       |	template <class Scanner>
  831|       |	struct ExtendedRowHeader {
  832|       |		typename Scanner::CommonRowHeader Common;
  833|       |
  834|       |		template <class OtherScanner>
  835|       |		ExtendedRowHeader& operator =(const ExtendedRowHeader<OtherScanner>& other)
  836|       |		{
  837|       |			PIRE_STATIC_ASSERT(sizeof(ExtendedRowHeader) == sizeof(ExtendedRowHeader<OtherScanner>));
  838|       |			Common = other.Common;
  839|       |			return *this;
  840|       |		}
  841|       |	};
  842|       |
  843|       |	template <class Header>
  844|       |	static void SetNoExit(Header&) {}
  845|       |
  846|       |	template <class Header>
  847|       |	static void SetNoShortcut(Header&) {}
  848|       |
  849|       |	template <class Header>
  850|       |	static void SetMask(Header&, size_t, char) {}
  851|       |
  852|       |	template <class Header>
  853|       |	static void FinishMasks(Header&, size_t) {}
  854|       |
  855|       |	template <class Relocation>
  856|       |	static PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
  857|       |	bool NoExit(const Scanner<Relocation, NoShortcuts>&, typename Scanner<Relocation, NoShortcuts>::State)
  858|       |	{
  859|       |		// Cannot exit prematurely
  860|       |		return false;
  861|       |	}
  862|       |
  863|       |	template <class Relocation>
  864|       |	static PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
  865|       |	bool NoShortcut(const Scanner<Relocation, NoShortcuts>&, typename Scanner<Relocation, NoShortcuts>::State)
  866|       |	{
  867|       |		// There's no shortcut regardless of the state
  868|       |		return true;
  869|       |	}
  870|       |
  871|       |	template <class Relocation>
  872|       |	static PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
  873|       |	const Word* Run(const Scanner<Relocation, NoShortcuts>&, typename Scanner<Relocation, NoShortcuts>::State, size_t, const Word* begin, const Word*)
  874|       |	{
  875|       |		// Stop shortcutting right at the beginning
  876|       |		return begin;
  877|       |	}
  878|       |};
  879|       |
  880|       |#ifndef PIRE_DEBUG
  881|       |
  882|       |// The purpose of this template is to produce a number of ProcessChunk() calls
  883|       |// instead of writing for(...){ProcessChunk()} loop that GCC refuses to unroll.
  884|       |// Manually unrolled code proves to be faster
  885|       |template <class Scanner, unsigned Count>
  886|       |struct MultiChunk {
  887|       |	// Process Word-sized chunk which consist of >=1 size_t-sized chunks
  888|       |	template<class Pred>
  889|       |	static PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
  890|       |	Action Process(const Scanner& scanner, typename Scanner::State& state, const size_t* p, Pred pred)
  891|  1.71M|	{
  892|  1.71M|		if (RunChunk(scanner, state, p, 0, sizeof(void*), pred) == Continue)
  893|  1.71M|			return MultiChunk<Scanner, Count-1>::Process(scanner, state, ++p, pred);
  894|      0|		else
  895|      0|			return Stop;
  896|  1.71M|	}
  ------------------
  | _ZN4Pire4Impl10MultiChunkINS0_7ScannerINS0_14NonrelocatableENS0_9ExitMasksILm2EEEEELj2EE7ProcessINS0_7RunPredIS6_EEEENS0_6ActionERKS6_RmPKmT_:
  |  891|   858k|	{
  |  892|   858k|		if (RunChunk(scanner, state, p, 0, sizeof(void*), pred) == Continue)
  |  893|   858k|			return MultiChunk<Scanner, Count-1>::Process(scanner, state, ++p, pred);
  |  894|      0|		else
  |  895|      0|			return Stop;
  |  896|   858k|	}
  ------------------
  | _ZN4Pire4Impl10MultiChunkINS0_7ScannerINS0_14NonrelocatableENS0_9ExitMasksILm2EEEEELj1EE7ProcessINS0_7RunPredIS6_EEEENS0_6ActionERKS6_RmPKmT_:
  |  891|   858k|	{
  |  892|   858k|		if (RunChunk(scanner, state, p, 0, sizeof(void*), pred) == Continue)
  |  893|   858k|			return MultiChunk<Scanner, Count-1>::Process(scanner, state, ++p, pred);
  |  894|      0|		else
  |  895|      0|			return Stop;
  |  896|   858k|	}
  ------------------
  897|       |};
  898|       |
  899|       |template <class Scanner>
  900|       |struct MultiChunk<Scanner, 0> {
  901|       |	// Process Word-sized chunk which consist of >=1 size_t-sized chunks
  902|       |	template<class Pred>
  903|       |	static PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
  904|       |	Action Process(const Scanner&, typename Scanner::State, const size_t*, Pred)
  905|   858k|	{
  906|   858k|		return Continue;
  907|   858k|	}
  908|       |};
  909|       |
  910|       |// Efficiently runs a scanner through size_t-aligned memory range
  911|       |template<class Relocation, class Shortcutting>
  912|       |struct AlignedRunner< Scanner<Relocation, Shortcutting> > {
  913|       |private:
  914|       |	typedef Scanner<Relocation, Shortcutting> ScannerType;
  915|       |
  916|       |	// Processes Word-sized chuck of memory (depending on the platform a Word might
  917|       |	// consist of multiple size_t chuncks)
  918|       |	template <class Pred>
  919|       |	static PIRE_FORCED_INLINE PIRE_HOT_FUNCTION
  920|       |	Action RunMultiChunk(const ScannerType& scanner, typename ScannerType::State& st, const size_t* begin, Pred pred)
  921|   858k|	{
  922|   858k|		return MultiChunk<ScannerType, sizeof(Word)/sizeof(size_t)>::Process(scanner, st, begin, pred);
  923|   858k|	}
  924|       |
  925|       |	// Asserts if the scanner changes state while processing the byte range that is
  926|       |	// supposed to be skipped by a shortcut
  927|       |	static void ValidateSkip(const ScannerType& scanner, typename ScannerType::State st, const char* begin, const char* end)
  928|       |	{
  929|       |		typename ScannerType::State stateBefore = st;
  930|       |		for (const char* pos = begin; pos != end; ++pos) {
  931|       |			Step(scanner, st, (unsigned char)*pos);
  932|       |			Y_ASSERT(st == stateBefore);
  933|       |		}
  934|       |	}
  935|       |
  936|       |public:
  937|       |
  938|       |	template<class Pred>
  939|       |	static inline PIRE_HOT_FUNCTION
  940|       |	Action RunAligned(const ScannerType& scanner, typename ScannerType::State& st, const size_t* begin, const size_t* end , Pred pred)
  941|  92.0k|	{
  942|  92.0k|		typename ScannerType::State state = st;		
  943|  92.0k|		const Word* head = AlignUp((const Word*) begin, sizeof(Word));
  944|  92.0k|		const Word* tail = AlignDown((const Word*) end, sizeof(Word));
  945|  92.0k|		for (; begin != (const size_t*) head && begin != end; ++begin)
  946|      0|			if (RunChunk(scanner, state, begin, 0, sizeof(void*), pred) == Stop) {
  947|      0|				st = state;
  948|      0|				return Stop;
  949|      0|			}
  950|       |		
  951|  92.0k|		if (begin == end) {
  952|      0|			st = state;
  953|      0|			return Continue;
  954|      0|		}
  955|  92.0k|		if (Shortcutting::NoExit(scanner, state)) {
  956|      0|			st = state;
  957|      0|			return pred(scanner, state, ((const char*) end));
  958|      0|		}
  959|       |		
  960|       |		// Row size should be a multiple of MaxSizeWord size. Then alignOffset is the same for any state
  961|  92.0k|		Y_ASSERT((scanner.RowSize()*sizeof(typename ScannerType::Transition)) % sizeof(MaxSizeWord) == 0);
  962|  92.0k|		size_t alignOffset = (AlignUp((size_t)scanner.m_transitions, sizeof(Word)) - (size_t)scanner.m_transitions) / sizeof(size_t);
  963|       |
  964|  92.0k|		bool noShortcut = Shortcutting::NoShortcut(scanner, state);
  965|       |
  966|   961k|		while (true) {
  967|       |			// Do normal processing until a shortcut is possible
  968|  1.82M|			while (noShortcut && head != tail) {
  969|   858k|				if (RunMultiChunk(scanner, state, (const size_t*)head, pred) == Stop) {
  970|      0|					st = state;
  971|      0|					return Stop;
  972|      0|				}
  973|   858k|				++head;
  974|   858k|				noShortcut = Shortcutting::NoShortcut(scanner, state);
  975|   858k|			}
  976|   961k|			if (head == tail)
  977|  92.0k|				break;
  978|       |
  979|   869k|			if (Shortcutting::NoExit(scanner, state)) {
  980|      0|				st = state;
  981|      0|				return pred(scanner, state, ((const char*) end));
  982|      0|			}
  983|       |
  984|       |			// Do fast forwarding while it is possible
  985|   869k|			const Word* skipEnd = Shortcutting::Run(scanner, state, alignOffset, head, tail);
  986|   869k|			PIRE_IF_CHECKED(ValidateSkip(scanner, state, (const char*)head, (const char*)skipEnd));
  987|   869k|			head = skipEnd;
  988|   869k|			noShortcut = true;
  989|   869k|		}
  990|       |		
  991|   134k|		for (size_t* p = (size_t*) tail; p != end; ++p) {
  992|  42.8k|			if (RunChunk(scanner, state, p, 0, sizeof(void*), pred) == Stop) {
  993|      0|				st = state;
  994|      0|				return Stop;
  995|      0|			}
  996|  42.8k|		}
  997|       |		
  998|  92.0k|		st = state;
  999|  92.0k|		return Continue;
 1000|  92.0k|	}
 1001|       |};
 1002|       |
 1003|       |#endif
 1004|       |
 1005|       |template<class Scanner>
 1006|       |class ScannerGlueTask: public ScannerGlueCommon<Scanner> {
 1007|       |public:
 1008|       |	typedef ScannerGlueCommon<Scanner> Base;
 1009|       |	typedef typename Base::State State;
 1010|       |	using Base::Lhs;
 1011|       |	using Base::Rhs;
 1012|       |	using Base::Sc;
 1013|       |	using Base::Letters;
 1014|       |
 1015|       |	typedef GluedStateLookupTable<256*1024, typename Scanner::State> InvStates;
 1016|       |	
 1017|       |	ScannerGlueTask(const Scanner& lhs, const Scanner& rhs)
 1018|       |		: ScannerGlueCommon<Scanner>(lhs, rhs, LettersEquality<Scanner>(lhs.m_letters, rhs.m_letters))
 1019|       |	{
 1020|       |	}
 1021|       |	
 1022|       |	void AcceptStates(const TVector<State>& states)
 1023|       |	{
 1024|       |		// Make up a new scanner and fill in the final table
 1025|       |		
 1026|       |		size_t finalTableSize = 0;
 1027|       |		for (auto&& i : states)
 1028|       |			finalTableSize += RangeLen(Lhs().AcceptedRegexps(i.first)) + RangeLen(Rhs().AcceptedRegexps(i.second));
 1029|       |		this->SetSc(std::unique_ptr<Scanner>(new Scanner));
 1030|       |		Sc().Init(states.size(), Letters(), finalTableSize, size_t(0), Lhs().RegexpsCount() + Rhs().RegexpsCount());
 1031|       |
 1032|       |		auto finalWriter = Sc().m_final;
 1033|       |		for (size_t state = 0; state != states.size(); ++state) {
 1034|       |			Sc().m_finalIndex[state] = finalWriter - Sc().m_final;
 1035|       |			finalWriter = Shift(Lhs().AcceptedRegexps(states[state].first), 0, finalWriter);
 1036|       |			finalWriter = Shift(Rhs().AcceptedRegexps(states[state].second), Lhs().RegexpsCount(), finalWriter);
 1037|       |			*finalWriter++ = static_cast<size_t>(-1);
 1038|       |			
 1039|       |			Sc().SetTag(state, ((Lhs().Final(states[state].first) || Rhs().Final(states[state].second)) ? Scanner::FinalFlag : 0)
 1040|       |				| ((Lhs().Dead(states[state].first) && Rhs().Dead(states[state].second)) ? Scanner::DeadFlag : 0));
 1041|       |		}
 1042|       |	}
 1043|       |	
 1044|       |	void Connect(size_t from, size_t to, Char letter) { Sc().SetJump(from, letter, to); }
 1045|       |
 1046|       |	const Scanner& Success()
 1047|       |	{
 1048|       |		Sc().BuildShortcuts();
 1049|       |		return Sc();
 1050|       |	}
 1051|       |	
 1052|       |private:
 1053|       |	template<class Iter>
 1054|       |	size_t RangeLen(ypair<Iter, Iter> range) const
 1055|       |	{
 1056|       |		return std::distance(range.first, range.second);
 1057|       |	}
 1058|       |
 1059|       |	template<class Iter, class OutIter>
 1060|       |	OutIter Shift(ypair<Iter, Iter> range, size_t shift, OutIter out) const
 1061|       |	{
 1062|       |		for (; range.first != range.second; ++range.first, ++out)
 1063|       |			*out = *range.first + shift;
 1064|       |		return out;
 1065|       |	}
 1066|       |};
 1067|       |
 1068|       |}
 1069|       |
 1070|       |
 1071|       |template<class Relocation, class Shortcutting>
 1072|       |struct StDumper< Impl::Scanner<Relocation, Shortcutting> > {
 1073|       |
 1074|       |	typedef Impl::Scanner<Relocation, Shortcutting> ScannerType;
 1075|       |
 1076|       |	StDumper(const ScannerType& sc, typename ScannerType::State st): m_sc(&sc), m_st(st) {}
 1077|       |
 1078|       |	void Dump(yostream& stream) const
 1079|       |	{
 1080|       |		stream << m_sc->StateIndex(m_st);
 1081|       |		if (m_sc->Final(m_st))
 1082|       |			stream << " [final]";
 1083|       |		if (m_sc->Dead(m_st))
 1084|       |			stream << " [dead]";
 1085|       |	}
 1086|       |private:
 1087|       |	const ScannerType* m_sc;
 1088|       |	typename ScannerType::State m_st;
 1089|       |};
 1090|       |
 1091|       |
 1092|       |template<class Relocation, class Shortcutting>
 1093|       |Impl::Scanner<Relocation, Shortcutting> Impl::Scanner<Relocation, Shortcutting>::Glue(const Impl::Scanner<Relocation, Shortcutting>& lhs, const Impl::Scanner<Relocation, Shortcutting>& rhs, size_t maxSize /* = 0 */)
 1094|       |{
 1095|       |	if (lhs.Empty())
 1096|       |		return rhs;
 1097|       |	if (rhs.Empty())
 1098|       |		return lhs;
 1099|       |	
 1100|       |	static const size_t DefMaxSize = 80000;
 1101|       |	Impl::ScannerGlueTask< Impl::Scanner<Relocation, Shortcutting> > task(lhs, rhs);
 1102|       |	return Impl::Determine(task, maxSize ? maxSize : DefMaxSize);
 1103|       |}
 1104|       |
 1105|       |
 1106|       |/**
 1107|       | * A compiled multiregexp.
 1108|       | * Can only find out whether a string matches the regexps or not,
 1109|       | * but takes O( str.length() ) time.
 1110|       | *
 1111|       | * In addition, multiple scanners can be agglutinated together,
 1112|       | * producting a scanner which can be used for checking
 1113|       | * strings against several regexps in a single pass.
 1114|       | */
 1115|       |typedef Impl::Scanner<Impl::Relocatable, Impl::ExitMasks<2> > Scanner;
 1116|       |typedef Impl::Scanner<Impl::Relocatable, Impl::NoShortcuts> ScannerNoMask;
 1117|       |
 1118|       |/**
 1119|       | * Same as above, but does not allow relocation or mmap()-ing.
 1120|       | * On the other hand, runs almost twice as fast as the Scanner.
 1121|       | */
 1122|       |typedef Impl::Scanner<Impl::Nonrelocatable, Impl::ExitMasks<2> > NonrelocScanner;
 1123|       |typedef Impl::Scanner<Impl::Nonrelocatable, Impl::NoShortcuts> NonrelocScannerNoMask;
 1124|       |
 1125|       |}
 1126|       |
 1127|       |namespace std {
 1128|      0|	inline void swap(Pire::Scanner& a, Pire::Scanner& b) {
 1129|      0|		a.Swap(b);
 1130|      0|	}
 1131|       |
 1132|      0|	inline void swap(Pire::NonrelocScanner& a, Pire::NonrelocScanner& b) {
 1133|      0|		a.Swap(b);
 1134|      0|	}
 1135|       |}
 1136|       |
 1137|       |
 1138|       |#endif

/home/johnpaul/pire/pire/scanners/simple.h:
    1|       |/*
    2|       | * simple.h -- the definition of the SimpleScanner
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#ifndef PIRE_SCANNERS_SIMPLE_H
   25|       |#define PIRE_SCANNERS_SIMPLE_H
   26|       |
   27|       |#include "common.h"
   28|       |#include "../approx_matching.h"
   29|       |#include "../stub/stl.h"
   30|       |#include "../stub/defaults.h"
   31|       |#include "../stub/saveload.h"
   32|       |
   33|       |namespace Pire {
   34|       |
   35|       |/**
   36|       | * More faster version than the Scanner, but incapable of storing multiple
   37|       | * regexps and taking more memory for the same regexp.
   38|       | */
   39|       |class SimpleScanner {
   40|       |private:
   41|       |	static const size_t STATE_ROW_SIZE = MaxChar + 1; // All characters + 1 element to store final state flag
   42|       |
   43|       |public:
   44|       |	typedef size_t      Transition;
   45|       |	typedef ui16        Letter;
   46|       |	typedef ui32        Action;
   47|       |	typedef ui8         Tag;
   48|       |
   49|      0|	SimpleScanner()	{ Alias(Null()); }
   50|       |	
   51|       |	explicit SimpleScanner(Fsm& fsm, size_t distance = 0);
   52|       |
   53|      0|	size_t Size() const { return m.statesCount; }
   54|      0|	bool Empty() const { return m_transitions == Null().m_transitions; }
   55|       |
   56|       |	typedef size_t State;
   57|       |
   58|      0|	size_t RegexpsCount() const { return Empty() ? 0 : 1; }
   59|      0|	size_t LettersCount() const { return MaxChar; }
   60|       |
   61|       |	/// Checks whether specified state is in any of the final sets
   62|      0|	bool Final(const State& state) const { return *(((const Transition*) state) - 1) != 0; }
   63|       |
   64|      0|	bool Dead(const State&) const { return false; }
   65|       |
   66|      0|	ypair<const size_t*, const size_t*> AcceptedRegexps(const State& s) const {
   67|      0|		return Final(s) ? Accept() : Deny();
   68|      0|	}
   69|       |
   70|       |	/// returns an initial state for this scanner
   71|      0|	void Initialize(State& state) const { state = m.initial; }
   72|       |
   73|       |	/// Handles one characters
   74|       |	Action Next(State& state, Char c) const
   75|      0|	{
   76|      0|		Transition shift = reinterpret_cast<const Transition*>(state)[c];
   77|      0|		state += shift;
   78|      0|		return 0;
   79|      0|	}
   80|       |
   81|      0|	bool TakeAction(State&, Action) const { return false; }
   82|       |
   83|       |	SimpleScanner(const SimpleScanner& s): m(s.m)
   84|      0|	{
   85|      0|		if (!s.m_buffer) {
   86|      0|			// Empty or mmap()-ed scanner, just copy pointers
   87|      0|			m_buffer = 0;
   88|      0|			m_transitions = s.m_transitions;
   89|      0|		} else {
   90|      0|			// In-memory scanner, perform deep copy
   91|      0|			m_buffer = BufferType(new char[BufSize()]);
   92|      0|			memcpy(m_buffer.get(), s.m_buffer.get(), BufSize());
   93|      0|			Markup(m_buffer.get());
   94|      0|
   95|      0|			m.initial += (m_transitions - s.m_transitions) * sizeof(Transition);
   96|      0|		}
   97|      0|	}
   98|       |	
   99|       |	// Makes a shallow ("weak") copy of the given scanner.
  100|       |	// The copied scanner does not maintain lifetime of the original's entrails.
  101|       |	void Alias(const SimpleScanner& s)
  102|      0|	{
  103|      0|		m = s.m;
  104|      0|		m_buffer.reset();
  105|      0|		m_transitions = s.m_transitions;
  106|      0|	}
  107|       |
  108|       |	void Swap(SimpleScanner& s)
  109|      0|	{
  110|      0|		DoSwap(m_buffer, s.m_buffer);
  111|      0|		DoSwap(m.statesCount, s.m.statesCount);
  112|      0|		DoSwap(m.initial, s.m.initial);
  113|      0|		DoSwap(m_transitions, s.m_transitions);
  114|      0|	}
  115|       |
  116|      0|	SimpleScanner& operator = (const SimpleScanner& s) { SimpleScanner(s).Swap(*this); return *this; }
  117|       |
  118|       |	/*
  119|       |	 * Constructs the scanner from mmap()-ed memory range, returning a pointer
  120|       |	 * to unconsumed part of the buffer.
  121|       |	 */
  122|       |	const void* Mmap(const void* ptr, size_t size)
  123|      0|	{
  124|      0|		Impl::CheckAlign(ptr);
  125|      0|		SimpleScanner s;
  126|      0|
  127|      0|		const size_t* p = reinterpret_cast<const size_t*>(ptr);
  128|      0|		Impl::ValidateHeader(p, size, ScannerIOTypes::SimpleScanner, sizeof(m));
  129|      0|		if (size < sizeof(s.m))
  130|      0|			throw Error("EOF reached while mapping NPire::Scanner");
  131|      0|
  132|      0|		memcpy(&s.m, p, sizeof(s.m));
  133|      0|		Impl::AdvancePtr(p, size, sizeof(s.m));
  134|      0|		Impl::AlignPtr(p, size);
  135|      0|
  136|      0|		bool empty = *((const bool*) p);
  137|      0|		Impl::AdvancePtr(p, size, sizeof(empty));
  138|      0|		Impl::AlignPtr(p, size);
  139|      0|		
  140|      0|		if (empty)
  141|      0|			s.Alias(Null());
  142|      0|		else {
  143|      0|			if (size < s.BufSize())
  144|      0|				throw Error("EOF reached while mapping NPire::Scanner");
  145|      0|			s.Markup(const_cast<size_t*>(p));
  146|      0|			s.m.initial += reinterpret_cast<size_t>(s.m_transitions);
  147|      0|
  148|      0|			Swap(s);
  149|      0|			Impl::AdvancePtr(p, size, BufSize());
  150|      0|		}
  151|      0|		return Impl::AlignPtr(p, size);
  152|      0|	}
  153|       |
  154|       |	size_t StateIndex(State s) const
  155|      0|	{
  156|      0|		return (s - reinterpret_cast<size_t>(m_transitions)) / (STATE_ROW_SIZE * sizeof(Transition));
  157|      0|	}
  158|       |
  159|       |	// Returns the size of the memory buffer used (or required) by scanner.
  160|       |	size_t BufSize() const
  161|      0|	{
  162|      0|		return STATE_ROW_SIZE * m.statesCount * sizeof(Transition); // Transitions table
  163|      0|	}
  164|       |
  165|       |	void Save(yostream*) const;
  166|       |	void Load(yistream*);
  167|       |
  168|       |protected:
  169|       |	struct Locals {
  170|       |		size_t statesCount;
  171|       |		size_t initial;
  172|       |	} m;
  173|       |
  174|       |	using BufferType = std::unique_ptr<char[]>;
  175|       |	BufferType m_buffer;
  176|       |
  177|       |	Transition* m_transitions;
  178|       |
  179|       |	// Only used to force Null() call during static initialization, when Null()::n can be
  180|       |	// initialized safely by compilers that don't support thread safe static local vars
  181|       |	// initialization
  182|       |	static const SimpleScanner* m_null;
  183|       |
  184|       |	inline static const SimpleScanner& Null()
  185|      0|	{
  186|      0|		static const SimpleScanner n = Fsm::MakeFalse().Compile<SimpleScanner>();
  187|      0|		return n;
  188|      0|	}
  189|       |
  190|       |	static ypair<const size_t*, const size_t*> Accept()
  191|      0|	{
  192|      0|		static size_t v[1] = { 0 };
  193|      0|		return ymake_pair(v, v + 1);
  194|      0|	}
  195|       |
  196|       |	static ypair<const size_t*, const size_t*> Deny()
  197|      0|	{
  198|      0|		static size_t v[1] = { 0 };
  199|      0|		return ymake_pair(v, v);
  200|      0|	}
  201|       |
  202|       |	/*
  203|       |	 * Initializes pointers depending on buffer start, letters and states count
  204|       |	 */
  205|       |	void Markup(void* ptr)
  206|      0|	{
  207|      0|		m_transitions = reinterpret_cast<Transition*>(ptr);
  208|      0|	}
  209|       |
  210|       |	void SetJump(size_t oldState, Char c, size_t newState)
  211|      0|	{
  212|      0|		Y_ASSERT(m_buffer);
  213|      0|		Y_ASSERT(oldState < m.statesCount);
  214|      0|		Y_ASSERT(newState < m.statesCount);
  215|      0|		m_transitions[oldState * STATE_ROW_SIZE + 1 + c]
  216|      0|			= (((newState - oldState) * STATE_ROW_SIZE) * sizeof(Transition));
  217|      0|	}
  218|       |
  219|      0|	unsigned long RemapAction(unsigned long action) { return action; }
  220|       |
  221|       |	void SetInitial(size_t state)
  222|      0|	{
  223|      0|		Y_ASSERT(m_buffer);
  224|      0|		m.initial = reinterpret_cast<size_t>(m_transitions + state * STATE_ROW_SIZE + 1);
  225|      0|	}
  226|       |
  227|       |	void SetTag(size_t state, size_t tag)
  228|      0|	{
  229|      0|		Y_ASSERT(m_buffer);
  230|      0|		m_transitions[state * STATE_ROW_SIZE] = tag;
  231|      0|	}
  232|       |
  233|       |};
  234|       |inline SimpleScanner::SimpleScanner(Fsm& fsm, size_t distance)
  235|       |{
  236|       |	if (distance) {
  237|       |		fsm = CreateApproxFsm(fsm, distance);
  238|       |	}
  239|       |	fsm.Canonize();
  240|       |	
  241|       |	m.statesCount = fsm.Size();
  242|       |	m_buffer = BufferType(new char[BufSize()]);
  243|       |	memset(m_buffer.get(), 0, BufSize());
  244|       |	Markup(m_buffer.get());
  245|       |	m.initial = reinterpret_cast<size_t>(m_transitions + fsm.Initial() * STATE_ROW_SIZE + 1);
  246|       |	for (size_t state = 0; state < fsm.Size(); ++state)
  247|       |		SetTag(state, fsm.Tag(state) | (fsm.IsFinal(state) ? 1 : 0));
  248|       |
  249|       |	for (size_t from = 0; from != fsm.Size(); ++from)
  250|       |		for (auto&& i : fsm.Letters()) {
  251|       |			const auto& tos = fsm.Destinations(from, i.first);
  252|       |			if (tos.empty())
  253|       |				continue;
  254|       |			for (auto&& l : i.second.second)
  255|       |				for (auto&& to : tos)
  256|       |					SetJump(from, l, to);
  257|       |		}
  258|       |}
  259|       |
  260|       |	
  261|       |}
  262|       |
  263|       |#endif

/home/johnpaul/pire/pire/scanners/slow.h:
    1|       |/*
    2|       | * slow.h -- definition of the SlowScanner
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#ifndef PIRE_SCANNERS_SLOW_H
   25|       |#define PIRE_SCANNERS_SLOW_H
   26|       |
   27|       |#include "common.h"
   28|       |#include "../approx_matching.h"
   29|       |#include "../stub/stl.h"
   30|       |#include "../partition.h"
   31|       |#include "../vbitset.h"
   32|       |#include "../fsm.h"
   33|       |#include "../run.h"
   34|       |#include "../stub/saveload.h"
   35|       |
   36|       |#ifdef PIRE_DEBUG
   37|       |#include <iostream>
   38|       |#include "../stub/lexical_cast.h"
   39|       |#endif
   40|       |
   41|       |namespace Pire {
   42|       |
   43|       |/**
   44|       | * A 'slow' scanner.
   45|       | * Takes O( str.length() * this->m_states.size() ) time to scan string,
   46|       | * but does not require FSM to be deterministic.
   47|       | * Thus can be used to handle something sorta /x.{40}$/,
   48|       | * where deterministic FSM contains 2^40 states and hence cannot fit
   49|       | * in memory.
   50|       | */
   51|       |class SlowScanner {
   52|       |public:
   53|       |	typedef size_t      Transition;
   54|       |	typedef ui16        Letter;
   55|       |	typedef ui32        Action;
   56|       |	typedef ui8         Tag;
   57|       |
   58|       |	enum { 
   59|       |		FinalFlag = 1,
   60|       |		DeadFlag  = 0
   61|       |	};
   62|       |
   63|       |	struct State {
   64|       |		TVector<unsigned> states;
   65|       |		BitSet flags;
   66|       |
   67|      0|		State() {}
   68|      0|		State(size_t size): flags(size) { states.reserve(size); }
   69|      0|		void Swap(State& s) { states.swap(s.states); flags.Swap(s.flags); }
   70|       |
   71|       |#ifdef PIRE_DEBUG
   72|       |		friend yostream& operator << (yostream& stream, const State& state) { return stream << Join(state.states.begin(), state.states.end(), ", "); }
   73|       |#endif
   74|       |	};
   75|       |
   76|      0|	SlowScanner(bool needActions = false) {
   77|      0|		Alias(Null());
   78|      0|		need_actions = needActions;
   79|      0|	}
   80|       |
   81|      0|	size_t GetLettersCount() const {return m.lettersCount; };
   82|       |
   83|      0|	size_t Size() const { return GetSize(); }
   84|      0|	size_t GetSize() const { return m.statesCount; }
   85|      0|	bool Empty() const { return m_finals == Null().m_finals; }
   86|       |	
   87|      0|	size_t Id() const {return (size_t) -1;}
   88|      0|	size_t RegexpsCount() const { return Empty() ? 0 : 1; }
   89|       |
   90|       |	void Initialize(State& state) const
   91|      0|	{
   92|      0|		state.states.clear();
   93|      0|		state.states.reserve(m.statesCount);
   94|      0|		state.states.push_back(m.start);
   95|      0|		BitSet(m.statesCount).Swap(state.flags);
   96|      0|	}
   97|       |
   98|       |	Char Translate(Char ch) const
   99|      0|	{
  100|      0|		return m_letters[static_cast<size_t>(ch)];
  101|      0|	}
  102|       |
  103|       |	Action NextTranslated(const State& current, State& next, Char l) const
  104|      0|	{
  105|      0|		next.flags.Clear();
  106|      0|		next.states.clear();
  107|      0|		for (auto&& state : current.states) {
  108|      0|			const unsigned* begin = 0;
  109|      0|			const unsigned* end = 0;
  110|      0|			if (!m_vecptr) {
  111|      0|				const size_t* pos = m_jumpPos + state * m.lettersCount + l;
  112|      0|				begin = m_jumps + pos[0];
  113|      0|				end = m_jumps + pos[1];
  114|      0|			} else {
  115|      0|				const auto& v = (*m_vecptr)[state * m.lettersCount + l];
  116|      0|				if (!v.empty()) {
  117|      0|					begin = &v[0];
  118|      0|					end = &v[0] + v.size();
  119|      0|				}
  120|      0|			}
  121|      0|
  122|      0|			for (; begin != end; ++begin)
  123|      0|				if (!next.flags.Test(*begin)) {
  124|      0|					next.flags.Set(*begin);
  125|      0|					next.states.push_back(*begin);
  126|      0|				}
  127|      0|		}
  128|      0|
  129|      0|		return 0;
  130|      0|	}
  131|       |
  132|       |	Action Next(const State& current, State& next, Char c) const
  133|      0|	{
  134|      0|		return NextTranslated(current, next, Translate(c));
  135|      0|	}
  136|       |
  137|      0|	bool TakeAction(State&, Action) const { return false; }
  138|       |
  139|       |	Action NextTranslated(State& s, Char l) const
  140|      0|	{
  141|      0|		State dest(m.statesCount);
  142|      0|		Action a = NextTranslated(s, dest, l);
  143|      0|		s.Swap(dest);
  144|      0|		return a;
  145|      0|	}
  146|       |
  147|       |	Action Next(State& s, Char c) const
  148|      0|	{
  149|      0|		return NextTranslated(s, Translate(c));
  150|      0|	}
  151|       |
  152|       |	bool Final(const State& s) const
  153|      0|	{
  154|      0|		for (auto&& state : s.states)
  155|      0|			if (m_finals[state])
  156|      0|				return true;
  157|      0|		return false;
  158|      0|	}
  159|       |
  160|       |	bool Dead(const State&) const
  161|      0|	{
  162|      0|		return false;
  163|      0|	}
  164|       |
  165|      0|	ypair<const size_t*, const size_t*> AcceptedRegexps(const State& s) const {
  166|      0|		return Final(s) ? Accept() : Deny();
  167|      0|	}
  168|       |
  169|      0|	bool CanStop(const State& s) const {
  170|      0|		return Final(s);
  171|      0|	}
  172|       |	
  173|       |	const void* Mmap(const void* ptr, size_t size)
  174|      0|	{
  175|      0|		Impl::CheckAlign(ptr);
  176|      0|		SlowScanner s;
  177|      0|		const size_t* p = reinterpret_cast<const size_t*>(ptr);
  178|      0|
  179|      0|		Impl::ValidateHeader(p, size, ScannerIOTypes::SlowScanner, sizeof(s.m));
  180|      0|		Locals* locals;
  181|      0|		Impl::MapPtr(locals, 1, p, size);
  182|      0|		memcpy(&s.m, locals, sizeof(s.m));
  183|      0|		
  184|      0|		bool empty = *((const bool*) p);
  185|      0|		Impl::AdvancePtr(p, size, sizeof(empty));
  186|      0|		Impl::AlignPtr(p, size);
  187|      0|		
  188|      0|		if (empty)
  189|      0|			s.Alias(Null());
  190|      0|		else {
  191|      0|			s.m_vecptr = 0;
  192|      0|			Impl::MapPtr(s.m_letters, MaxChar, p, size);
  193|      0|			Impl::MapPtr(s.m_finals, s.m.statesCount, p, size);
  194|      0|			Impl::MapPtr(s.m_jumpPos, s.m.statesCount * s.m.lettersCount + 1, p, size);
  195|      0|			Impl::MapPtr(s.m_jumps, s.m_jumpPos[s.m.statesCount * s.m.lettersCount], p, size);
  196|      0|			if (need_actions)
  197|      0|				Impl::MapPtr(s.m_actions, s.m_jumpPos[s.m.statesCount * s.m.lettersCount], p, size);
  198|      0|			Swap(s);
  199|      0|		}
  200|      0|		return (const void*) p;
  201|      0|	}
  202|       |
  203|       |	void Swap(SlowScanner& s)
  204|      0|	{
  205|      0|		DoSwap(m_finals, s.m_finals);
  206|      0|		DoSwap(m_jumps, s.m_jumps);
  207|      0|		DoSwap(m_actions, s.m_actions);
  208|      0|		DoSwap(m_jumpPos, s.m_jumpPos);
  209|      0|		DoSwap(m.statesCount, s.m.statesCount);
  210|      0|		DoSwap(m.lettersCount, s.m.lettersCount);
  211|      0|		DoSwap(m.start, s.m.start);
  212|      0|		DoSwap(m_letters, s.m_letters);
  213|      0|		DoSwap(m_pool, s.m_pool);
  214|      0|		DoSwap(m_vec, s.m_vec);
  215|      0|		
  216|      0|		DoSwap(m_vecptr, s.m_vecptr);
  217|      0|		DoSwap(need_actions, s.need_actions);
  218|      0|		DoSwap(m_actionsvec, s.m_actionsvec);
  219|      0|		if (m_vecptr == &s.m_vec)
  220|      0|			m_vecptr = &m_vec;
  221|      0|		if (s.m_vecptr == &m_vec)
  222|      0|			s.m_vecptr = &s.m_vec;
  223|      0|	}
  224|       |
  225|       |	SlowScanner(const SlowScanner& s)
  226|       |		: m(s.m)
  227|       |		, m_vec(s.m_vec)
  228|       |		, need_actions(s.need_actions)
  229|       |		, m_actionsvec(s.m_actionsvec)
  230|      0|	{
  231|      0|		if (s.m_vec.empty()) {
  232|      0|			// Empty or mmap()-ed scanner, just copy pointers
  233|      0|			m_finals = s.m_finals;
  234|      0|			m_jumps = s.m_jumps;
  235|      0|			m_actions = s.m_actions;
  236|      0|			m_jumpPos = s.m_jumpPos;
  237|      0|			m_letters = s.m_letters;
  238|      0|			m_vecptr = 0;
  239|      0|		} else {
  240|      0|			// In-memory scanner, perform deep copy
  241|      0|			alloc(m_letters, MaxChar);
  242|      0|			memcpy(m_letters, s.m_letters, sizeof(*m_letters) * MaxChar);
  243|      0|			m_jumps = 0;
  244|      0|			m_jumpPos = 0;
  245|      0|			m_actions = 0;
  246|      0|			alloc(m_finals, m.statesCount);
  247|      0|			memcpy(m_finals, s.m_finals, sizeof(*m_finals) * m.statesCount);
  248|      0|			m_vecptr = &m_vec;
  249|      0|		}
  250|      0|	}
  251|       |
  252|       |	explicit SlowScanner(Fsm& fsm, bool needActions = false, bool removeEpsilons = true, size_t distance = 0)
  253|       |		: need_actions(needActions)
  254|      0|	{
  255|      0|		if (distance) {
  256|      0|			fsm = CreateApproxFsm(fsm, distance);
  257|      0|		}
  258|      0|		if (removeEpsilons)
  259|      0|			fsm.RemoveEpsilons();
  260|      0|		fsm.Sparse(!removeEpsilons);
  261|      0|
  262|      0|		m.statesCount = fsm.Size();
  263|      0|		m.lettersCount = fsm.Letters().Size();
  264|      0|
  265|      0|		m_vec.resize(m.statesCount * m.lettersCount);
  266|      0|		if (need_actions)
  267|      0|			m_actionsvec.resize(m.statesCount * m.lettersCount);
  268|      0|		m_vecptr = &m_vec;
  269|      0|		alloc(m_letters, MaxChar);
  270|      0|		m_jumps = 0;
  271|      0|		m_actions = 0;
  272|      0|		m_jumpPos = 0;
  273|      0|		alloc(m_finals, m.statesCount);
  274|      0|
  275|      0|		// Build letter translation table
  276|      0|		Fill(m_letters, m_letters + MaxChar, 0);
  277|      0|		for (auto&& letter : fsm.Letters())
  278|      0|			for (auto&& character : letter.second.second)
  279|      0|				m_letters[character] = letter.second.first;
  280|      0|
  281|      0|		m.start = fsm.Initial();
  282|      0|		BuildScanner(fsm, *this);
  283|      0|	}
  284|       |
  285|      0|	SlowScanner& operator = (const SlowScanner& s) { SlowScanner(s).Swap(*this); return *this; }
  286|       |
  287|       |	~SlowScanner()
  288|      0|	{
  289|      0|		for (auto&& i : m_pool)
  290|      0|			free(i);
  291|      0|	}
  292|       |
  293|       |	void Save(yostream*) const;
  294|       |	void Load(yistream*);
  295|       |
  296|      0|	const State& StateIndex(const State& s) const { return s; }
  297|       |
  298|       |protected:
  299|       |	bool IsMmaped() const
  300|      0|	{
  301|      0|		return (!m_vecptr);
  302|      0|	}
  303|       |
  304|       |	size_t GetJump(size_t pos) const
  305|      0|	{
  306|      0|		return m_jumps[pos];
  307|      0|	}
  308|       |
  309|       |	Action& GetAction(size_t pos) const
  310|      0|	{
  311|      0|		return m_actions[pos];
  312|      0|	}
  313|       |
  314|       |	const TVector<Action>& GetActionsVec(size_t from) const
  315|      0|	{
  316|      0|		return m_actionsvec[from];
  317|      0|	}
  318|       |
  319|       |	const TVector<unsigned int>& GetJumpsVec(size_t from) const
  320|      0|	{
  321|      0|		return m_vec[from];
  322|      0|	}
  323|       |
  324|       |	size_t* GetJumpPos() const
  325|      0|	{
  326|      0|		return m_jumpPos;
  327|      0|	}
  328|       |
  329|       |	size_t GetStart() const
  330|      0|	{
  331|      0|		return m.start;
  332|      0|	}
  333|       |
  334|       |	bool IsFinal(size_t pos) const
  335|      0|	{
  336|      0|		return m_finals[pos];
  337|      0|	}
  338|       |
  339|       |private:
  340|       |
  341|       |	struct Locals {
  342|       |		size_t statesCount;
  343|       |		size_t lettersCount;
  344|       |		size_t start;
  345|       |	} m;
  346|       |
  347|       |	bool* m_finals;
  348|       |	unsigned* m_jumps;
  349|       |	Action* m_actions;
  350|       |	size_t* m_jumpPos;
  351|       |	size_t* m_letters;
  352|       |
  353|       |	TVector<void*> m_pool;
  354|       |	TVector< TVector<unsigned> > m_vec, *m_vecptr;
  355|       |
  356|       |	// Only used to force Null() call during static initialization, when Null()::n can be
  357|       |	// initialized safely by compilers that don't support thread safe static local vars
  358|       |	// initialization
  359|       |	static const SlowScanner* m_null;
  360|       |
  361|       |	bool need_actions;
  362|       |	TVector<TVector<Action>> m_actionsvec;
  363|       |	static const SlowScanner& Null();
  364|       |
  365|       |	template<class T> void alloc(T*& p, size_t size)
  366|      0|	{
  367|      0|		p = static_cast<T*>(malloc(size * sizeof(T)));
  368|      0|		memset(p, 0, size * sizeof(T));
  369|      0|		m_pool.push_back(p);
  370|      0|	}
  ------------------
  | Unexecuted instantiation: _ZN4Pire11SlowScanner5allocImEEvRPT_m
  ------------------
  | Unexecuted instantiation: _ZN4Pire11SlowScanner5allocIbEEvRPT_m
  ------------------
  371|       |	
  372|       |	void Alias(const SlowScanner& s)
  373|      0|	{		
  374|      0|		memcpy(&m, &s.m, sizeof(m));
  375|      0|		m_vec.clear();
  376|      0|		need_actions = s.need_actions;
  377|      0|		m_actionsvec.clear();
  378|      0|		m_finals = s.m_finals;
  379|      0|		m_jumps = s.m_jumps;
  380|      0|		m_actions = s.m_actions;
  381|      0|		m_jumpPos = s.m_jumpPos;
  382|      0|		m_letters = s.m_letters;
  383|      0|		m_vecptr = s.m_vecptr;
  384|      0|		m_pool.clear();
  385|      0|	}
  386|       |	
  387|       |	void SetJump(size_t oldState, Char c, size_t newState, unsigned long action)
  388|      0|	{
  389|      0|		Y_ASSERT(!m_vec.empty());
  390|      0|		Y_ASSERT(oldState < m.statesCount);
  391|      0|		Y_ASSERT(newState < m.statesCount);
  392|      0|
  393|      0|		size_t idx = oldState * m.lettersCount + m_letters[c];
  394|      0|		m_vec[idx].push_back(newState);
  395|      0|		if (need_actions)
  396|      0|			m_actionsvec[idx].push_back(action);
  397|      0|	}
  398|       |
  399|      0|	unsigned long RemapAction(unsigned long action) { return action; }
  400|       |
  401|      0|	void SetInitial(size_t state) { m.start = state; }
  402|      0|	void SetTag(size_t state, ui8 tag) { m_finals[state] = (tag != 0); }
  403|       |	
  404|      0|	void FinishBuild() {}
  405|       |
  406|       |	static ypair<const size_t*, const size_t*> Accept()
  407|      0|	{
  408|      0|		static size_t v[1] = { 0 };
  409|      0|
  410|      0|		return ymake_pair(v, v + 1);
  411|      0|	}
  412|       |
  413|       |	static ypair<const size_t*, const size_t*> Deny()
  414|      0|	{
  415|      0|		static size_t v[1] = { 0 };
  416|      0|		return ymake_pair(v, v);
  417|      0|	}
  418|       |
  419|       |	friend void BuildScanner<SlowScanner>(const Fsm&, SlowScanner&);
  420|       |};
  421|       |
  422|       |template<>
  423|      0|inline SlowScanner Fsm::Compile(size_t distance) {
  424|      0|	return SlowScanner(*this, false, true, distance);
  425|      0|}
  426|       |
  427|       |inline const SlowScanner& SlowScanner::Null()
  428|      0|{
  429|      0|	static const SlowScanner n = Fsm::MakeFalse().Compile<SlowScanner>();
  430|      0|	return n;
  431|      0|}
  432|       |
  433|       |#ifndef PIRE_DEBUG	
  434|       |/// A specialization of Run(), since its state is much heavier than other ones
  435|       |/// and we thus want to avoid copying states.
  436|       |template<>
  437|       |inline void Run<SlowScanner>(const SlowScanner& scanner, SlowScanner::State& state, const char* begin, const char* end)
  438|      0|{
  439|      0|	SlowScanner::State temp;
  440|      0|	scanner.Initialize(temp);
  441|      0|
  442|      0|	SlowScanner::State* src = &state;
  443|      0|	SlowScanner::State* dest = &temp;
  444|      0|
  445|      0|	for (; begin != end; ++begin) {
  446|      0|		scanner.Next(*src, *dest, static_cast<unsigned char>(*begin));
  447|      0|		DoSwap(src, dest);
  448|      0|	}
  449|      0|	if (src != &state)
  450|      0|		state = *src;
  451|      0|}
  452|       |#endif
  453|       |
  454|       |}
  455|       |
  456|       |
  457|       |#endif

/home/johnpaul/pire/pire/stub/codepage_h.h:
    1|       |/*
    2|       | * Copyright (c) 2000-2010, Yandex
    3|       | *
    4|       | * This file is free software: you can redistribute it and/or modify
    5|       | * it under the terms of the GNU Lesser Public License as published by
    6|       | * the Free Software Foundation, either version 3 of the License, or
    7|       | * (at your option) any later version.
    8|       | * 
    9|       | * This file is distributed in the hope that it will be useful,
   10|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   11|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   12|       | * GNU Lesser Public License for more details.
   13|       | * You should have received a copy of the GNU Lesser Public License
   14|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   15|       | */
   16|       |
   17|       |
   18|       |#ifndef PIRE_STUB_CODEPAGE_H_H
   19|       |#define PIRE_STUB_CODEPAGE_H_H
   20|       |
   21|       |struct CodePage;
   22|       |struct Recoder;
   23|       |struct Encoder;
   24|       |
   25|       |/*****************************************************************\
   26|       | *                    struct CodePage                              *
   27|       |\*****************************************************************/
   28|       |struct CodePage {
   29|       |	docCodes    CPEnum;       // int MIBEnum;
   30|       |	const char *Names[30];    // name[0] -- preferred mime-name
   31|       |	wchar32     unicode[256];
   32|       |	const char *DefaultChar;  //[CCL_NUM]
   33|       |
   34|      0|	bool is_lower(int ch) const {return ch>=0 && Pire::is_lower(unicode[(unsigned char)ch]);}
   35|      0|	bool is_upper(int ch) const {return ch>=0 && Pire::is_upper(unicode[(unsigned char)ch]);}
   36|      0|	bool is_alpha(int ch) const {return ch>=0 && Pire::is_alpha(unicode[(unsigned char)ch]);}
   37|      0|	bool is_digit(int ch) const {return ch>=0 && Pire::is_digit(unicode[(unsigned char)ch]);}
   38|      0|	bool is_xdigit(int ch)const {return ch>=0 && Pire::is_xdigit(unicode[(unsigned char)ch]);}
   39|      0|	bool is_alnum(int ch) const {return ch>=0 && Pire::is_alnum(unicode[(unsigned char)ch]);}
   40|      0|	bool is_space(int ch) const {return ch>=0 && Pire::is_space(unicode[(unsigned char)ch]);}
   41|      0|	bool is_punct(int ch) const {return ch>=0 && Pire::is_punct(unicode[(unsigned char)ch]);}
   42|      0|	bool is_cntrl(int ch) const {return ch>=0 && Pire::is_cntrl(unicode[(unsigned char)ch]);}
   43|      0|	bool is_graph(int ch) const {return ch>=0 && Pire::is_graph(unicode[(unsigned char)ch]);}
   44|      0|	bool is_print(int ch) const {return ch>=0 && Pire::is_print(unicode[(unsigned char)ch]);}
   45|       |	// non-standard
   46|      0|	bool is_composed(int ch) const {return ch>=0 && Pire::is_composed(unicode[(unsigned char)ch]);}
   47|       |
   48|       |	char *strlwr(char *in_out, size_t len = (unsigned)(-1)) const;
   49|       |	char *strupr(char *in_out, size_t len = (unsigned)(-1)) const;
   50|       |	char *strlwr(const char *in, char *out, size_t len = (unsigned)(-1)) const;
   51|       |	char *strupr(const char *in, char *out, size_t len = (unsigned)(-1)) const;
   52|       |	int   stricmp(const char* s1, const char *s2) const;
   53|       |	int   strnicmp(const char* s1, const char *s2, size_t len) const;
   54|       |
   55|       |	unsigned char to_upper(unsigned char ch) const;
   56|       |	unsigned char to_lower(unsigned char ch) const;
   57|       |	unsigned char to_title(unsigned char ch) const;
   58|       |	int           to_digit(unsigned char ch) const;
   59|       |
   60|       |	static void Initialize();
   61|       |};
   62|       |
   63|       |const CodePage *CodePageByName(const char *name);
   64|       |
   65|       |namespace NCodepagePrivate {
   66|       |	class TCodepagesMap {
   67|       |	private:
   68|       |		const CodePage* Data[CODES_MAX];
   69|       |
   70|       |	public:
   71|       |		TCodepagesMap();
   72|       |
   73|      0|		const CodePage* Get(docCodes e) {
   74|      0|			Y_ASSERT(CODES_UNKNOWN < e && e < CODES_MAX);
   75|      0|			return Data[e];
   76|      0|		}
   77|       |	};
   78|       |}
   79|       |
   80|       |const CodePage *CodePageByDocCode(docCodes e)
   81|      0|{
   82|      0|	return Singleton<NCodepagePrivate::TCodepagesMap>()->Get(e);
   83|      0|}
   84|       |
   85|       |docCodes DocCodeByName(const char *name)
   86|      0|{
   87|      0|	const CodePage *CP = CodePageByName(name);
   88|      0|	if (CP == 0)
   89|      0|		return CODES_UNKNOWN;
   90|      0|	return CP->CPEnum;
   91|      0|}
   92|       |docCodes DocCodeByCodePage(const CodePage *CP)
   93|      0|{
   94|      0|	return CP->CPEnum;
   95|      0|}
   96|       |const char *NameByDocCode(docCodes e)
   97|      0|{
   98|      0|	return CodePageByDocCode(e)->Names[0];
   99|      0|}
  100|       |const char *NameByCodePage(const CodePage *CP)
  101|      0|{
  102|      0|	return CP->Names[0];
  103|      0|}
  104|       |
  105|       |docCodes EncodingHintByName(const char* name);
  106|       |
  107|       |/*****************************************************************\
  108|       | *                    struct Encoder                               *
  109|       |\*****************************************************************/
  110|       |enum RECODE_RESULT{
  111|       |	RECODE_OK,
  112|       |	RECODE_EOINPUT,
  113|       |	RECODE_EOOUTPUT,
  114|       |	RECODE_BROKENSYMBOL,
  115|       |	RECODE_ERROR,
  116|       |	RECODE_DEFAULTSYMBOL,
  117|       |};
  118|       |
  119|       |struct Encoder {
  120|       |	char *Table[256];
  121|       |	const  char *DefaultChar;
  122|       |
  123|       |	char Code(wchar32 ch) const
  124|      0|	{
  125|      0|		if (ch > 0xFFFF)
  126|      0|			return 0;
  127|      0|		return (unsigned char)Table[(ch>>8)&255][ch&255];
  128|      0|	}
  129|       |	char Tr(wchar32 ch) const
  130|      0|	{
  131|      0|		char code = Code(ch);
  132|      0|		if (code == 0 && ch != 0)
  133|      0|			code =  DefaultChar[wc_type(ch)];
  134|      0|		Y_ASSERT(code != 0 || ch == 0);
  135|      0|		return code;
  136|      0|	}
  137|       |
  138|       |	unsigned char operator [](wchar32 ch) const
  139|      0|	{
  140|      0|		return Tr(ch);
  141|      0|	}
  142|       |	void Tr(const wchar32 *in, char *out, size_t len) const;
  143|       |	void Tr(const wchar32 *in, char *out) const;
  144|       |	char * DefaultPlane;
  145|       |};
  146|       |
  147|       |struct CustomEncoder : public Encoder {
  148|       |	void Create (const CodePage *target, int mode=1);
  149|       |	void Free ();
  150|       |private:
  151|       |	void addToTable(wchar32 ucode, unsigned char code, const CodePage* target);
  152|       |};
  153|       |
  154|       |struct MultipleEncMapping {
  155|       |	typedef ui32 maptype;
  156|       |	static maptype DefaultPlane[256];
  157|       |	maptype *Table[256];
  158|       |	MultipleEncMapping();
  159|      0|	maptype GetEncodings(wchar32 ch) const {
  160|      0|		return Table[(ch>>8)&255][ch&255];
  161|      0|	}
  162|       |	void ImportEncoder(const Encoder &E, int enc);
  163|       |	~MultipleEncMapping();
  164|       |
  165|       |	DECLARE_NOCOPY(MultipleEncMapping);
  166|       |};
  167|       |
  168|       |/*****************************************************************\
  169|       | *                    struct Recoder                               *
  170|       |\*****************************************************************/
  171|       |struct Recoder {
  172|       |	unsigned char Table[257];
  173|       |
  174|       |	void Create(const CodePage &source, const CodePage &target);
  175|       |	void Create(const CodePage &source, const Encoder* wideTarget);
  176|       |
  177|       |	void Create(const CodePage &page, wchar32 (*mapper)(wchar32));
  178|       |	void Create(const CodePage &page, const Encoder* widePage, wchar32 (*mapper)(wchar32));
  179|       |
  180|       |	unsigned char Tr(unsigned char c) const
  181|      0|	{
  182|      0|		return Table[c];
  183|      0|	}
  184|       |	unsigned char operator [](unsigned char c) const
  185|      0|	{
  186|      0|		return Table[c];
  187|      0|	}
  188|       |	void  Tr(const char *in, char *out, size_t len) const;
  189|       |	void  Tr(const char *in, char *out) const;
  190|       |	void  Tr(char *in_out, size_t len) const;
  191|       |	void  Tr(char *in_out) const;
  192|       |};
  193|       |
  194|       |extern const Encoder *EncodeTo[CODES_MAX];
  195|       |
  196|       |extern const struct Encoder &WideCharToYandex;
  197|       |
  198|       |extern const Recoder rcdr_to_yandex[];
  199|       |extern const Recoder rcdr_from_yandex[];
  200|       |
  201|       |extern const Recoder rcdr_to_lower[];
  202|       |extern const Recoder rcdr_to_upper[];
  203|       |extern const Recoder rcdr_to_title[];
  204|       |
  205|       |unsigned char CodePage::to_upper(unsigned char ch) const
  206|      0|{
  207|      0|	return rcdr_to_upper[CPEnum].Table[ch];
  208|      0|}
  209|       |unsigned char CodePage::to_lower(unsigned char ch) const
  210|      0|{
  211|      0|	return rcdr_to_lower[CPEnum].Table[ch];
  212|      0|}
  213|       |unsigned char CodePage::to_title(unsigned char ch) const
  214|      0|{
  215|      0|	return rcdr_to_title[CPEnum].Table[ch];
  216|      0|}
  217|       |int CodePage::to_digit(unsigned char ch) const
  218|      0|{
  219|      0|	return Pire::to_digit(unicode[ch]);
  220|      0|}
  221|       |
  222|       |extern const struct CodePage csYandex;
  223|       |
  224|       |const unsigned char yaUNK_Up = 0xA6;
  225|       |const unsigned char yaUNK_Lo = 0xB6;
  226|       |const unsigned char yaIDEOGR = 0x9F;
  227|       |const unsigned char yaSHY    = 0x8F;
  228|       |const unsigned char yaACUTE  = 0x80;
  229|       |const unsigned char yaGradus = 0xB0;
  230|       |
  231|      0|unsigned char utf8_leadbyte_mask(size_t len) {
  232|       |	// Y_ASSERT (len <= 4);
  233|      0|	return "\0\0\037\017\007"[len];
  234|      0|}
  235|       |
  236|       |size_t utf8_rune_len(const unsigned char p)
  237|  2.00M|{
  238|  2.00M|	return "\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\0\0\0\0\0\0\0\0\2\2\2\2\3\3\4\0"[p>>3];
  239|  2.00M|}
  240|       |
  241|       |size_t utf8_rune_len_by_ucs(wchar32 rune)
  242|  3.40M|{
  243|  3.40M|	if (rune < 0x80)
  244|  3.40M|		return 1U;
  245|      0|	else if (rune < 0x800)
  246|      0|		return 2U;
  247|      0|	else if (rune < 0x10000)
  248|      0|		return 3U;
  249|      0|	else if (rune < 0x200000)
  250|      0|		return 4U;
  251|      0|	else if (rune < 0x4000000)
  252|      0|		return 5U;
  253|      0|	else
  254|      0|		return 6U;
  255|  3.40M|}
  256|       |
  257|       |extern const wchar32 BROKEN_RUNE;
  258|       |
  259|       |RECODE_RESULT utf8_read_rune(wchar32 &rune, size_t &rune_len, const unsigned char *s, const unsigned char *end)
  260|  2.00M|{
  261|  2.00M|	rune = BROKEN_RUNE;
  262|  2.00M|	rune_len = 0;
  263|  2.00M|	wchar32 _rune;
  264|       |
  265|  2.00M|	size_t _len = utf8_rune_len(*s);
  266|  2.00M|	if (s + _len > end) return RECODE_EOINPUT;  //[EOINPUT]
  267|  2.00M|	if (_len==0) return RECODE_BROKENSYMBOL;    //[BROKENSYMBOL] in first byte
  268|  2.00M|	_rune = *s++;                               //[00000000 0XXXXXXX]
  269|       |
  270|  2.00M|	if (_len > 1) {
  271|      0|		_rune &= utf8_leadbyte_mask(_len);
  272|      0|		unsigned char ch = *s++;
  273|      0|		if ((ch & 0xC0) != 0x80)
  274|      0|			return RECODE_BROKENSYMBOL;         //[BROKENSYMBOL] in second byte
  275|      0|		_rune <<= 6;
  276|      0|		_rune |= ch & 0x3F;                     //[00000XXX XXYYYYYY]
  277|      0|		if (_len > 2) {
  278|      0|			ch = *s++;
  279|      0|			if ((ch & 0xC0) != 0x80)
  280|      0|				return RECODE_BROKENSYMBOL;     //[BROKENSYMBOL] in third byte
  281|      0|			_rune <<= 6;
  282|      0|			_rune |= ch & 0x3F;                 //[XXXXYYYY YYZZZZZZ]
  283|      0|			if (_len > 3) {
  284|      0|				ch = *s;
  285|      0|				if ((ch & 0xC0) != 0x80)
  286|      0|					return RECODE_BROKENSYMBOL; //[BROKENSYMBOL] in fourth byte
  287|      0|				_rune <<= 6;
  288|      0|				_rune |= ch & 0x3F;             //[XXXYY YYYYZZZZ ZZQQQQQQ]
  289|      0|			}
  290|      0|		}
  291|      0|	}
  292|  2.00M|	rune_len = _len;
  293|  2.00M|	rune = _rune;
  294|  2.00M|	return RECODE_OK;
  295|  2.00M|}
  296|       |
  297|  3.40M|RECODE_RESULT utf8_put_rune(wchar32 rune, size_t &rune_len, unsigned char *s, const unsigned char *end){
  298|  3.40M|	rune_len = 0;
  299|  3.40M|	size_t tail = end - s;
  300|  3.40M|	if (rune < 0x80){
  301|  3.40M|		if (tail <= 0) return RECODE_EOOUTPUT;
  302|  3.40M|		*s = (unsigned char)rune;
  303|  3.40M|		rune_len = 1;
  304|  3.40M|		return RECODE_OK;
  305|  3.40M|	}
  306|      0|	if (rune < 0x800){
  307|      0|		if (tail <= 1) return RECODE_EOOUTPUT;
  308|      0|		*s++ = (unsigned char)(0xC0 | (rune >> 6));
  309|      0|		*s   = (unsigned char)(0x80 | (rune & 0x3F));
  310|      0|		rune_len = 2;
  311|      0|		return RECODE_OK;
  312|      0|	}
  313|      0|	if (rune < 0x10000) {
  314|      0|		if (tail <= 2) return RECODE_EOOUTPUT;
  315|      0|		*s++ = (unsigned char)(0xE0 | (rune >> 12));
  316|      0|		*s++ = (unsigned char)(0x80 | ((rune >> 6) & 0x3F));
  317|      0|		*s   = (unsigned char)(0x80 | (rune & 0x3F));
  318|      0|		rune_len = 3;
  319|      0|		return RECODE_OK;
  320|      0|	}
  321|      0|	/*if (rune < 0x200000)*/ {
  322|      0|		if (tail <= 3) return RECODE_EOOUTPUT;
  323|      0|		*s++ = (unsigned char)(0xF0 | ((rune >> 18) & 0x07));
  324|      0|		*s++ = (unsigned char)(0x80 | ((rune >> 12) & 0x3F));
  325|      0|		*s++ = (unsigned char)(0x80 | ((rune >> 6) & 0x3F));
  326|      0|		*s   = (unsigned char)(0x80 | (rune & 0x3F));
  327|      0|		rune_len = 4;
  328|      0|		return RECODE_OK;
  329|      0|	}
  330|      0|};
  331|       |
  332|      0|RECODE_RESULT utf8_read_rune_from_unknown_plane(wchar32 &rune, size_t &rune_len, const wchar32 *s, const wchar32 *end) {
  333|      0|	if ((*s & 0xFF00) != 0xF000) {
  334|      0|		rune_len = 1;
  335|      0|		rune = *s;
  336|      0|		return RECODE_OK;
  337|      0|	}
  338|       |
  339|      0|	rune_len = 0;
  340|       |
  341|      0|	size_t _len = utf8_rune_len((unsigned char)(*s));
  342|      0|	if (s + _len > end) return RECODE_EOINPUT;  //[EOINPUT]
  343|      0|	if (_len == 0) return RECODE_BROKENSYMBOL;  //[BROKENSYMBOL] in first byte
  344|       |
  345|      0|	wchar32 _rune = (ui8)(*s++);                //[00000000 0XXXXXXX]
  346|      0|	if (_len > 1) {
  347|      0|		_rune &= utf8_leadbyte_mask(_len);
  348|      0|		wchar32 ch = *s++;
  349|      0|		if ((ch & 0xFFC0) != 0xF080)
  350|      0|			return RECODE_BROKENSYMBOL;         //[BROKENSYMBOL] in second byte
  351|      0|		_rune <<= 6;
  352|      0|		_rune |= ch & 0x3F;                     //[00000XXX XXYYYYYY]
  353|      0|		if (_len > 2) {
  354|      0|			ch = *s++;
  355|      0|			if ((ch & 0xFFC0) != 0xF080)
  356|      0|				return RECODE_BROKENSYMBOL;     //[BROKENSYMBOL] in third byte
  357|      0|			_rune <<= 6;
  358|      0|			_rune |= ch & 0x3F;                 //[XXXXYYYY YYZZZZZZ]
  359|      0|			if (_len > 3) {
  360|      0|				ch = *s;
  361|      0|				if ((ch & 0xFFC0) != 0xF080)
  362|      0|					return RECODE_BROKENSYMBOL; //[BROKENSYMBOL] in fourth byte
  363|      0|				_rune <<= 6;
  364|      0|				_rune |= ch & 0x3F;             //[XXXYY YYYYZZZZ ZZQQQQQQ]
  365|      0|			}
  366|      0|		}
  367|      0|	}
  368|      0|	rune_len = _len;
  369|      0|	rune = _rune;
  370|      0|	return RECODE_OK;
  371|      0|}
  372|       |
  373|       |/// this function changes (lowers) [end] position in case of utf-8
  374|       |/// null character is NOT assumed or written at [*end]
  375|       |void DecodeUnknownPlane(wchar32 *start, wchar32 *&end, const docCodes enc4unk);
  376|       |
  377|       |/// this function may return less than [len] bytes in case of utf-8
  378|       |/// [dst] buffer must have at least [len] bytes
  379|       |/// [dst] is NOT terminated with null character
  380|       |size_t DecodeUnknownAndRecodeToYandex(const wchar32 *src, char *dst, size_t len, const docCodes enc4unk);
  381|       |
  382|      0|void ToLower(char* s, size_t n, const CodePage& cp = csYandex) {
  383|      0|	char* const e = s + n;
  384|      0|	for (; s != e; ++s)
  385|      0|		*s = cp.to_lower(*s);
  386|      0|}
  387|       |
  388|      0|void ToUpper(char* s, size_t n, const CodePage& cp = csYandex) {
  389|      0|	char* const e = s + n;
  390|      0|	for (; s != e; ++s)
  391|      0|		*s = cp.to_upper(*s);
  392|      0|}
  393|       |
  394|       |#endif

/home/johnpaul/pire/pire/stub/defaults.h:
    1|       |/*
    2|       | * Copyright (C) 2000-2010, Yandex
    3|       | *
    4|       | * This file is free software: you can redistribute it and/or modify
    5|       | * it under the terms of the GNU Lesser Public License as published by
    6|       | * the Free Software Foundation, either version 3 of the License, or
    7|       | * (at your option) any later version.
    8|       | * 
    9|       | * This file is distributed in the hope that it will be useful,
   10|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   11|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   12|       | * GNU Lesser Public License for more details.
   13|       | * You should have received a copy of the GNU Lesser Public License
   14|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   15|       | */
   16|       |
   17|       |
   18|       |#ifndef PIRE_STUB_DEFAULTS_H_INCLUDED
   19|       |#define PIRE_STUB_DEFAULTS_H_INCLUDED
   20|       |
   21|       |#include <stdint.h>
   22|       |#include <stddef.h>
   23|       |
   24|       |namespace Pire {
   25|       |	typedef int8_t i8;
   26|       |	typedef int16_t i16;
   27|       |	typedef int32_t i32;
   28|       |	typedef int64_t i64;
   29|       |	typedef uint8_t ui8;
   30|       |	typedef uint16_t ui16;
   31|       |	typedef uint32_t ui32;
   32|       |	typedef uint64_t ui64;
   33|       |
   34|       |	typedef ui32 wchar32;
   35|       |	
   36|       |	template<class T>
   37|      0|	inline uint64_t ULL(T t) { return (uint64_t) t; }
   38|       |}
   39|       |
   40|       |#endif

/home/johnpaul/pire/pire/stub/doccodes_h.h:
    1|       |/*
    2|       | * Copyright (C) 2000-2010, Yandex
    3|       | *
    4|       | * This file is free software: you can redistribute it and/or modify
    5|       | * it under the terms of the GNU Lesser Public License as published by
    6|       | * the Free Software Foundation, either version 3 of the License, or
    7|       | * (at your option) any later version.
    8|       | * 
    9|       | * This file is distributed in the hope that it will be useful,
   10|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   11|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   12|       | * GNU Lesser Public License for more details.
   13|       | * You should have received a copy of the GNU Lesser Public License
   14|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   15|       | */
   16|       |
   17|       |
   18|       |#ifndef PIRE_STUB_DOCCODES_H_H
   19|       |#define PIRE_STUB_DOCCODES_H_H
   20|       |
   21|       |
   22|       |
   23|       |
   24|       |const char* mimetypeByExt(const char *fname, const char* check_ext=0);
   25|       |
   26|       |enum docCodes{           // CP_ENUM
   27|       |	CODES_UNSUPPORTED = -2, // valid but unsupported encoding
   28|       |	CODES_UNKNOWN = -1,  // invalid or unspecified encoding
   29|       |	CODES_WIN,           // [ 0] CP_WINDOWS_1251     Windows
   30|       |	CODES_KOI8,          // [ 1] CP_KOI8_R           Koi8-r
   31|       |	CODES_ALT,           // [ 2] CP_IBM_866          MS DOS, alternative
   32|       |	CODES_MAC,           // [ 3] CP_MAC_CYRILLIC     Macintosh
   33|       |	CODES_MAIN,          // [ 4] CP_ISO_LATIN_CYRILLIC Main
   34|       |	CODES_ASCII,         // [ 5] CP_WINDOWS_1252     Latin 1
   35|       |	CODES_UNIPOL,        // [ 6] CP_UNIPOL           ISO+WIN
   36|       |	CODES_WIN_EAST,      // [ 7] CP_WINDOWS_1250     WIN PL
   37|       |	CODES_ISO_EAST,      // [ 8] CP_ISO_8859_2       ISO PL
   38|       |	// our superset of subset of windows-1251
   39|       |	CODES_YANDEX,        // [ 9] CP_YANDEX
   40|       |	// popular non-standard codepages
   41|       |	CODES_WINWIN,        // [10] CP_WIN_WIN          win-autoconverted-from-koi-to-win (win_as_koi_to_win)
   42|       |	CODES_KOIKOI,        // [11] CP_KOI_KOI          koi-autoconverted-from-win-to-koi (koi_as_win_to_koi)
   43|       |	// missing standard codepages
   44|       |	CODES_IBM855,        // [12] CP_IBM_855
   45|       |	CODES_UTF8,          // [13] CP_FakeUTF8
   46|       |	CODES_UNKNOWNPLANE,  // [14] Unrecognized characters are mapped into the PUA: U+F000..U+F0FF
   47|       |
   48|       |	CODES_KAZWIN,        // [15] CP_WINDOWS_1251_K   Kazakh version of Windows-1251
   49|       |	CODES_TATWIN,        // [16] CP_WINDOWS_1251_T   Tatarian version of Windows-1251
   50|       |	CODES_ARMSCII,       // [17] Armenian ASCII
   51|       |	CODES_GEO_ITA,       // [18] Academy of Sciences Georgian
   52|       |	CODES_GEO_PS,        // [19] Georgian Parliament
   53|       |	CODES_ISO_8859_3,    // [20] Latin-3: Turkish, Maltese and Esperanto
   54|       |	CODES_ISO_8859_4,    // [21] Latin-4: Estonian, Latvian, Lithuanian, Greenlandic, Sami
   55|       |	CODES_ISO_8859_6,    // [22] Latin/Arabic: Arabic
   56|       |	CODES_ISO_8859_7,    // [23] Latin/Greek: Greek
   57|       |	CODES_ISO_8859_8,    // [24] Latin/Hebrew: Hebrew
   58|       |	CODES_ISO_8859_9,    // [25] Latin-5 or Turkish: Turkish
   59|       |	CODES_ISO_8859_13,   // [26] Latin-7 or Baltic Rim: Baltic languages
   60|       |	CODES_ISO_8859_15,   // [27] Latin-9: Western European languages
   61|       |	CODES_ISO_8859_16,   // [28] Latin-10: South-Eastern European languages
   62|       |	CODES_WINDOWS_1253,  // [29] for Greek
   63|       |	CODES_WINDOWS_1254,  // [30] for Turkish
   64|       |	CODES_WINDOWS_1255,  // [31] for Hebrew
   65|       |	CODES_WINDOWS_1256,  // [32] for Arabic
   66|       |	CODES_WINDOWS_1257,  // [33] for Estonian, Latvian and Lithuanian
   67|       |
   68|       |	// these codes are all the other 8bit codes known by libiconv
   69|       |	// they follow in alphanumeric order
   70|       |	CODES_CP1046,
   71|       |	CODES_CP1124,
   72|       |	CODES_CP1125,
   73|       |	CODES_CP1129,
   74|       |	CODES_CP1131,
   75|       |	CODES_CP1133,
   76|       |	CODES_CP1161,
   77|       |	CODES_CP1162,
   78|       |	CODES_CP1163,
   79|       |	CODES_CP1258,
   80|       |	CODES_CP437,
   81|       |	CODES_CP737,
   82|       |	CODES_CP775,
   83|       |	CODES_CP850,
   84|       |	CODES_CP852,
   85|       |	CODES_CP853,
   86|       |	CODES_CP856,
   87|       |	CODES_CP857,
   88|       |	CODES_CP858,
   89|       |	CODES_CP860,
   90|       |	CODES_CP861,
   91|       |	CODES_CP862,
   92|       |	CODES_CP863,
   93|       |	CODES_CP864,
   94|       |	CODES_CP865,
   95|       |	CODES_CP869,
   96|       |	CODES_CP874,
   97|       |	CODES_CP922,
   98|       |	CODES_HP_ROMAN8,
   99|       |	CODES_ISO646_CN,
  100|       |	CODES_ISO646_JP,
  101|       |	CODES_ISO8859_10,
  102|       |	CODES_ISO8859_11,
  103|       |	CODES_ISO8859_14,
  104|       |	CODES_JISX0201,
  105|       |	CODES_KOI8_T,
  106|       |	CODES_MAC_ARABIC,
  107|       |	CODES_MAC_CENTRALEUROPE,
  108|       |	CODES_MAC_CROATIAN,
  109|       |	CODES_MAC_GREEK,
  110|       |	CODES_MAC_HEBREW,
  111|       |	CODES_MAC_ICELAND,
  112|       |	CODES_MAC_ROMANIA,
  113|       |	CODES_MAC_ROMAN,
  114|       |	CODES_MAC_THAI,
  115|       |	CODES_MAC_TURKISH,
  116|       |	CODES_MAC_UKRAINE,
  117|       |	CODES_MULELAO,
  118|       |	CODES_NEXTSTEP,
  119|       |	CODES_PT154,
  120|       |	CODES_RISCOS_LATIN1,
  121|       |	CODES_RK1048,
  122|       |	CODES_TCVN,
  123|       |	CODES_TDS565,
  124|       |	CODES_TIS620,
  125|       |	CODES_VISCII,
  126|       |
  127|       |	CODES_MAX            //      CP_NUM
  128|       |};
  129|       |
  130|       |docCodes codingByStr(const char *codingStr);
  131|       |
  132|       |enum docLanguage {
  133|       |	LANG_UNK = 0,
  134|       |	LANG_RUS = 1,
  135|       |	LANG_ENG = 2,
  136|       |	LANG_POL = 3,
  137|       |	LANG_HUN = 4,
  138|       |	LANG_UKR = 5,
  139|       |	LANG_GER = 6,
  140|       |	LANG_FRN = 7,
  141|       |	LANG_TAT = 8,
  142|       |	LANG_BLR = 9,
  143|       |	LANG_KAZ = 10,
  144|       |	LANG_NAMES = 11,
  145|       |	LANG_SPA = 12,
  146|       |	LANG_ITA = 13,
  147|       |	LANG_ARM = 14,
  148|       |	LANG_DAN = 15,
  149|       |	LANG_POR = 16,
  150|       |	LANG_BRA = 17,
  151|       |	LANG_SLO = 18,
  152|       |	LANG_SLV = 19,
  153|       |	LANG_DUT = 20,
  154|       |	LANG_BUL = 21,
  155|       |	LANG_CAT = 22,
  156|       |	LANG_HRV = 23,
  157|       |	LANG_CZE = 24,
  158|       |	LANG_GRE = 25,
  159|       |	LANG_HEB = 26,
  160|       |	LANG_NOB = 27,
  161|       |	LANG_NNO = 28,
  162|       |	LANG_SWE = 29,
  163|       |	LANG_KOR = 30,
  164|       |	LANG_LAT = 31,
  165|       |	LANG_TRANS = 32,
  166|       |	LANG_E2R = 33,
  167|       |	LANG_R2E = 34,
  168|       |	LANG_EMPTY = 35,
  169|       |	LANG_UNK_LAT = 36,
  170|       |	LANG_UNK_CYR = 37,
  171|       |	LANG_UNK_ALPHA = 38,
  172|       |	LANG_FIN = 39,
  173|       |	LANG_EST = 40,
  174|       |	LANG_LAV = 41,
  175|       |	LANG_LIT = 42,
  176|       |	LANG_BAK = 43,
  177|       |	LANG_TUR = 44,
  178|       |	LANG_RUM = 45,
  179|       |	LANG_MON = 46,
  180|       |	LANG_UZB = 47,
  181|       |	LANG_KIR = 48,
  182|       |	LANG_TGK = 49,
  183|       |	LANG_TUK = 50,
  184|       |	LANG_SRP = 51,
  185|       |	LANG_AZE = 52,
  186|       |	// missed language: use it for new language before adding them to the end of the list
  187|       |	LANG_GEO = 54,
  188|       |	LANG_ARA = 55,
  189|       |	LANG_PER = 56,
  190|       |	LANG_UNTRANS = 57,
  191|       |	LANG_MAX
  192|       |};
  193|       |
  194|       |docLanguage LanguageByName(const char *name);
  195|       |extern const char *NameByLanguage[LANG_MAX];
  196|       |extern const char *IsoNameByLanguage[LANG_MAX];
  197|       |
  198|       |enum MimeTypes {
  199|       |	MIME_UNKNOWN    = 0,
  200|       |	MIME_TEXT       = 1,
  201|       |	MIME_HTML       = 2,  MIME_XHTMLXML = MIME_HTML,
  202|       |	MIME_PDF        = 3,
  203|       |	MIME_RTF        = 4,
  204|       |	MIME_DOC        = 5,  MIME_MSWORD = MIME_DOC,
  205|       |	MIME_MPEG       = 6,
  206|       |	MIME_XML        = 7,  MIME_RSS = MIME_XML,
  207|       |	MIME_WML        = 8,
  208|       |	MIME_SWF        = 9,  MIME_FLASH = MIME_SWF,
  209|       |	MIME_XLS        = 10, MIME_EXCEL = MIME_XLS,
  210|       |	MIME_PPT        = 11,
  211|       |	MIME_IMAGE_JPG  = 12,
  212|       |	MIME_IMAGE_PJPG = 13,
  213|       |	MIME_IMAGE_PNG  = 14,
  214|       |	MIME_IMAGE_GIF  = 15,
  215|       |	MIME_DOCX       = 16,
  216|       |	MIME_ODT        = 17,
  217|       |	MIME_ODP        = 18,
  218|       |	MIME_ODS        = 19,
  219|       |	//MIME_XHTMLXML   = 20,
  220|       |	MIME_IMAGE_BMP  = 21,
  221|       |	MIME_WAV        = 22,
  222|       |	MIME_ARCHIVE    = 23,
  223|       |	MIME_EXE        = 24,
  224|       |	MIME_ODG        = 25,
  225|       |	MIME_GZIP       = 26,
  226|       |	MIME_XLSX       = 27,
  227|       |	MIME_PPTX       = 28,
  228|       |	MIME_MAX
  229|       |};
  230|       |
  231|       |extern const char *MimeNames[MIME_MAX];
  232|       |
  233|      0|MimeTypes mimeByStr(const char *mimeStr) {
  234|      0|	if (strcmp(mimeStr,"text/html") == 0)
  235|      0|		return MIME_HTML;
  236|      0|	if (strcmp(mimeStr,"text/plain") == 0)
  237|      0|		return MIME_TEXT;
  238|      0|	if (strcmp(mimeStr,"audio/mpeg") == 0)
  239|      0|		return MIME_MPEG;
  240|      0|	if (strcmp(mimeStr,"text/xml") == 0)
  241|      0|		return MIME_XML;
  242|      0|	if (strcmp(mimeStr,"text/vnd.wap.wml") == 0)
  243|      0|		return MIME_WML;
  244|      0|	if (strcmp(mimeStr,"application/pdf") == 0)
  245|      0|		return MIME_PDF;
  246|      0|	if (strcmp(mimeStr,"text/rtf") == 0)
  247|      0|		return MIME_RTF;
  248|      0|	if (strcmp(mimeStr,"application/msword") == 0)
  249|      0|		return MIME_DOC;
  250|      0|	if (strcmp(mimeStr,"application/x-shockwave-flash") == 0)
  251|      0|		return MIME_SWF;
  252|      0|	if (strcmp(mimeStr,"application/vnd.ms-excel") == 0)
  253|      0|		return MIME_XLS;
  254|      0|	if (strcmp(mimeStr,"application/vnd.ms-powerpoint") == 0)
  255|      0|		return MIME_PPT;
  256|      0|	if (strcmp(mimeStr,"application/xhtml+xml") == 0)
  257|      0|		return MIME_XHTMLXML;
  258|      0|	if (strcmp(mimeStr,"image/jpeg") == 0)
  259|      0|		return MIME_IMAGE_JPG;
  260|      0|	if (strcmp(mimeStr,"image/jpg") == 0)
  261|      0|		return MIME_IMAGE_JPG;
  262|      0|	if (strcmp(mimeStr,"image/pjpeg") == 0)
  263|      0|		return MIME_IMAGE_PJPG;
  264|      0|	if (strcmp(mimeStr,"image/png") == 0)
  265|      0|		return MIME_IMAGE_PNG;
  266|      0|	if (strcmp(mimeStr,"image/gif") == 0)
  267|      0|		return MIME_IMAGE_GIF;
  268|      0|	if (strcmp(mimeStr,"application/vnd.openxmlformats-officedocument.wordprocessingml.document") == 0)
  269|      0|		return MIME_DOCX;
  270|      0|	if (strcmp(mimeStr,"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet") == 0)
  271|      0|		return MIME_XLSX;
  272|      0|	if (strcmp(mimeStr,"application/vnd.openxmlformats-officedocument.presentationml.presentation") == 0)
  273|      0|		return MIME_PPTX;
  274|      0|	if (strcmp(mimeStr,"application/vnd.oasis.opendocument.text") == 0)
  275|      0|		return MIME_ODT;
  276|      0|	if (strcmp(mimeStr,"application/vnd.oasis.opendocument.presentation") == 0)
  277|      0|		return MIME_ODP;
  278|      0|	if (strcmp(mimeStr,"application/vnd.oasis.opendocument.spreadsheet") == 0)
  279|      0|		return MIME_ODS;
  280|      0|	if (strcmp(mimeStr,"application/vnd.oasis.opendocument.graphics") == 0)
  281|      0|		return MIME_ODG;
  282|      0|	if (strcmp(mimeStr, "image/x-ms-bmp") == 0)
  283|      0|		return MIME_IMAGE_BMP;
  284|      0|	if (strcmp(mimeStr, "audio/x-wav") == 0)
  285|      0|		return MIME_WAV;
  286|      0|	if (strcmp(mimeStr, "application/x-archive") == 0)
  287|      0|		return MIME_ARCHIVE;
  288|      0|	if (strcmp(mimeStr, "application/x-dosexec") == 0)
  289|      0|		return MIME_EXE;
  290|      0|	if (strcmp(mimeStr, "application/x-gzip") == 0)
  291|      0|		return MIME_GZIP;
  292|      0|	return MIME_UNKNOWN;
  293|      0|}
  294|       |
  295|      0|const char* strByMime(MimeTypes mime) {
  296|      0|	const char *res = 0;
  297|      0|	if (mime == MIME_HTML)
  298|      0|		res = "text/html";
  299|      0|	else if (mime == MIME_TEXT)
  300|      0|		res = "text/plain";
  301|      0|	else if (mime == MIME_MPEG)
  302|      0|		res = "audio/mpeg";
  303|      0|	else if (mime == MIME_XML)
  304|      0|		res = "text/xml";
  305|      0|	else if (mime == MIME_WML)
  306|      0|		res = "text/vnd.wap.wml";
  307|      0|	else if (mime == MIME_PDF)
  308|      0|		res = "application/pdf";
  309|      0|	else if (mime == MIME_RTF)
  310|      0|		res = "text/rtf";
  311|      0|	else if (mime == MIME_DOC)
  312|      0|		res = "application/msword";
  313|      0|	else if (mime == MIME_SWF)
  314|      0|		res = "application/x-shockwave-flash";
  315|      0|	else if (mime == MIME_XLS)
  316|      0|		res = "application/vnd.ms-excel";
  317|      0|	else if (mime == MIME_PPT)
  318|      0|		res = "application/vnd.ms-powerpoint";
  319|      0|	else if (mime == MIME_XHTMLXML)
  320|      0|		res = "application/xhtml+xml";
  321|      0|	else if (mime == MIME_IMAGE_JPG)
  322|      0|		res = "image/jpeg";
  323|      0|	else if (mime == MIME_IMAGE_PJPG)
  324|      0|		res = "image/pjpeg";
  325|      0|	else if (mime == MIME_IMAGE_PNG)
  326|      0|		res = "image/png";
  327|      0|	else if (mime == MIME_IMAGE_GIF)
  328|      0|		res = "image/gif";
  329|      0|	else if (mime == MIME_DOCX)
  330|      0|		res = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
  331|      0|	else if (mime == MIME_XLSX)
  332|      0|		res = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
  333|      0|	else if (mime == MIME_PPTX)
  334|      0|		res = "application/vnd.openxmlformats-officedocument.presentationml.presentation";
  335|      0|	else if (mime == MIME_ODT)
  336|      0|		res = "application/vnd.oasis.opendocument.text";
  337|      0|	else if (mime == MIME_ODP)
  338|      0|		res = "application/vnd.oasis.opendocument.presentation";
  339|      0|	else if (mime == MIME_ODS)
  340|      0|		res = "application/vnd.oasis.opendocument.spreadsheet";
  341|      0|	else if (mime == MIME_ODG)
  342|      0|		res = "application/vnd.oasis.opendocument.graphics";
  343|      0|	else if (mime == MIME_IMAGE_BMP)
  344|      0|		res = "image/x-ms-bmp";
  345|      0|	else if (mime == MIME_WAV)
  346|      0|		res = "audio/x-wav";
  347|      0|	else if (mime == MIME_ARCHIVE)
  348|      0|		res = "application/x-archive";
  349|      0|	else if (mime == MIME_EXE)
  350|      0|		res = "application/x-dosexec";
  351|      0|	else if (mime == MIME_GZIP)
  352|      0|		res = "application/x-gzip";
  353|      0|	return res;
  354|      0|}
  355|       |
  356|       |#endif

/home/johnpaul/pire/pire/stub/lexical_cast.h:
    1|       |/*
    2|       | * lexical_cast.h -- a replacement for boost::lexical_cast.
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#ifndef PIRE_STUB_LEXICAL_CAST_H_INCLUDED
   25|       |#define PIRE_STUB_LEXICAL_CAST_H_INCLUDED
   26|       |
   27|       |#include <stdexcept>
   28|       |#include <typeinfo>
   29|       |#include <sstream>
   30|       |#include <string>
   31|       |
   32|       |namespace Pire {
   33|       |
   34|       |class BadLexicalCast: public std::invalid_argument {
   35|       |public:
   36|      0|	BadLexicalCast(const std::string& what): std::invalid_argument(what) {}
   37|       |
   38|       |	template<class From, class To> static void Raise()
   39|       |	{
   40|       |		throw BadLexicalCast(
   41|       |			std::string("Cannot convert from ") + typeid(From).name()
   42|       |			+ " to " + typeid(To).name()
   43|       |		);
   44|       |	}
   45|       |};
   46|       |
   47|       |template<class T, class F> struct LexicalCaster {
   48|       |	static T lexical_cast(const F& f) {
   49|       |		std::stringstream s;
   50|       |		T t;
   51|       |		if (s << f && s >> t)
   52|       |			return t;
   53|       |		else {
   54|       |			BadLexicalCast::Raise<F, T>();
   55|       |			return T(); // Make compiler happy
   56|       |		}
   57|       |	}
   58|       |};
   59|       |
   60|       |template<class T, class F> T LexicalCast(const F& f) { return LexicalCaster<T, F>::lexical_cast(f); }
   61|       |	
   62|       |template<class F> std::string ToString(const F& f) { return LexicalCast<std::string>(f); }
   63|       |template<class T> T FromString(const std::string& s) { return LexicalCast<T>(s); }
   64|       |
   65|       |template<class Iter>
   66|       |inline std::string Join(Iter begin, Iter end, const std::string& separator)
   67|      0|{
   68|      0|	if (begin == end)
   69|      0|		return std::string();
   70|      0|	std::stringstream s;
   71|      0|	s << *begin;
   72|      0|	for (++begin; begin != end; ++begin)
   73|      0|		s << separator << *begin;
   74|      0|	return s.str();
   75|      0|}
   76|       |
   77|       |}
   78|       |
   79|       |#endif

/home/johnpaul/pire/pire/stub/memstreams.h:
    1|       |/*
    2|       | * memstreams.h -- a wrapper providing istream/ostream interface
    3|       | *                 for memory ranges.
    4|       | *
    5|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    6|       | *                          Alexander Gololobov <agololobov@gmail.com>
    7|       | *
    8|       | * This file is part of Pire, the Perl Incompatible
    9|       | * Regular Expressions library.
   10|       | *
   11|       | * Pire is free software: you can redistribute it and/or modify
   12|       | * it under the terms of the GNU Lesser Public License as published by
   13|       | * the Free Software Foundation, either version 3 of the License, or
   14|       | * (at your option) any later version.
   15|       | * 
   16|       | * Pire is distributed in the hope that it will be useful,
   17|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   18|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   19|       | * GNU Lesser Public License for more details.
   20|       | * You should have received a copy of the GNU Lesser Public License
   21|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   22|       | */
   23|       |
   24|       |
   25|       |#ifndef PIRE_STUB_MEMSTREAMS_H_INCLUDED
   26|       |#define PIRE_STUB_MEMSTREAMS_H_INCLUDED
   27|       |
   28|       |#include <vector>
   29|       |#include <iostream>
   30|       |#include <memory.h>
   31|       |
   32|       |namespace Pire {
   33|       |	
   34|       |	class MemBuffer {
   35|       |	public:
   36|      0|		MemBuffer(const std::vector<char>& buf): m_buf(&buf) {}
   37|      0|		const char* Data() const { return m_buf->empty() ? 0 : &(*m_buf)[0]; }
   38|      0|		size_t Size() const { return m_buf->size(); }
   39|       |		typedef std::vector<char>::const_iterator Iterator;
   40|      0|		Iterator Begin() const { return m_buf->begin(); }
   41|      0|		Iterator End() const { return m_buf->end(); }
   42|       |	private:
   43|       |		const std::vector<char>* m_buf;
   44|       |	};
   45|       |    
   46|       |	typedef MemBuffer::Iterator BufferIterator; // For compatibility with Arcadia
   47|       |    
   48|       |
   49|       |	class BufferOutputBase {
   50|       |	private:
   51|       |		class StreamBuf: public std::basic_streambuf<char> {
   52|       |		public:
   53|      0|			MemBuffer Buf() const { return MemBuffer(buf); }
   54|       |		protected:
   55|       |			typedef std::char_traits<char> Traits;
   56|       |
   57|       |			Traits::int_type overflow(Traits::int_type x)
   58|      0|			{
   59|      0|				buf.push_back((char) x);
   60|      0|				return x;
   61|      0|			}
   62|       |			
   63|       |			std::streamsize xsputn(const char* ptr, std::streamsize size)
   64|      0|			{
   65|      0|				buf.insert(buf.end(), ptr, ptr + size);
   66|      0|				return size;
   67|      0|			}
   68|       |		private:
   69|       |			std::vector<char> buf;
   70|       |		};
   71|       |
   72|       |	protected:
   73|       |		StreamBuf m_rdbuf;
   74|       |		
   75|       |	public:
   76|      0|		BufferOutputBase() { }
   77|      0|		MemBuffer Buffer() const { return m_rdbuf.Buf(); }
   78|       |	};
   79|       |
   80|       |	class BufferOutput: public BufferOutputBase, public std::ostream {
   81|       |	public:
   82|      0|		BufferOutput() : std::ostream(&m_rdbuf) {}
   83|       |	};
   84|       |    
   85|       |	class MemoryInputBase {
   86|       |	private:
   87|       |        
   88|       |		class StreamBuf: public std::basic_streambuf<char> {
   89|       |		public:
   90|       |			StreamBuf(const char* data, size_t size)
   91|      0|			{
   92|      0|				char* p = const_cast<char*>(data);
   93|      0|				setg(p, p, p+size);
   94|      0|			}
   95|       |			
   96|       |		protected:
   97|       |			std::streamsize xsgetn(char* ptr, std::streamsize size)
   98|      0|			{
   99|      0|				size = std::min<std::streamsize>(size, egptr() - gptr());
  100|      0|				memcpy(ptr, gptr(), size);
  101|      0|				gbump(size);
  102|      0|				return size;
  103|      0|			}
  104|       |		};
  105|       |
  106|       |	protected:
  107|       |		StreamBuf m_rdbuf;
  108|       |        
  109|       |	public:
  110|      0|		MemoryInputBase(const char* data, size_t size): m_rdbuf(data, size) {}
  111|       |	};	
  112|       |
  113|       |	class MemoryInput : protected MemoryInputBase, public std::istream {
  114|       |	public:
  115|       |		MemoryInput(const char* data, size_t size)
  116|       |			: MemoryInputBase(data, size)
  117|       |			, std::istream(&m_rdbuf)
  118|      0|		{
  119|      0|			exceptions(badbit | eofbit);
  120|      0|		}
  121|       |	};
  122|       |}
  123|       |
  124|       |#endif

/home/johnpaul/pire/pire/stub/noncopyable.h:
    1|       |/*
    2|       | * noncopyable.h -- a replacement for boost::noncopyable
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#ifndef PIRE_STUB_NONCOPYABLE_H_INCLUDED
   25|       |#define PIRE_STUB_NONCOPYABLE_H_INCLUDED
   26|       |
   27|       |namespace Pire {
   28|       |	
   29|       |	class NonCopyable {
   30|       |	public:
   31|      1|		NonCopyable() {}
   32|       |	private:
   33|       |		NonCopyable(const NonCopyable&);
   34|       |		NonCopyable& operator = (const NonCopyable&);
   35|       |	};
   36|       |}
   37|       |
   38|       |#endif

/home/johnpaul/pire/pire/stub/saveload.h:
    1|       |/*
    2|       | * saveload.h -- wrapper for istreams/ostreams with alignment feature
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#ifndef PIRE_STUB_SAVELOAD_H_INCLUDED
   25|       |#define PIRE_STUB_SAVELOAD_H_INCLUDED
   26|       |
   27|       |#include <sys/types.h>
   28|       |#include <iostream>
   29|       |#include <vector>
   30|       |#include "stl.h"
   31|       |
   32|       |namespace Pire {
   33|       |
   34|       |	namespace Impl {
   35|       |
   36|       |		template<class Char, class Traits = std::char_traits<Char> >
   37|       |		class CountingStreambuf: public std::basic_streambuf<Char, Traits> {
   38|       |		public:
   39|       |			CountingStreambuf(std::basic_streambuf<Char, Traits>* backend)
   40|       |				: m_backend(backend)
   41|       |				, m_read(0)
   42|       |				, m_written(0)
   43|       |			{}
   44|       |
   45|       |			std::streamsize read() const { return m_read; }
   46|       |			std::streamsize written() const { return m_written; }
   47|       |
   48|       |		protected:
   49|       |			typename Traits::int_type underflow()
   50|       |			{
   51|       |				typename Traits::int_type ret = m_backend->sgetc();
   52|       |				if (!Traits::eq_int_type(ret, Traits::eof())) {
   53|       |					m_ch = (Char) ret;
   54|       |					m_read += sizeof(Char);
   55|       |					this->setg(&m_ch, &m_ch, &m_ch+1);
   56|       |				}
   57|       |				return ret;
   58|       |			}
   59|       |
   60|       |			std::streamsize xsgetn(Char* data, std::streamsize len)
   61|       |			{
   62|       |				std::streamsize ret = m_backend->sgetn(data, len);
   63|       |				m_read += ret * sizeof(Char);
   64|       |				return ret;
   65|       |			}
   66|       |
   67|       |			typename Traits::int_type overflow(typename Traits::int_type c)
   68|       |			{
   69|       |				typename Traits::int_type ret = m_backend->sputc(c);
   70|       |				if (!Traits::eq_int_type(ret, Traits::eof()))
   71|       |					m_written += sizeof(Char);
   72|       |				return ret;
   73|       |			}
   74|       |
   75|       |			std::streamsize xsputn(const Char* data, std::streamsize len)
   76|       |			{
   77|       |				std::streamsize ret = m_backend->sputn(data, len);
   78|       |				m_written += ret * sizeof(Char);
   79|       |				return ret;
   80|       |			}
   81|       |
   82|       |			int sync() { return m_backend->pubsync(); }
   83|       |
   84|       |		private:
   85|       |			std::basic_streambuf<Char, Traits>* m_backend;
   86|       |			std::streamsize m_read;
   87|       |			std::streamsize m_written;
   88|       |			Char m_ch;
   89|       |		};
   90|       |
   91|       |		template<class Char, class Traits = std::char_traits<Char> >
   92|       |		class BasicAlignedInput: public std::basic_istream<Char, Traits> {
   93|       |		public:
   94|       |			BasicAlignedInput(std::basic_istream<Char, Traits>* backend)
   95|       |				: std::basic_istream<Char, Traits>(0)
   96|       |				, m_streambuf(backend->rdbuf())
   97|       |			{
   98|       |				rdbuf(&m_streambuf);
   99|       |			}
  100|       |
  101|       |			void Align(size_t divisor = sizeof(void*))
  102|       |			{
  103|       |				if (m_streambuf.read() & (divisor - 1)) {
  104|       |					size_t len = (divisor - (m_streambuf.read() & (divisor - 1))) / sizeof(Char);
  105|       |					if (m_fill.size() < len)
  106|       |						m_fill.resize(len);
  107|       |					this->read(&m_fill[0], len);
  108|       |				}
  109|       |			}
  110|       |		private:
  111|       |			CountingStreambuf<Char, Traits> m_streambuf;
  112|       |			std::vector<char> m_fill;
  113|       |		};
  114|       |
  115|       |		template<class Char, class Traits = std::char_traits<Char> >
  116|       |		class BasicAlignedOutput: public std::basic_ostream<Char, Traits> {
  117|       |		public:
  118|       |			BasicAlignedOutput(std::basic_ostream<Char, Traits>* backend)
  119|       |				: std::basic_ostream<Char, Traits>(0)
  120|       |				, m_streambuf(backend->rdbuf())
  121|       |			{
  122|       |				this->rdbuf(&m_streambuf);
  123|       |			}
  124|       |
  125|       |			void Align(size_t divisor = sizeof(void*))
  126|       |			{
  127|       |				if (m_streambuf.written() & (divisor - 1)) {
  128|       |					size_t len = (divisor - (m_streambuf.written() & (divisor - 1))) / sizeof(Char);
  129|       |					if (m_fill.size() < len)
  130|       |						m_fill.resize(len, char(0xCC));
  131|       |					this->write(&m_fill[0], len);
  132|       |				}
  133|       |			}
  134|       |		private:
  135|       |			CountingStreambuf<Char, Traits> m_streambuf;
  136|       |			std::vector<char> m_fill;
  137|       |		};
  138|       |	
  139|       |	}
  140|       |
  141|       |	typedef Impl::BasicAlignedInput<char> AlignedInput;
  142|       |	typedef Impl::BasicAlignedOutput<char> AlignedOutput;
  143|       |	template<class T>
  144|       |	void SavePodType(yostream* s, const T& t)
  145|       |	{
  146|       |		s->write((char*) &t, sizeof(t));
  147|       |	}
  148|       |	
  149|       |	template<class T>
  150|       |	void LoadPodType(yistream* s, T& t)
  151|      0|	{
  152|      0|		s->read((char*) &t, sizeof(t));
  153|      0|	}
  154|       |	template<class T>
  155|       |	void Save(yostream* s, const T& t) { t.Save(s);}
  156|       |
  157|       |	template<class T>
  158|       |	void Load(yistream* s, T& t) { t.Load(s);}
  159|       |
  160|       |	template<class T>
  161|       |	void SavePodArray(yostream* s, const T* t, size_t len)
  162|      0|	{
  163|      0|		s->write((char*) t, len * sizeof(*t));
  164|      0|	}
  165|       |
  166|       |	template<class T>
  167|       |	void LoadPodArray(yistream* s, T* t, size_t len)
  168|      0|	{
  169|      0|		s->read((char*) t, len * sizeof(*t));
  170|      0|	}
  171|       |};
  172|       |
  173|       |#endif

/home/johnpaul/pire/pire/stub/singleton.h:
    1|       |/*
    2|       | * singleton.h -- a simple singleton.
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#ifndef PIRE_STUB_SINGLETON_H_INCLUDED
   25|       |#define PIRE_STUB_SINGLETON_H_INCLUDED
   26|       |
   27|       |namespace Pire {
   28|       |	
   29|       |	// FIXME: not thread safe.
   30|       |	template<class T>
   31|       |	T* Singleton()
   32|  49.2M|	{
   33|  49.2M|		static T* p = 0;
   34|  49.2M|		if (!p)
   35|      2|			p = new T;
   36|  49.2M|		return p;
   37|  49.2M|	}
  ------------------
  | Unexecuted instantiation: _ZN4Pire9SingletonItEEPT_v
  ------------------
  | _ZN4Pire9SingletonINS_4TSetImSt4lessImESaImEEEEEPT_v:
  |   32|  49.1M|	{
  |   33|  49.1M|		static T* p = 0;
  |   34|  49.1M|		if (!p)
  |   35|      1|			p = new T;
  |   36|  49.1M|		return p;
  |   37|  49.1M|	}
  ------------------
  | Unexecuted instantiation: _ZN4Pire9SingletonINS_16NCodepagePrivate13TCodepagesMapEEEPT_v
  ------------------
  | classes.cpp:_ZN4Pire9SingletonINS_12_GLOBAL__N_116CharClassesTableEEEPT_v:
  |   32|   100k|	{
  |   33|   100k|		static T* p = 0;
  |   34|   100k|		if (!p)
  |   35|      1|			p = new T;
  |   36|   100k|		return p;
  |   37|   100k|	}
  ------------------
   38|       |	template<class T>
   39|  49.1M|	const T& DefaultValue() { return *Singleton<T>(); }
  ------------------
  | Unexecuted instantiation: _ZN4Pire12DefaultValueItEERKT_v
  ------------------
  | _ZN4Pire12DefaultValueINS_4TSetImSt4lessImESaImEEEEERKT_v:
  |   39|  49.1M|	const T& DefaultValue() { return *Singleton<T>(); }
  ------------------
   40|       |	
   41|       |};
   42|       |
   43|       |#endif

/home/johnpaul/pire/pire/stub/stl.h:
    1|       |/*
    2|       | * stl.h -- a wrapper around STL containers.
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |/*
   25|       | * This file is autogenerated; do not edit.
   26|       | * Modify tools/mkstl.pl and regenerate the file if you need to.
   27|       | */
   28|       |#ifndef PIRE_COMPAT_H_INCLUDED
   29|       |#define PIRE_COMPAT_H_INCLUDED
   30|       |
   31|       |#include "../defs.h"
   32|       |#include <string>
   33|       |#include <vector>
   34|       |#include <deque>
   35|       |#include <list>
   36|       |#include <map>
   37|       |#include <set>
   38|       |#include <bitset>
   39|       |#include <utility>
   40|       |#include <memory>
   41|       |#include <iostream>
   42|       |#include <algorithm>
   43|       |#include <stdexcept>
   44|       |#include <iterator>
   45|       |#include <functional>
   46|       |#include <initializer_list>
   47|       |#include <assert.h>
   48|       |
   49|       |#ifdef PIRE_CHECKED
   50|       |#define Y_ASSERT(e) assert(e)
   51|       |#else
   52|   375M|#define Y_ASSERT(e) do {} while (0)
   53|       |#endif
   54|       |
   55|       |#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)
   56|       |#pragma GCC diagnostic push
   57|       |#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
   58|       |#endif
   59|       |
   60|       |namespace Pire {
   61|       |	template< class T, class A = std::allocator<T> >
   62|       |	class TVector: public std::vector<T, A> {
   63|       |	public:
   64|   159M|		TVector(): std::vector<T, A>() {}
  ------------------
  | _ZN4Pire7TVectorISt10unique_ptrINS_7FeatureESt14default_deleteIS2_EESaIS5_EEC2Ev:
  |   64|   100k|		TVector(): std::vector<T, A>() {}
  ------------------
  | _ZN4Pire7TVectorIcSaIcEEC2Ev:
  |   64|  2.80M|		TVector(): std::vector<T, A>() {}
  ------------------
  | _ZN4Pire7TVectorINS0_ImSaImEEESaIS2_EEC2Ev:
  |   64|  2.90M|		TVector(): std::vector<T, A>() {}
  ------------------
  | _ZN4Pire7TVectorImSaImEEC2Ev:
  |   64|   152M|		TVector(): std::vector<T, A>() {}
  ------------------
  | Unexecuted instantiation: _ZN4Pire7TVectorIiSaIiEEC2Ev
  ------------------
  | _ZN4Pire7TVectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS6_EEC2Ev:
  |   64|  1.70M|		TVector(): std::vector<T, A>() {}
  ------------------
  | _ZN4Pire7TVectorINS_5ypairIjjEESaIS2_EEC2Ev:
  |   64|     22|		TVector(): std::vector<T, A>() {}
  ------------------
   65|       |
   66|       |		TVector(std::initializer_list<T> il): std::vector<T, A>(il) {}
   67|       |
   68|       |		template<class Arg1>
   69|  4.10M|		TVector(Arg1 arg1): std::vector<T, A>(arg1) {}
  ------------------
  | _ZN4Pire7TVectorINS0_IcSaIcEEESaIS2_EEC2ImEET_:
  |   69|   100k|		TVector(Arg1 arg1): std::vector<T, A>(arg1) {}
  ------------------
  | Unexecuted instantiation: _ZN4Pire7TVectorINS_4TSetItSt4lessItESaItEEESaIS5_EEC2ImEET_
  ------------------
  | Unexecuted instantiation: _ZN4Pire7TVectorINS_4TMapItNS_4TSetImSt4lessImESaImEEES3_ItESaISt4pairIKtS6_EEEESaISC_EEC2ImEET_
  ------------------
  | _ZN4Pire7TVectorINS0_INS0_ImSaImEEESaIS2_EEESaIS4_EEC2ImEET_:
  |   69|   100k|		TVector(Arg1 arg1): std::vector<T, A>(arg1) {}
  ------------------
  | _ZN4Pire7TVectorImSaImEEC2ImEET_:
  |   69|  2.80M|		TVector(Arg1 arg1): std::vector<T, A>(arg1) {}
  ------------------
  | _ZN4Pire7TVectorINS_7ybitsetILm264EEESaIS2_EEC2ImEET_:
  |   69|   100k|		TVector(Arg1 arg1): std::vector<T, A>(arg1) {}
  ------------------
  | _ZN4Pire7TVectorINS_4TMapImNS_4TSetImSt4lessImESaImEEES4_SaISt4pairIKmS6_EEEESaISB_EEC2IiEET_:
  |   69|   600k|		TVector(Arg1 arg1): std::vector<T, A>(arg1) {}
  ------------------
  | _ZN4Pire7TVectorINS_4TSetImSt4lessImESaImEEESaIS5_EEC2ImEET_:
  |   69|   100k|		TVector(Arg1 arg1): std::vector<T, A>(arg1) {}
  ------------------
  | _ZN4Pire7TVectorItSaItEEC2ImEET_:
  |   69|   100k|		TVector(Arg1 arg1): std::vector<T, A>(arg1) {}
  ------------------
  | _ZN4Pire7TVectorINS0_ImSaImEEESaIS2_EEC2ImEET_:
  |   69|   200k|		TVector(Arg1 arg1): std::vector<T, A>(arg1) {}
  ------------------
   70|       |
   71|       |		template<class Arg1, class Arg2>
   72|  4.00M|		TVector(Arg1 arg1, Arg2 arg2): std::vector<T, A>(arg1, arg2) {}
  ------------------
  | _ZN4Pire7TVectorIbSaIbEEC2ImbEET_T0_:
  |   72|   400k|		TVector(Arg1 arg1, Arg2 arg2): std::vector<T, A>(arg1, arg2) {}
  ------------------
  | _ZN4Pire7TVectorItSaItEEC2IitEET_T0_:
  |   72|  1.80M|		TVector(Arg1 arg1, Arg2 arg2): std::vector<T, A>(arg1, arg2) {}
  ------------------
  | _ZN4Pire7TVectorImSaImEEC2IimEET_T0_:
  |   72|   100k|		TVector(Arg1 arg1, Arg2 arg2): std::vector<T, A>(arg1, arg2) {}
  ------------------
  | Unexecuted instantiation: _ZN4Pire7TVectorIjSaIjEEC2IicEET_T0_
  ------------------
  | _ZN4Pire7TVectorIjSaIjEEC2IijEET_T0_:
  |   72|  1.70M|		TVector(Arg1 arg1, Arg2 arg2): std::vector<T, A>(arg1, arg2) {}
  ------------------
   73|       |
   74|       |		template<class Arg1, class Arg2, class Arg3>
   75|       |		TVector(Arg1 arg1, Arg2 arg2, Arg3 arg3): std::vector<T, A>(arg1, arg2, arg3) {}
   76|       |	};
   77|       |
   78|       |	template< class T, class A = std::allocator<T> >
   79|       |	class TDeque: public std::deque<T, A> {
   80|       |	public:
   81|   500k|		TDeque(): std::deque<T, A>() {}
  ------------------
  | _ZN4Pire6TDequeIjSaIjEEC2Ev:
  |   81|   100k|		TDeque(): std::deque<T, A>() {}
  ------------------
  | _ZN4Pire6TDequeImSaImEEC2Ev:
  |   81|   200k|		TDeque(): std::deque<T, A>() {}
  ------------------
  | _ZN4Pire6TDequeINS_7TVectorImSaImEEESaIS3_EEC2Ev:
  |   81|   100k|		TDeque(): std::deque<T, A>() {}
  ------------------
  | _ZN4Pire6TDequeINS_5ypairImmEESaIS2_EEC2Ev:
  |   81|   100k|		TDeque(): std::deque<T, A>() {}
  ------------------
   82|       |
   83|       |		template<class Arg1>
   84|       |		TDeque(Arg1 arg1): std::deque<T, A>(arg1) {}
   85|       |
   86|       |		template<class Arg1, class Arg2>
   87|       |		TDeque(Arg1 arg1, Arg2 arg2): std::deque<T, A>(arg1, arg2) {}
   88|       |
   89|       |		template<class Arg1, class Arg2, class Arg3>
   90|       |		TDeque(Arg1 arg1, Arg2 arg2, Arg3 arg3): std::deque<T, A>(arg1, arg2, arg3) {}
   91|       |	};
   92|       |
   93|       |	template< class T, class A = std::allocator<T> >
   94|       |	class TList: public std::list<T, A> {
   95|       |	public:
   96|       |		TList(): std::list<T, A>() {}
   97|       |
   98|       |		template<class Arg1>
   99|       |		TList(Arg1 arg1): std::list<T, A>(arg1) {}
  100|       |
  101|       |		template<class Arg1, class Arg2>
  102|       |		TList(Arg1 arg1, Arg2 arg2): std::list<T, A>(arg1, arg2) {}
  103|       |
  104|       |		template<class Arg1, class Arg2, class Arg3>
  105|       |		TList(Arg1 arg1, Arg2 arg2, Arg3 arg3): std::list<T, A>(arg1, arg2, arg3) {}
  106|       |	};
  107|       |
  108|       |	template< class K, class V, class C = std::less<K>, class A = std::allocator< std::pair<const K, V> > >
  109|       |	class TMap: public std::map<K, V, C, A> {
  110|       |	public:
  111|  20.7M|		TMap(): std::map<K, V, C, A>() {}
  ------------------
  | Unexecuted instantiation: _ZN4Pire4TMapItNS_4TSetImSt4lessImESaImEEES2_ItESaISt4pairIKtS5_EEEC2Ev
  ------------------
  | _ZN4Pire4TMapIbmSt4lessIbESaISt4pairIKbmEEEC2Ev:
  |  111|   100k|		TMap(): std::map<K, V, C, A>() {}
  ------------------
  | _ZN4Pire4TMapImNS_4TSetImSt4lessImESaImEEES3_SaISt4pairIKmS5_EEEC2Ev:
  |  111|  14.1M|		TMap(): std::map<K, V, C, A>() {}
  ------------------
  | _ZN4Pire4TMapItNS_5ypairImNS_7TVectorItSaItEEEEESt4lessItESaISt4pairIKtS5_EEEC2Ev:
  |  111|   800k|		TMap(): std::map<K, V, C, A>() {}
  ------------------
  | _ZN4Pire4TMapIttSt4lessItESaISt4pairIKttEEEC2Ev:
  |  111|   800k|		TMap(): std::map<K, V, C, A>() {}
  ------------------
  | _ZN4Pire4TMapImNS0_ImmSt4lessImESaISt4pairIKmmEEEES2_SaIS3_IS4_S7_EEEC2Ev:
  |  111|   700k|		TMap(): std::map<K, V, C, A>() {}
  ------------------
  | _ZN4Pire4TMapImmSt4lessImESaISt4pairIKmmEEEC2Ev:
  |  111|   600k|		TMap(): std::map<K, V, C, A>() {}
  ------------------
  | _ZN4Pire4TMapIcmSt4lessIcESaISt4pairIKcmEEEC2Ev:
  |  111|  1.70M|		TMap(): std::map<K, V, C, A>() {}
  ------------------
  | _ZN4Pire4TMapINS_5ypairImcEEmSt4lessIS2_ESaISt4pairIKS2_mEEEC2Ev:
  |  111|  1.70M|		TMap(): std::map<K, V, C, A>() {}
  ------------------
  | _ZN4Pire4TMapINS_7TVectorImSaImEEEmSt4lessIS3_ESaISt4pairIKS3_mEEEC2Ev:
  |  111|   100k|		TMap(): std::map<K, V, C, A>() {}
  ------------------
  | _ZN4Pire4TMapImNS_7TVectorImSaImEEESt4lessImESaISt4pairIKmS3_EEEC2Ev:
  |  111|   100k|		TMap(): std::map<K, V, C, A>() {}
  ------------------
  | classes.cpp:_ZN4Pire4TMapIjNS_12_GLOBAL__N_116CharClassesTable9CharClassESt4lessIjESaISt4pairIKjS3_EEEC2Ev:
  |  111|      1|		TMap(): std::map<K, V, C, A>() {}
  ------------------
  112|       |
  113|       |		template<class Arg1>
  114|       |		TMap(Arg1 arg1): std::map<K, V, C, A>(arg1) {}
  115|       |
  116|       |		template<class Arg1, class Arg2>
  117|       |		TMap(Arg1 arg1, Arg2 arg2): std::map<K, V, C, A>(arg1, arg2) {}
  118|       |
  119|       |		template<class Arg1, class Arg2, class Arg3>
  120|       |		TMap(Arg1 arg1, Arg2 arg2, Arg3 arg3): std::map<K, V, C, A>(arg1, arg2, arg3) {}
  121|       |	};
  122|       |
  123|       |	template< class T, class C = std::less<T>, class A = std::allocator<T> >
  124|       |	class TSet: public std::set<T, C, A> {
  125|       |	public:
  126|   261M|		TSet(): std::set<T, C, A>() {}
  ------------------
  | _ZN4Pire4TSetImSt4lessImESaImEEC2Ev:
  |  126|   251M|		TSet(): std::set<T, C, A>() {}
  ------------------
  | Unexecuted instantiation: _ZN4Pire4TSetItSt4lessItESaItEEC2Ev
  ------------------
  | _ZN4Pire4TSetINS_5ypairItmEESt4lessIS2_ESaIS2_EEC2Ev:
  |  126|  2.80M|		TSet(): std::set<T, C, A>() {}
  ------------------
  | _ZN4Pire4TSetINS_5ypairImcEESt4lessIS2_ESaIS2_EEC2Ev:
  |  126|  1.70M|		TSet(): std::set<T, C, A>() {}
  ------------------
  | _ZN4Pire4TSetIcSt4lessIcESaIcEEC2Ev:
  |  126|  1.70M|		TSet(): std::set<T, C, A>() {}
  ------------------
  | _ZN4Pire4TSetINS_7TVectorIjSaIjEEESt4lessIS3_ESaIS3_EEC2Ev:
  |  126|  3.40M|		TSet(): std::set<T, C, A>() {}
  ------------------
  | Unexecuted instantiation: _ZN4Pire4TSetIjSt4lessIjESaIjEEC2Ev
  ------------------
  127|       |
  128|       |		TSet(std::initializer_list<T> il): std::set<T, C, A>(il) {}
  129|       |
  130|       |		template<class Arg1>
  131|       |		TSet(Arg1 arg1): std::set<T, C, A>(arg1) {}
  132|       |
  133|       |		template<class Arg1, class Arg2>
  134|       |		TSet(Arg1 arg1, Arg2 arg2): std::set<T, C, A>(arg1, arg2) {}
  135|       |
  136|       |		template<class Arg1, class Arg2, class Arg3>
  137|       |		TSet(Arg1 arg1, Arg2 arg2, Arg3 arg3): std::set<T, C, A>(arg1, arg2, arg3) {}
  138|       |	};
  139|       |
  140|       |	template< size_t N >
  141|       |	class ybitset: public std::bitset<N> {
  142|       |	public:
  143|  2.80M|		ybitset(): std::bitset<N>() {}
  144|       |
  145|       |		template<class Arg1>
  146|       |		ybitset(Arg1 arg1): std::bitset<N>(arg1) {}
  147|       |
  148|       |		template<class Arg1, class Arg2>
  149|       |		ybitset(Arg1 arg1, Arg2 arg2): std::bitset<N>(arg1, arg2) {}
  150|       |
  151|       |		template<class Arg1, class Arg2, class Arg3>
  152|       |		ybitset(Arg1 arg1, Arg2 arg2, Arg3 arg3): std::bitset<N>(arg1, arg2, arg3) {}
  153|       |	};
  154|       |
  155|       |	template< class A, class B >
  156|       |	class ypair: public std::pair<A, B> {
  157|       |	public:
  158|  1.70M|		ypair(): std::pair<A, B>() {}
  159|       |
  160|       |		template<class Arg1>
  161|   100M|		ypair(Arg1 arg1): std::pair<A, B>(arg1) {}
  ------------------
  | _ZN4Pire5ypairItmEC2INS0_ImmEEEET_:
  |  161|   100M|		ypair(Arg1 arg1): std::pair<A, B>(arg1) {}
  ------------------
  | Unexecuted instantiation: _ZN4Pire5ypairImcEC2INS0_ImhEEEET_
  ------------------
  162|       |
  163|       |		template<class Arg1, class Arg2>
  164|   153M|		ypair(Arg1 arg1, Arg2 arg2): std::pair<A, B>(arg1, arg2) {}
  ------------------
  | Unexecuted instantiation: _ZN4Pire5ypairImcEC2ImcEET_T0_
  ------------------
  | Unexecuted instantiation: _ZN4Pire5ypairImhEC2ImhEET_T0_
  ------------------
  | Unexecuted instantiation: _ZN4Pire5ypairItNS_4TSetImSt4lessImESaImEEEEC2ItS5_EET_T0_
  ------------------
  | _ZN4Pire5ypairImNS_4TSetImSt4lessImESaImEEEEC2ImS5_EET_T0_:
  |  164|   900k|		ypair(Arg1 arg1, Arg2 arg2): std::pair<A, B>(arg1, arg2) {}
  ------------------
  | _ZN4Pire5ypairImmEC2ImmEET_T0_:
  |  164|   147M|		ypair(Arg1 arg1, Arg2 arg2): std::pair<A, B>(arg1, arg2) {}
  ------------------
  | _ZN4Pire5ypairItNS0_ImNS_7TVectorItSaItEEEEEEC2ItS4_EET_T0_:
  |  164|  1.80M|		ypair(Arg1 arg1, Arg2 arg2): std::pair<A, B>(arg1, arg2) {}
  ------------------
  | _ZN4Pire5ypairImNS_7TVectorItSaItEEEEC2ImS3_EET_T0_:
  |  164|  1.80M|		ypair(Arg1 arg1, Arg2 arg2): std::pair<A, B>(arg1, arg2) {}
  ------------------
  | _ZN4Pire5ypairINS_4TSetINS_7TVectorIjSaIjEEESt4lessIS4_ESaIS4_EEEbEC2IS8_bEET_T0_:
  |  164|  1.70M|		ypair(Arg1 arg1, Arg2 arg2): std::pair<A, B>(arg1, arg2) {}
  ------------------
  | Unexecuted instantiation: _ZN4Pire5ypairIiiEC2IiiEET_T0_
  ------------------
  | _ZN4Pire5ypairIjjEC2IjjEET_T0_:
  |  164|     14|		ypair(Arg1 arg1, Arg2 arg2): std::pair<A, B>(arg1, arg2) {}
  ------------------
  165|       |
  166|       |		template<class Arg1, class Arg2, class Arg3>
  167|       |		ypair(Arg1 arg1, Arg2 arg2, Arg3 arg3): std::pair<A, B>(arg1, arg2, arg3) {}
  168|       |	};
  169|       |
  170|       |	template< class A, class B, class R >
  171|       |	class ybinary_function: public std::binary_function<A, B, R> {
  172|       |	public:
  173|   400k|		ybinary_function(): std::binary_function<A, B, R>() {}
  174|       |
  175|       |		template<class Arg1>
  176|       |		ybinary_function(Arg1 arg1): std::binary_function<A, B, R>(arg1) {}
  177|       |
  178|       |		template<class Arg1, class Arg2>
  179|       |		ybinary_function(Arg1 arg1, Arg2 arg2): std::binary_function<A, B, R>(arg1, arg2) {}
  180|       |
  181|       |		template<class Arg1, class Arg2, class Arg3>
  182|       |		ybinary_function(Arg1 arg1, Arg2 arg2, Arg3 arg3): std::binary_function<A, B, R>(arg1, arg2, arg3) {}
  183|       |	};
  184|       |
  185|       |	typedef std::string ystring;
  186|       |	typedef std::istream yistream;
  187|       |	typedef std::ostream yostream;
  188|       |
  189|       |	template<class A, class B>
  190|   152M|	inline ypair<A, B> ymake_pair(A a, B b) { return ypair<A, B>(a, b); }
  ------------------
  | Unexecuted instantiation: _ZN4Pire10ymake_pairIPmS1_EENS_5ypairIT_T0_EES3_S4_
  ------------------
  | Unexecuted instantiation: _ZN4Pire10ymake_pairImcEENS_5ypairIT_T0_EES2_S3_
  ------------------
  | Unexecuted instantiation: _ZN4Pire10ymake_pairImhEENS_5ypairIT_T0_EES2_S3_
  ------------------
  | Unexecuted instantiation: _ZN4Pire10ymake_pairItNS_4TSetImSt4lessImESaImEEEEENS_5ypairIT_T0_EES7_S8_
  ------------------
  | _ZN4Pire10ymake_pairImNS_4TSetImSt4lessImESaImEEEEENS_5ypairIT_T0_EES7_S8_:
  |  190|   900k|	inline ypair<A, B> ymake_pair(A a, B b) { return ypair<A, B>(a, b); }
  ------------------
  | _ZN4Pire10ymake_pairImmEENS_5ypairIT_T0_EES2_S3_:
  |  190|   147M|	inline ypair<A, B> ymake_pair(A a, B b) { return ypair<A, B>(a, b); }
  ------------------
  | _ZN4Pire10ymake_pairItNS_5ypairImNS_7TVectorItSaItEEEEEEENS1_IT_T0_EES6_S7_:
  |  190|  1.80M|	inline ypair<A, B> ymake_pair(A a, B b) { return ypair<A, B>(a, b); }
  ------------------
  | _ZN4Pire10ymake_pairImNS_7TVectorItSaItEEEEENS_5ypairIT_T0_EES5_S6_:
  |  190|  1.80M|	inline ypair<A, B> ymake_pair(A a, B b) { return ypair<A, B>(a, b); }
  ------------------
  | _ZN4Pire10ymake_pairIjjEENS_5ypairIT_T0_EES2_S3_:
  |  190|     14|	inline ypair<A, B> ymake_pair(A a, B b) { return ypair<A, B>(a, b); }
  ------------------
  191|       |
  192|       |	template<class T>
  193|       |	inline const T& ymin(const T& a, const T& b) { return std::min(a, b); }
  194|       |
  195|       |	template<class T>
  196|       |	inline const T& ymax(const T& a, const T& b) { return std::max(a, b); }
  197|       |
  198|       |	PIRE_IFDEBUG(static std::ostream& Cdbg = std::clog);
  199|       |
  200|      0|	inline yostream& Endl(yostream& s) { return std::endl(s); }
  201|       |
  202|       |	template<class T>
  203|  3.60M|	static inline void DoSwap(T& a, T& b) { std::swap(a, b); }
  ------------------
  | Unexecuted instantiation: fuzz.cpp:_ZN4PireL6DoSwapISt10unique_ptrINS_3Any14AbstractHolderESt14default_deleteIS3_EEEEvRT_S8_
  ------------------
  | Unexecuted instantiation: fuzz.cpp:_ZN4PireL6DoSwapIjEEvRT_S2_
  ------------------
  | Unexecuted instantiation: fuzz.cpp:_ZN4PireL6DoSwapIPtEEvRT_S3_
  ------------------
  | Unexecuted instantiation: fuzz.cpp:_ZN4PireL6DoSwapISt10unique_ptrIA_cSt14default_deleteIS2_EEEEvRT_S7_
  ------------------
  | Unexecuted instantiation: fuzz.cpp:_ZN4PireL6DoSwapImEEvRT_S2_
  ------------------
  | Unexecuted instantiation: fuzz.cpp:_ZN4PireL6DoSwapIPmEEvRT_S3_
  ------------------
  | Unexecuted instantiation: fuzz.cpp:_ZN4PireL6DoSwapIPbEEvRT_S3_
  ------------------
  | Unexecuted instantiation: fuzz.cpp:_ZN4PireL6DoSwapIPjEEvRT_S3_
  ------------------
  | Unexecuted instantiation: fuzz.cpp:_ZN4PireL6DoSwapINS_7TVectorIPvSaIS2_EEEEEvRT_S6_
  ------------------
  | Unexecuted instantiation: fuzz.cpp:_ZN4PireL6DoSwapINS_7TVectorINS1_IjSaIjEEESaIS3_EEEEEvRT_S7_
  ------------------
  | Unexecuted instantiation: fuzz.cpp:_ZN4PireL6DoSwapIPNS_7TVectorINS1_IjSaIjEEESaIS3_EEEEEvRT_S8_
  ------------------
  | Unexecuted instantiation: fuzz.cpp:_ZN4PireL6DoSwapIbEEvRT_S2_
  ------------------
  | Unexecuted instantiation: fuzz.cpp:_ZN4PireL6DoSwapIPNS_11SlowScanner5StateEEEvRT_S5_
  ------------------
  | fsm.cpp:_ZN4PireL6DoSwapImEEvRT_S2_:
  |  203|   200k|	static inline void DoSwap(T& a, T& b) { std::swap(a, b); }
  ------------------
  | fsm.cpp:_ZN4PireL6DoSwapINS_7TVectorINS_4TMapImNS_4TSetImSt4lessImESaImEEES5_SaISt4pairIKmS7_EEEESaISC_EEEEEvRT_SG_:
  |  203|   200k|	static inline void DoSwap(T& a, T& b) { std::swap(a, b); }
  ------------------
  | fsm.cpp:_ZN4PireL6DoSwapINS_4TSetImSt4lessImESaImEEEEEvRT_S7_:
  |  203|   200k|	static inline void DoSwap(T& a, T& b) { std::swap(a, b); }
  ------------------
  | fsm.cpp:_ZN4PireL6DoSwapINS_9PartitionItNS_3Fsm15LettersEqualityEEEEEvRT_S6_:
  |  203|   200k|	static inline void DoSwap(T& a, T& b) { std::swap(a, b); }
  ------------------
  | fsm.cpp:_ZN4PireL6DoSwapIbEEvRT_S2_:
  |  203|   400k|	static inline void DoSwap(T& a, T& b) { std::swap(a, b); }
  ------------------
  | fsm.cpp:_ZN4PireL6DoSwapINS_4TMapImNS1_ImmSt4lessImESaISt4pairIKmmEEEES3_SaIS4_IS5_S8_EEEEEEvRT_SD_:
  |  203|   200k|	static inline void DoSwap(T& a, T& b) { std::swap(a, b); }
  ------------------
  | fsm.cpp:_ZN4PireL6DoSwapINS_4TMapImmSt4lessImESaISt4pairIKmmEEEEEEvRT_SA_:
  |  203|   200k|	static inline void DoSwap(T& a, T& b) { std::swap(a, b); }
  ------------------
  | re_lexer.cpp:_ZN4PireL6DoSwapISt10unique_ptrINS_3Any14AbstractHolderESt14default_deleteIS3_EEEEvRT_S8_:
  |  203|  1.90M|	static inline void DoSwap(T& a, T& b) { std::swap(a, b); }
  ------------------
  | Unexecuted instantiation: read_unicode.cpp:_ZN4PireL6DoSwapISt10unique_ptrINS_3Any14AbstractHolderESt14default_deleteIS3_EEEEvRT_S8_
  ------------------
  | Unexecuted instantiation: re_parser.cpp:_ZN4PireL6DoSwapISt10unique_ptrINS_3Any14AbstractHolderESt14default_deleteIS3_EEEEvRT_S8_
  ------------------
  | re_parser.cpp:_ZN4PireL6DoSwapINS_3AnyEEEvRT_S3_:
  |  203|   100k|	static inline void DoSwap(T& a, T& b) { std::swap(a, b); }
  ------------------
  | Unexecuted instantiation: classes.cpp:_ZN4PireL6DoSwapISt10unique_ptrINS_3Any14AbstractHolderESt14default_deleteIS3_EEEEvRT_S8_
  ------------------
  204|       |
  205|       |	template<class Iter, class T>
  206|      0|	static inline void Fill(Iter begin, Iter end, T t) { std::fill(begin, end, t); }
  207|       |	
  208|       |	template <class I, class T, class C>
  209|   400k|	static inline I LowerBound(I f, I l, const T& v, C c) {
  210|   400k|		return std::lower_bound(f, l, v, c);
  211|   400k|	}
  212|       |
  213|       |	class Error: public std::runtime_error {
  214|       |	public:
  215|      0|		Error(const char* msg): std::runtime_error(msg) {}
  216|      0|		Error(const ystring& msg): std::runtime_error(msg) {}
  217|       |	};
  218|       |
  219|       |	template <class T1, class T2, class Stream>
  220|       |	Stream& operator << (Stream& stream, const ypair<T1, T2>& val)
  221|       |	{
  222|       |		stream << "[" << val.first << ", " << val.second << "]";
  223|       |		return stream;
  224|       |	}
  225|       |
  226|       |}
  227|       |
  228|       |#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)
  229|       |#pragma GCC diagnostic pop
  230|       |#endif
  231|       |
  232|       |#endif

/home/johnpaul/pire/pire/stub/unidata_h.h:
    1|       |/*
    2|       | * Copyright (c) 2000-2010, Yandex
    3|       | *
    4|       | * This file is free software: you can redistribute it and/or modify
    5|       | * it under the terms of the GNU Lesser Public License as published by
    6|       | * the Free Software Foundation, either version 3 of the License, or
    7|       | * (at your option) any later version.
    8|       | * 
    9|       | * This file is distributed in the hope that it will be useful,
   10|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   11|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   12|       | * GNU Lesser Public License for more details.
   13|       | * You should have received a copy of the GNU Lesser Public License
   14|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   15|       | */
   16|       |
   17|       |
   18|       |#ifndef PIRE_STUB_UNIDATA_H_H
   19|       |#define PIRE_STUB_UNIDATA_H_H
   20|       |
   21|       |
   22|       |
   23|       |enum WC_TYPE {
   24|       |	// Category           // DefaultChar
   25|       |	Lu_UPPER     =  1, // ''
   26|       |	Ll_LOWER     =  2, // ''
   27|       |	Lt_TITLE     =  3, // ''
   28|       |	Lm_EXTENDER  =  4, // '-'
   29|       |	Lm_LETTER    =  5, // ''
   30|       |	Lo_OTHER     =  6, // '?'
   31|       |	Lo_IDEOGRAPH =  7, // '?'
   32|       |	Lo_KATAKANA  =  8, // '?'
   33|       |	Lo_HIRAGANA  =  9, // '?'
   34|       |	Lo_LEADING   = 10, // '?'
   35|       |	Lo_VOWEL     = 11, // '?'
   36|       |	Lo_TRAILING  = 12, // '?'
   37|       |
   38|       |	Mn_NONSPACING= 13, // '`'
   39|       |	Me_ENCLOSING = 14, // '`'
   40|       |	Mc_SPACING   = 15, // '`'
   41|       |
   42|       |	Nd_DIGIT     = 16, // '9'           // convert to digit
   43|       |	Nl_LETTER    = 17, // 'X'           // X,V,C,L,I ...
   44|       |	Nl_IDEOGRAPH = 18, // '?'
   45|       |	No_OTHER     = 19, // '9'
   46|       |
   47|       |	Zs_SPACE     = 20, // ' ' [\40\240] SPACE ... NO-BREAK SPACE (00A0)
   48|       |	Zs_ZWSPACE   = 21, // ' '           // nothing ?
   49|       |	Zl_LINE      = 22, // '\n'
   50|       |	Zp_PARAGRAPH = 23, // '\n'
   51|       |
   52|       |	Cc_ASCII     = 24, // '\x1A'        // can not happen
   53|       |	Cc_SPACE     = 25, // '\x1A'        // can not happen
   54|       |	Cc_SEPARATOR = 26, // '\x1A'        // can not happen
   55|       |
   56|       |	Cf_FORMAT    = 27, // '\x1A'        // nothing ?
   57|       |	Cf_JOIN      = 28, // '\x1A'        // nothing ?
   58|       |	Cf_BIDI      = 29, // '\x1A'        // nothing ?
   59|       |	Cf_ZWNBSP    = 30, // '\x1A'        // nothing ?
   60|       |
   61|       |	Cn_UNASSIGNED=  0, // '?'
   62|       |	Co_PRIVATE   =  0, // '?'
   63|       |	Cs_LOW       = 31, // '?'
   64|       |	Cs_HIGH      = 32, // '?'
   65|       |
   66|       |	Pd_DASH      = 33, // '-'
   67|       |	Pd_HYPHEN    = 34, // '-' [-]       HYPHEN-MINUS
   68|       |	Ps_START     = 35, // '(' [([{]     LEFT PARENTHESIS ... LEFT CURLY BRACKET
   69|       |	Ps_QUOTE     = 36, // '"'
   70|       |	Pe_END       = 37, // ')' [)]}]     RIGHT PARENTHESIS ... RIGHT CURLY BRACKET
   71|       |	Pe_QUOTE     = 38, // '"'
   72|       |	Pi_QUOTE     = 39, // '"'
   73|       |	Pf_QUOTE     = 40, // '"'
   74|       |	Pc_CONNECTOR = 41, // '_' [_]       LOW LINE
   75|       |	Po_OTHER     = 42, // '*' [#%&*/@\] NUMBER SIGN ... REVERSE SOLIDUS
   76|       |	Po_QUOTE     = 43, // '"' ["]       QUOTATION MARK
   77|       |	Po_TERMINAL  = 44, // '.' [!,.:;?]  EXCLAMATION MARK ... QUESTION MARK
   78|       |	Po_EXTENDER  = 45, // '-' []       MIDDLE DOT (00B7)
   79|       |	Po_HYPHEN    = 46, // '-'
   80|       |
   81|       |	Sm_MATH      = 47, // '=' [+<=>|~]  PLUS SIGN ... TILDE
   82|       |	Sm_MINUS     = 48, // '-'
   83|       |	Sc_CURRENCY  = 49, // '$' [$]       DOLLAR SIGN
   84|       |	Sk_MODIFIER  = 50, // '`' [^`]      CIRCUMFLEX ACCENT ... GRAVE ACCENT
   85|       |	So_OTHER     = 51, // '' []       DEGREE SIGN (00B0)
   86|       |
   87|       |	Ps_SINGLE_QUOTE = 52, // '\'' [']   OPENING SINGLE QUOTE
   88|       |	Pe_SINGLE_QUOTE = 53, // '\'' [']   CLOSING SINGLE QUOTE
   89|       |	Pi_SINGLE_QUOTE = 54, // '\'' [']   INITIAL SINGLE QUOTE
   90|       |	Pf_SINGLE_QUOTE = 55, // '\'' [']   FINAL SINGLE QUOTE
   91|       |	Po_SINGLE_QUOTE = 56, // '\'' [']   APOSTROPHE and PRIME
   92|       |
   93|       |	CCL_NUM      = 57,
   94|       |	CCL_MASK     = 0x3F,
   95|       |
   96|       |	TO_LOWER     = 1<< 6,
   97|       |	TO_UPPER     = 1<< 7,
   98|       |	TO_TITLE     = 1<< 8,
   99|       |
  100|       |	IS_XDIGIT    = 1<< 9,
  101|       |	IS_DIGIT     = 1<<10,
  102|       |	IS_NONBREAK  = 1<<11,
  103|       |
  104|       |	IS_PRIVATE   = 1<<12,
  105|       |	IS_ORDERED   = 1<<13,
  106|       |
  107|       |	IS_COMPAT    = 1<<14,
  108|       |	IS_CANON     = 1<<15,
  109|       |
  110|       |	BIDI_OFFSET   =  16,
  111|       |	SVAL_OFFSET   =  22,
  112|       |};
  113|       |
  114|       |const size_t DEFCHAR_BUF = 58; // CCL_NUM + 1
  115|       |
  116|       |extern const ui32 unicode_types[];
  117|       |extern const wchar32 decomp_mapping[];
  118|       |extern const ui32 *unicode_pages[];
  119|       |
  120|       |extern const unsigned DECOMP_OFFSET;
  121|       |extern const unsigned DECOMP_MASK;
  122|       |extern const unsigned LENGTH_OFFSET;
  123|       |extern const unsigned LENGTH_MASK;
  124|       |extern const unsigned TYPES_OFFSET;
  125|       |extern const unsigned TYPES_MASK;
  126|       |
  127|      0|#define _(i) (ULL(1)<<(i))
  128|       |
  129|       |ui32 _runeinfo(wchar32 ch)
  130|      0|{
  131|      0|	if (ch > 0xFFFF)
  132|      0|		return _runeinfo(0xE001);//as characters from Private Use Zone
  133|      0|	return unicode_pages[(ch>>5)&0x7FF][ch&0x1F];
  134|      0|}
  135|       |ui32 wc_info(wchar32 ch)
  136|      0|{
  137|      0|	return unicode_types[(_runeinfo(ch)>>TYPES_OFFSET) & TYPES_MASK];
  138|      0|}
  139|       |WC_TYPE wc_type(wchar32 ch)
  140|      0|{
  141|      0|	return (WC_TYPE)(wc_info(ch) & CCL_MASK);
  142|      0|}
  143|       |unsigned get_decomp_mapping(wchar32 ch, const wchar32 *&decomp_p, unsigned &decomp_len)
  144|      0|{
  145|      0|	ui32 info = _runeinfo(ch);
  146|      0|	decomp_len = (info>>LENGTH_OFFSET)&LENGTH_MASK;
  147|      0|	decomp_p = &decomp_mapping[(info>>DECOMP_OFFSET) & DECOMP_MASK];
  148|      0|	return decomp_len;
  149|      0|}
  150|       |bool wc_istype(wchar32 ch, ui64 type_bits)
  151|      0|{
  152|      0|	return (_(wc_type(ch)) & type_bits) != 0;
  153|      0|}
  154|       |
  155|       |// all usefull properties
  156|       |
  157|       |bool is_unicode_space(wchar32 ch) // is_space without \n,\r,\v,\f,\40,\t
  158|      0|{
  159|      0|	return wc_istype(ch, _(Zs_SPACE)|_(Zs_ZWSPACE)|_(Zl_LINE)|_(Zp_PARAGRAPH));
  160|      0|}
  161|       |bool is_whitespace(wchar32 ch)
  162|      0|{
  163|      0|	return wc_istype(ch, _(Cc_SPACE)|_(Zs_SPACE)|_(Zs_ZWSPACE)|_(Zl_LINE)|_(Zp_PARAGRAPH));
  164|      0|}
  165|       |bool is_ascii_cntrl(wchar32 ch)
  166|      0|{
  167|      0|	return wc_istype(ch, _(Cc_ASCII)|_(Cc_SPACE)|_(Cc_SEPARATOR));
  168|      0|}
  169|       |bool is_bidi_cntrl(wchar32 ch)
  170|      0|{
  171|      0|	return wc_istype(ch, _(Cf_BIDI));
  172|      0|}
  173|       |bool is_join_cntrl(wchar32 ch)
  174|      0|{
  175|      0|	return wc_istype(ch, _(Cf_JOIN));
  176|      0|}
  177|       |bool is_format_cntrl(wchar32 ch)
  178|      0|{
  179|      0|	return wc_istype(ch, _(Cf_FORMAT));
  180|      0|}
  181|       |bool is_ignorable_cntrl(wchar32 ch)
  182|      0|{
  183|      0|	return wc_istype(ch, _(Cf_FORMAT)|_(Cf_JOIN)|_(Cf_BIDI)|_(Cf_ZWNBSP));
  184|      0|}
  185|       |bool is_cntrl(wchar32 ch)
  186|      0|{
  187|      0|	return wc_istype(ch,
  188|      0|		_(Cf_FORMAT)|_(Cf_JOIN)|_(Cf_BIDI)|_(Cf_ZWNBSP)|
  189|      0|		_(Cc_ASCII)|_(Cc_SPACE)|_(Cc_SEPARATOR)
  190|      0|	);
  191|      0|}
  192|       |bool is_zerowidth(wchar32 ch)
  193|      0|{
  194|      0|	return wc_istype(ch, _(Cf_FORMAT)|_(Cf_JOIN)|_(Cf_BIDI)|_(Cf_ZWNBSP)|_(Zs_ZWSPACE));
  195|      0|}
  196|       |bool is_line_sep(wchar32 ch)
  197|      0|{
  198|      0|	return wc_istype(ch, _(Zl_LINE));
  199|      0|}
  200|       |bool is_para_sep(wchar32 ch)
  201|      0|{
  202|      0|	return wc_istype(ch, _(Zp_PARAGRAPH));
  203|      0|}
  204|       |bool is_dash(wchar32 ch)
  205|      0|{
  206|      0|	return wc_istype(ch, _(Pd_DASH)|_(Pd_HYPHEN)|_(Sm_MINUS));
  207|      0|}
  208|       |bool is_hyphen(wchar32 ch)
  209|      0|{
  210|      0|	return wc_istype(ch, _(Pd_HYPHEN)|_(Po_HYPHEN));
  211|      0|}
  212|       |bool is_quotation(wchar32 ch)
  213|      0|{
  214|      0|	return wc_istype(ch, _(Po_QUOTE)|_(Ps_QUOTE)|_(Pe_QUOTE)|_(Pi_QUOTE)|_(Pf_QUOTE)|
  215|      0|		_(Po_SINGLE_QUOTE)|_(Ps_SINGLE_QUOTE)|_(Pe_SINGLE_QUOTE)|_(Pi_SINGLE_QUOTE)|_(Pf_SINGLE_QUOTE));
  216|       |
  217|      0|}
  218|       |bool is_terminal(wchar32 ch)
  219|      0|{
  220|      0|	return wc_istype(ch, _(Po_TERMINAL));
  221|      0|}
  222|       |bool is_paired_punct(wchar32 ch)
  223|      0|{
  224|      0|	return wc_istype(ch, _(Ps_START)|_(Pe_END) |
  225|      0|		_(Ps_QUOTE)|_(Pe_QUOTE)|_(Pi_QUOTE)|_(Pf_QUOTE)|
  226|      0|		_(Ps_SINGLE_QUOTE)|_(Pe_SINGLE_QUOTE)|_(Pi_SINGLE_QUOTE)|_(Pf_SINGLE_QUOTE));
  227|      0|}
  228|       |bool is_left_punct(wchar32 ch)
  229|      0|{
  230|      0|	return wc_istype(ch, _(Ps_START)|_(Ps_QUOTE)|_(Ps_SINGLE_QUOTE));
  231|      0|}
  232|       |bool is_right_punct(wchar32 ch)
  233|      0|{
  234|      0|	return wc_istype(ch, _(Pe_END)|_(Pe_QUOTE)|_(Pe_SINGLE_QUOTE));
  235|      0|}
  236|       |bool is_combining(wchar32 ch)
  237|      0|{
  238|      0|	return wc_istype(ch, _(Mc_SPACING)|_(Mn_NONSPACING)|_(Me_ENCLOSING));
  239|      0|}
  240|       |bool is_nonspacing(wchar32 ch)
  241|      0|{
  242|      0|	return wc_istype(ch, _(Mn_NONSPACING)|_(Me_ENCLOSING));
  243|      0|}
  244|       |bool is_alphabetic(wchar32 ch)
  245|      0|{
  246|      0|	return wc_istype(ch, _(Lu_UPPER)|_(Ll_LOWER)|_(Lt_TITLE)|
  247|      0|		_(Lm_EXTENDER)|_(Lm_LETTER)|_(Lo_OTHER)|
  248|      0|		_(Nl_LETTER)
  249|      0|	);
  250|      0|}
  251|       |bool is_ideographic(wchar32 ch)
  252|      0|{
  253|      0|	return wc_istype(ch, _(Lo_IDEOGRAPH)|_(Nl_IDEOGRAPH));
  254|      0|}
  255|       |bool is_katakana(wchar32 ch)
  256|      0|{
  257|      0|	return wc_istype(ch, _(Lo_KATAKANA));
  258|      0|}
  259|       |bool is_hiragana(wchar32 ch)
  260|      0|{
  261|      0|	return wc_istype(ch, _(Lo_HIRAGANA));
  262|      0|}
  263|       |bool is_hangul_leading(wchar32 ch)
  264|      0|{
  265|      0|	return wc_istype(ch, _(Lo_LEADING));
  266|      0|}
  267|       |bool is_hangul_vowel(wchar32 ch)
  268|      0|{
  269|      0|	return wc_istype(ch, _(Lo_VOWEL));
  270|      0|}
  271|       |bool is_hangul_trailing(wchar32 ch)
  272|      0|{
  273|      0|	return wc_istype(ch, _(Lo_TRAILING));
  274|      0|}
  275|       |bool is_hexdigit(wchar32 ch)
  276|      0|{
  277|      0|	return (wc_info(ch) & IS_XDIGIT) != 0;
  278|      0|}
  279|       |bool is_decdigit(wchar32 ch)
  280|      0|{
  281|      0|	return wc_istype(ch, _(Nd_DIGIT));
  282|      0|}
  283|       |bool is_numeric(wchar32 ch)
  284|      0|{
  285|      0|	return wc_istype(ch, _(Nd_DIGIT)|_(Nl_LETTER)|_(Nl_IDEOGRAPH)|_(No_OTHER));
  286|      0|}
  287|       |bool is_currency(wchar32 ch)
  288|      0|{
  289|      0|	return wc_istype(ch, _(Sc_CURRENCY));
  290|      0|}
  291|       |bool is_math(wchar32 ch)
  292|      0|{
  293|      0|	return wc_istype(ch, _(Sm_MATH));
  294|      0|}
  295|       |bool is_symbol(wchar32 ch)
  296|      0|{
  297|      0|	return wc_istype(ch, _(Sm_MATH)|_(Sm_MINUS)|_(Sc_CURRENCY)|_(Sk_MODIFIER)|_(So_OTHER));
  298|      0|}
  299|       |bool is_idstart(wchar32 ch) // unicode
  300|      0|{
  301|      0|	return wc_istype(ch,
  302|      0|		_(Lu_UPPER)|_(Ll_LOWER)|_(Lt_TITLE)|_(Lm_EXTENDER)|_(Lm_LETTER)|
  303|      0|		_(Lo_OTHER)|_(Lo_IDEOGRAPH)|_(Lo_KATAKANA)|_(Lo_HIRAGANA)|
  304|      0|		_(Lo_LEADING)|_(Lo_VOWEL)|_(Lo_TRAILING)|
  305|      0|		_(Nl_LETTER)
  306|      0|	);
  307|      0|}
  308|       |bool is_idignorable(wchar32 ch)
  309|      0|{
  310|      0|	return is_ignorable_cntrl(ch);
  311|      0|}
  312|       |bool is_idpart(wchar32 ch) // unicode
  313|      0|{
  314|      0|	return is_idignorable(ch) || is_idstart(ch) || wc_istype(ch,
  315|      0|		_(Mn_NONSPACING)|_(Mc_SPACING)|_(Nd_DIGIT)|_(Pc_CONNECTOR)
  316|      0|	);
  317|      0|}
  318|       |bool is_nmstart(wchar32 ch) // xml
  319|      0|{
  320|      0|	return ch == ':' || ch == '_' || ((wc_info(ch) & IS_COMPAT) == 0 &&
  321|      0|		wc_istype(ch,
  322|      0|			_(Lu_UPPER)|_(Ll_LOWER)|_(Lt_TITLE)|_(Lm_LETTER)|
  323|      0|			_(Lo_OTHER)|_(Lo_IDEOGRAPH)|_(Lo_KATAKANA)|_(Lo_HIRAGANA)|
  324|      0|			_(Lo_LEADING)|_(Lo_VOWEL)|_(Lo_TRAILING)|
  325|      0|			_(Nl_LETTER)
  326|      0|		));
  327|      0|}
  328|       |int is_nmchar(wchar32 ch) // xml
  329|      0|{
  330|      0|	return is_nmstart(ch) || ch == '.' || ch == '-' ||
  331|      0|		((wc_info(ch) & IS_COMPAT) == 0 &&
  332|      0|			wc_istype(ch,
  333|      0|				_(Lm_EXTENDER)|_(Po_EXTENDER)|
  334|      0|				_(Mc_SPACING)|_(Mn_NONSPACING)|_(Nd_DIGIT)|
  335|      0|				_(Nl_IDEOGRAPH)
  336|      0|			));
  337|      0|}
  338|       |bool is_low_surrogate(wchar32 ch)
  339|      0|{
  340|      0|	return wc_istype(ch, _(Cs_LOW));
  341|      0|}
  342|       |bool is_high_surrogate(wchar32 ch)
  343|      0|{
  344|      0|	return wc_istype(ch, _(Cs_HIGH));
  345|      0|}
  346|       |bool is_nonbreak(wchar32 ch)
  347|      0|{
  348|      0|	return (wc_info(ch) & IS_NONBREAK) != 0;
  349|      0|}
  350|       |bool is_private(wchar32 ch)
  351|      0|{
  352|      0|	return (wc_info(ch) & IS_PRIVATE) && !wc_istype(ch, _(Cs_HIGH));
  353|      0|}
  354|       |bool is_unassigned(wchar32 ch)
  355|      0|{
  356|      0|	int i = wc_info(ch);
  357|      0|	return ((i & 0x3F) == 0) && !(i & IS_PRIVATE);
  358|      0|}
  359|       |bool is_private_high_surrogate(wchar32 ch)
  360|      0|{
  361|      0|	return wc_istype(ch, _(Cs_HIGH)) && (wc_info(ch) & IS_PRIVATE);
  362|      0|}
  363|       |bool is_composed(wchar32 ch)
  364|      0|{
  365|      0|	return wc_info(ch) & (IS_COMPAT|IS_CANON) ? true : false;
  366|      0|}
  367|       |bool is_canon_composed(wchar32 ch)
  368|      0|{
  369|      0|	return wc_info(ch) & IS_CANON ? true : false;
  370|      0|}
  371|       |
  372|       |// transformations
  373|       |
  374|       |wchar32 to_lower(wchar32 ch)
  375|      0|{
  376|      0|	i32 i = wc_info(ch);
  377|      0|	return (wchar32)(ch + ((i & TO_LOWER) ? (i >> SVAL_OFFSET) : 0));
  378|      0|}
  379|       |wchar32 to_upper(wchar32 ch)
  380|      0|{
  381|      0|	i32 i = wc_info(ch);
  382|      0|	return (wchar32)(ch - ((i & TO_UPPER) ? (i >> SVAL_OFFSET) : 0));
  383|      0|}
  384|       |wchar32 to_title(wchar32 ch)
  385|      0|{
  386|      0|	i32 i = wc_info(ch);
  387|      0|	wchar32 ret = ch;
  388|      0|	if (i & TO_TITLE) {
  389|      0|		if (wc_istype(ch, _(Lu_UPPER)))
  390|      0|			ret++;
  391|      0|		else if (wc_istype(ch, _(Ll_LOWER)))
  392|      0|			ret--;
  393|      0|	} else if (i & TO_UPPER) {
  394|      0|		ret = (wchar32)(ret - (i >> SVAL_OFFSET));
  395|      0|	}
  396|      0|	return ret;
  397|      0|}
  398|       |int to_digit(wchar32 ch)
  399|      0|{
  400|      0|	i32 i = wc_info(ch);
  401|      0|	return (i & IS_DIGIT) ? (i >> SVAL_OFFSET) : -1;
  402|      0|}
  403|       |
  404|       |// BIDI properties (C2_...)
  405|       |
  406|      0|int is_bidi_left(wchar32 ch)    {return ((wc_info(ch) >> BIDI_OFFSET) & 15) == 1;}
  407|      0|int is_bidi_right(wchar32 ch)   {return ((wc_info(ch) >> BIDI_OFFSET) & 15) == 2;}
  408|      0|int is_bidi_euronum(wchar32 ch) {return ((wc_info(ch) >> BIDI_OFFSET) & 15) == 3;}
  409|      0|int is_bidi_eurosep(wchar32 ch) {return ((wc_info(ch) >> BIDI_OFFSET) & 15) == 4;}
  410|      0|int is_bidi_euroterm(wchar32 ch){return ((wc_info(ch) >> BIDI_OFFSET) & 15) == 5;}
  411|      0|int is_bidi_arabnum(wchar32 ch) {return ((wc_info(ch) >> BIDI_OFFSET) & 15) == 6;}
  412|      0|int is_bidi_commsep(wchar32 ch) {return ((wc_info(ch) >> BIDI_OFFSET) & 15) == 7;}
  413|      0|int is_bidi_blocksep(wchar32 ch){return ((wc_info(ch) >> BIDI_OFFSET) & 15) == 8;}
  414|      0|int is_bidi_segmsep(wchar32 ch) {return ((wc_info(ch) >> BIDI_OFFSET) & 15) == 9;}
  415|      0|int is_bidi_space(wchar32 ch)   {return ((wc_info(ch) >> BIDI_OFFSET) & 15) == 10;}
  416|      0|int is_bidi_neutral(wchar32 ch) {return ((wc_info(ch) >> BIDI_OFFSET) & 15) == 11;}
  417|      0|int is_bidi_notappl(wchar32 ch) {return ((wc_info(ch) >> BIDI_OFFSET) & 15) == 0;}
  418|       |
  419|       |// C properties (C1_...)
  420|       |
  421|       |bool is_space(wchar32 ch) // == is_whitespace
  422|      0|{
  423|      0|	return is_whitespace(ch);
  424|      0|}
  425|       |bool is_lower(wchar32 ch)
  426|      0|{
  427|      0|	return wc_istype(ch, _(Ll_LOWER));
  428|      0|}
  429|       |bool is_upper(wchar32 ch)
  430|      0|{
  431|      0|	return wc_istype(ch, _(Lu_UPPER));
  432|      0|}
  433|       |bool is_alpha(wchar32 ch)
  434|      0|{
  435|      0|	return wc_istype(ch,
  436|      0|		_(Lu_UPPER)|_(Ll_LOWER)|_(Lt_TITLE)|_(Lm_LETTER)|_(Lm_EXTENDER)|
  437|      0|		_(Lo_OTHER)|_(Lo_IDEOGRAPH)|_(Lo_KATAKANA)|_(Lo_HIRAGANA)|
  438|      0|		_(Lo_LEADING)|_(Lo_VOWEL)|_(Lo_TRAILING)
  439|      0|	);
  440|      0|}
  441|       |bool is_alnum(wchar32 ch)
  442|      0|{
  443|      0|	return wc_istype(ch,
  444|      0|		_(Lu_UPPER)|_(Ll_LOWER)|_(Lt_TITLE)|_(Lm_LETTER)|_(Lm_EXTENDER)|
  445|      0|		_(Lo_OTHER)|_(Lo_IDEOGRAPH)|_(Lo_KATAKANA)|_(Lo_HIRAGANA)|
  446|      0|		_(Lo_LEADING)|_(Lo_VOWEL)|_(Lo_TRAILING)|
  447|      0|		_(Nd_DIGIT)|_(Nl_LETTER)|_(Nl_IDEOGRAPH)|_(No_OTHER)
  448|      0|	);
  449|      0|}
  450|       |bool is_punct(wchar32 ch)
  451|      0|{
  452|      0|	return wc_istype(ch,
  453|      0|		_(Pd_DASH)|
  454|      0|		_(Pd_HYPHEN)|_(Ps_START)|_(Ps_QUOTE)|_(Pe_END)|_(Pe_QUOTE)|_(Pc_CONNECTOR)|
  455|      0|		_(Po_OTHER)|_(Po_QUOTE)|_(Po_TERMINAL)|_(Po_EXTENDER)|_(Po_HYPHEN)|
  456|      0|		_(Pi_QUOTE)|_(Pf_QUOTE)
  457|      0|	);
  458|      0|}
  459|      0|bool is_xdigit(wchar32 ch) {return is_hexdigit(ch);}
  460|      0|bool is_digit(wchar32 ch) {return is_decdigit(ch);}
  461|      0|bool is_graph(wchar32 ch) {return is_alnum(ch)||is_punct(ch)||is_symbol(ch);}
  462|       |bool is_blank(wchar32 ch)
  463|      0|{
  464|      0|	return wc_istype(ch, _(Zs_SPACE)|_(Zs_ZWSPACE)) || ch == '\t';
  465|      0|}
  466|      0|bool is_print(wchar32 ch) {return is_alnum(ch)||is_punct(ch)||is_symbol(ch)||is_blank(ch);}
  467|       |
  468|       |#undef _
  469|       |
  470|       |
  471|       |#define UCS2_SURROGATE_CHAR 0x046C // CAPITAL IOTIFIED BIG YUS
  472|       |
  473|       |#endif

/home/johnpaul/pire/pire/stub/utf8.cpp:
    1|       |/*
    2|       | * utf8.cpp -- the wrapper for compiling Unicode-handling routines
    3|       | *             borrowed from Yandex internals
    4|       | *
    5|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    6|       | *                          Alexander Gololobov <agololobov@gmail.com>
    7|       | *
    8|       | * This file is part of Pire, the Perl Incompatible
    9|       | * Regular Expressions library.
   10|       | *
   11|       | * Pire is free software: you can redistribute it and/or modify
   12|       | * it under the terms of the GNU Lesser Public License as published by
   13|       | * the Free Software Foundation, either version 3 of the License, or
   14|       | * (at your option) any later version.
   15|       | * 
   16|       | * Pire is distributed in the hope that it will be useful,
   17|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   18|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   19|       | * GNU Lesser Public License for more details.
   20|       | * You should have received a copy of the GNU Lesser Public License
   21|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   22|       | */
   23|       |
   24|       |
   25|       |#include <string.h>
   26|       |#include "defaults.h"
   27|       |#include "singleton.h"
   28|       |#include "stl.h"
   29|       |
   30|       |#define DECLARE_NOCOPY(klass) private: klass(const klass&); klass& operator = (const klass&);
   31|       |
   32|       |namespace Pire {
   33|       |
   34|       |#include "doccodes_h.h"
   35|       |#include "unidata_h.h"
   36|       |#include "codepage_h.h"
   37|       |#include "unidata_cpp.h"
   38|       |
   39|       |	const wchar32 BROKEN_RUNE = (wchar32) -1;
   40|       |
   41|       |	const Recoder rcdr_to_lower[1] = {};
   42|       |	const Recoder rcdr_to_upper[1] = {};
   43|       |	const Recoder rcdr_to_title[1] = {};
   44|       |	const CodePage *codepage_by_doccodes[1] = {};
   45|      0|	const CodePage *CodePageByName(const char*) { return 0; }
   46|       |
   47|      0|	NCodepagePrivate::TCodepagesMap::TCodepagesMap() {}
   48|       |}

/home/johnpaul/pire/pire/vbitset.h:
    1|       |/*
    2|       | * vbitset.h -- a bitset of variable size.
    3|       | *
    4|       | * Copyright (c) 2007-2010, Dmitry Prokoptsev <dprokoptsev@gmail.com>,
    5|       | *                          Alexander Gololobov <agololobov@gmail.com>
    6|       | *
    7|       | * This file is part of Pire, the Perl Incompatible
    8|       | * Regular Expressions library.
    9|       | *
   10|       | * Pire is free software: you can redistribute it and/or modify
   11|       | * it under the terms of the GNU Lesser Public License as published by
   12|       | * the Free Software Foundation, either version 3 of the License, or
   13|       | * (at your option) any later version.
   14|       | * 
   15|       | * Pire is distributed in the hope that it will be useful,
   16|       | * but WITHOUT ANY WARRANTY; without even the implied warranty of
   17|       | * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   18|       | * GNU Lesser Public License for more details.
   19|       | * You should have received a copy of the GNU Lesser Public License
   20|       | * along with Pire.  If not, see <http://www.gnu.org/licenses>.
   21|       | */
   22|       |
   23|       |
   24|       |#ifndef PIRE_VBITSET_H
   25|       |#define PIRE_VBITSET_H
   26|       |
   27|       |
   28|       |#include "stub/stl.h"
   29|       |#include <string.h>
   30|       |
   31|       |namespace Pire {
   32|       |
   33|       |#ifdef _DEBUG
   34|       |#define VBITSET_CHECK_SIZE(x) CheckSize(x)
   35|       |#else
   36|       |#define VBITSET_CHECK_SIZE(x) x
   37|       |#endif
   38|       |
   39|       |/// A bitset with variable width
   40|       |class BitSet {
   41|       |public:
   42|       |	typedef size_t value_type;
   43|       |	typedef size_t* pointer;
   44|       |	typedef size_t& reference;
   45|       |	typedef const size_t& const_reference;
   46|       |
   47|       |	class const_iterator;
   48|       |
   49|       |	BitSet()
   50|       |		: m_data(1, 1)
   51|      0|	{
   52|      0|	}
   53|       |	BitSet(size_t size)
   54|       |		: m_data(RoundUp(size + 1) + 1)
   55|       |		, m_size(size)
   56|      0|	{
   57|      0|		m_data[RoundDown(size)] |= (1U << Remainder(size));
   58|      0|	}
   59|       |
   60|       |	void Swap(BitSet& s)
   61|      0|	{
   62|      0|		m_data.swap(s.m_data);
   63|      0|		DoSwap(m_size, s.m_size);
   64|      0|	}
   65|       |
   66|       |	/// Sets the specified bit to 1.
   67|      0|	void Set(size_t pos) {
   68|      0|		m_data[RoundDown(VBITSET_CHECK_SIZE(pos))] |= (1U << Remainder(pos));
   69|      0|	}
   70|       |
   71|       |	/// Resets the specified bit to 0.
   72|      0|	void Reset(size_t pos) {
   73|      0|		m_data[RoundDown(VBITSET_CHECK_SIZE(pos))] &= ~(1U << Remainder(pos));
   74|      0|	}
   75|       |
   76|       |	/// Checks whether the specified bit is set to 1.
   77|      0|	bool Test(size_t pos) const {
   78|      0|		return (m_data[RoundDown(VBITSET_CHECK_SIZE(pos))] & (1U << Remainder(pos))) != 0;
   79|      0|	}
   80|       |
   81|      0|	size_t Size() const {
   82|      0|		return m_size;
   83|      0|	}
   84|       |
   85|       |	void Resize(size_t newsize)
   86|      0|	{
   87|      0|		m_data.resize(RoundUp(newsize + 1));
   88|      0|		if (Remainder(newsize) && !m_data.empty())
   89|      0|			m_data[m_data.size() - 1] &= ((1U << Remainder(newsize)) - 1); // Clear tail
   90|      0|		m_data[RoundDown(newsize)] |= (1U << Remainder(newsize));
   91|      0|	}
   92|       |
   93|       |	/// Resets all bits to 0.
   94|      0|	void Clear() { memset(&m_data[0], 0, m_data.size() * sizeof(ContainerType)); }
   95|       |
   96|       |private:
   97|       |	typedef unsigned char ContainerType;
   98|       |	static const size_t ItemSize = sizeof(ContainerType) * 8;
   99|       |	TVector<ContainerType> m_data;
  100|       |	size_t m_size;
  101|       |
  102|      0|	static size_t RoundUp(size_t x)   { return x / ItemSize + ((x % ItemSize) ? 1 : 0); }
  103|      0|	static size_t RoundDown(size_t x) { return x / ItemSize; }
  104|      0|	static size_t Remainder(size_t x) { return x % ItemSize; }
  105|       |
  106|       |#ifdef _DEBUG
  107|       |	size_t CheckSize(size_t size) const
  108|       |	{
  109|       |		if (size < m_size)
  110|       |			return size;
  111|       |		else
  112|       |			throw Error("BitSet: subscript out of range");
  113|       |	}
  114|       |#endif
  115|       |};
  116|       |
  117|       |}
  118|       |
  119|       |#endif

